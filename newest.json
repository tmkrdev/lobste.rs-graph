[{"short_id":"obifny","short_id_url":"https://lobste.rs/s/obifny","created_at":"2024-11-15T17:22:30.000-06:00","title":"Maybe Bluesky has “won”","url":"https://anderegg.ca/2024/11/15/maybe-bluesky-has-won","score":17,"flags":1,"comment_count":8,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/obifny/maybe_bluesky_has_won","submitter_user":"winter","user_is_author":false,"tags":["distributed"]},{"short_id":"o7tlpa","short_id_url":"https://lobste.rs/s/o7tlpa","created_at":"2024-11-15T14:43:13.000-06:00","title":"Huawei develops 72TB SSD-tape hybrid storage device","url":"https://www.tomshardware.com/pc-components/storage/huawei-develops-ssd-tape-hybrid-storage-device-for-warm-and-cold-storage-first-gen-med-drive-holds-up-to-72tb","score":8,"flags":0,"comment_count":2,"description":"\u003cp\u003eThis has the same energy as using an old steam locomotive boiler to drive a generator powering an electric motor. Having said that, I would buy one.\u003c/p\u003e\n","description_plain":"This has the same energy as using an old steam locomotive boiler to drive a generator powering an electric motor. Having said that, I would buy one.","comments_url":"https://lobste.rs/s/o7tlpa/huawei_develops_72tb_ssd_tape_hybrid","submitter_user":"ahelwer","user_is_author":false,"tags":["hardware"]},{"short_id":"rgcgev","short_id_url":"https://lobste.rs/s/rgcgev","created_at":"2024-11-15T14:25:06.000-06:00","title":"Retrofitting spatial safety to hundreds of millions of lines of C++","url":"https://security.googleblog.com/2024/11/retrofitting-spatial-safety-to-hundreds.html?m=1","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/rgcgev/retrofitting_spatial_safety_hundreds","submitter_user":"raymii","user_is_author":false,"tags":["c++"]},{"short_id":"eybzqx","short_id_url":"https://lobste.rs/s/eybzqx","created_at":"2024-11-15T14:15:55.000-06:00","title":"Ed Zitron - Why Are All Tech Products Now Shit?","url":"https://youtu.be/7Slib2bbMs4","score":1,"flags":1,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/eybzqx/ed_zitron_why_are_all_tech_products_now","submitter_user":"metahost","user_is_author":false,"tags":["culture","video"]},{"short_id":"xkccev","short_id_url":"https://lobste.rs/s/xkccev","created_at":"2024-11-15T13:08:41.000-06:00","title":"In Memoriam: Thomas E. Kurtz, co-inventor of BASIC, 1928–2024","url":"https://computerhistory.org/blog/in-memoriam-thomas-e-kurtz-1928-2024/","score":17,"flags":0,"comment_count":2,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/xkccev/memoriam_thomas_e_kurtz_co_inventor_basic","submitter_user":"xmodem","user_is_author":false,"tags":["compsci","culture","person","plt"]},{"short_id":"6kfvtg","short_id_url":"https://lobste.rs/s/6kfvtg","created_at":"2024-11-15T11:30:38.000-06:00","title":"What To Use Instead of PGP","url":"https://soatok.blog/2024/11/15/what-to-use-instead-of-pgp/","score":55,"flags":1,"comment_count":51,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/6kfvtg/what_use_instead_pgp","submitter_user":"deejayy","user_is_author":false,"tags":["cryptography","security"]},{"short_id":"uabxfu","short_id_url":"https://lobste.rs/s/uabxfu","created_at":"2024-11-15T11:13:53.000-06:00","title":"Gliimly is a programming language for web services","url":"https://gliimly.github.io/","score":5,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/uabxfu/gliimly_is_programming_language_for_web","submitter_user":"emschwartz","user_is_author":false,"tags":["api","programming"]},{"short_id":"gxb69j","short_id_url":"https://lobste.rs/s/gxb69j","created_at":"2024-11-15T09:55:37.000-06:00","title":"Thoughts on Django’s Core","url":"https://buttondown.com/carlton/archive/thoughts-on-djangos-core","score":7,"flags":0,"comment_count":2,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/gxb69j/thoughts_on_django_s_core","submitter_user":"zverok","user_is_author":false,"tags":["python"]},{"short_id":"zvwwcl","short_id_url":"https://lobste.rs/s/zvwwcl","created_at":"2024-11-15T09:35:54.000-06:00","title":"Fuzzing the PHP Interpreter via Dataflow Fusion","url":"https://arxiv.org/pdf/2410.21713","score":3,"flags":0,"comment_count":0,"description":"\u003cblockquote\u003e\n\u003cp\u003ePHP, a dominant scripting language in web development, powers a vast range of websites, from personal blogs to major platforms. While existing research primarily focuses on PHP application-level security issues like code injection, memory errors within the PHP interpreter have been largely overlooked. These memory errors, prevalent due to the PHP interpreter’s extensive C codebase, pose significant risks to the confidentiality, integrity, and availability of PHP servers. This paper introduces FlowFusion, the first automatic fuzzing framework specifically designed to detect memory errors in the PHP interpreter. FlowFusion leverages dataflow as an efficient representation of test cases maintained by PHP developers, merging two or more test cases to produce fused test cases with more complex code semantics. Moreover, FlowFusion employs strategies such as test mutation, interface fuzzing, and environment crossover to further facilitate memory error detection. In our evaluation, FlowFusion identified 56 unknown memory errors in the PHP interpreter, with 38 fixed and 4 confirmed. We compared FlowFusion against the official test suite and a naive test concatenation approach, demonstrating that FlowFusion can detect new bugs that these methods miss, while also achieving greater code coverage. Furthermore, FlowFusion outperformed state-of-the-art fuzzers AFL++ and Polyglot, covering 24% more lines of code after 24 hours of fuzzing under identical execution environments. FlowFusion has been acknowledged by PHP developers, and we believe our approach offers a practical tool for enhancing the security of the PHP interpreter.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2410.21713\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"\u003e PHP, a dominant scripting language in web development, powers a vast range of websites, from personal blogs to major platforms. While existing research primarily focuses on PHP application-level security issues like code injection, memory errors within the PHP interpreter have been largely overlooked. These memory errors, prevalent due to the PHP interpreter's extensive C codebase, pose significant risks to the confidentiality, integrity, and availability of PHP servers. This paper introduces FlowFusion, the first automatic fuzzing framework specifically designed to detect memory errors in the PHP interpreter. FlowFusion leverages dataflow as an efficient representation of test cases maintained by PHP developers, merging two or more test cases to produce fused test cases with more complex code semantics. Moreover, FlowFusion employs strategies such as test mutation, interface fuzzing, and environment crossover to further facilitate memory error detection. In our evaluation, FlowFusion identified 56 unknown memory errors in the PHP interpreter, with 38 fixed and 4 confirmed. We compared FlowFusion against the official test suite and a naive test concatenation approach, demonstrating that FlowFusion can detect new bugs that these methods miss, while also achieving greater code coverage. Furthermore, FlowFusion outperformed state-of-the-art fuzzers AFL++ and Polyglot, covering 24% more lines of code after 24 hours of fuzzing under identical execution environments. FlowFusion has been acknowledged by PHP developers, and we believe our approach offers a practical tool for enhancing the security of the PHP interpreter.\r\n\r\n[arXiv](https://arxiv.org/abs/2410.21713)","comments_url":"https://lobste.rs/s/zvwwcl/fuzzing_php_interpreter_via_dataflow","submitter_user":"calvin","user_is_author":false,"tags":["pdf","php","security","testing"]},{"short_id":"kh3hrz","short_id_url":"https://lobste.rs/s/kh3hrz","created_at":"2024-11-15T08:36:50.000-06:00","title":"Implementing Type Systems as Macros","url":"https://lambdaland.org/posts/2023-08-14_types_with_macros/","score":10,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/kh3hrz/implementing_type_systems_as_macros","submitter_user":"dpk","user_is_author":false,"tags":["lisp","plt"]},{"short_id":"qgr7hd","short_id_url":"https://lobste.rs/s/qgr7hd","created_at":"2024-11-15T07:46:39.000-06:00","title":"You Can't Build Interactive Web Apps Except as Single Page Applications... And Other Myths","url":"https://htmx.org/essays/you-cant/","score":17,"flags":0,"comment_count":7,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/qgr7hd/you_can_t_build_interactive_web_apps","submitter_user":"romes","user_is_author":false,"tags":["web"]},{"short_id":"qbbo7o","short_id_url":"https://lobste.rs/s/qbbo7o","created_at":"2024-11-15T04:39:25.000-06:00","title":"Announcing Prometheus 3.0","url":"https://prometheus.io/blog/2024/11/14/prometheus-3-0/","score":42,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/qbbo7o/announcing_prometheus_3_0","submitter_user":"asymmetric","user_is_author":false,"tags":["devops","release"]},{"short_id":"aqowpy","short_id_url":"https://lobste.rs/s/aqowpy","created_at":"2024-11-15T04:17:21.000-06:00","title":"How Westwood VQA works","url":"https://30fps.net/pages/vqa/","score":7,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/aqowpy/how_westwood_vqa_works","submitter_user":"pekkavaa","user_is_author":true,"tags":["graphics","retrocomputing"]},{"short_id":"lkpxbs","short_id_url":"https://lobste.rs/s/lkpxbs","created_at":"2024-11-15T04:13:36.000-06:00","title":"What are you doing this weekend?","url":"","score":11,"flags":0,"comment_count":23,"description":"\u003cp\u003eFeel free to tell what you plan on doing this weekend and even ask for help or feedback.\u003c/p\u003e\n\u003cp\u003ePlease keep in mind it’s more than OK to do nothing at all too!\u003c/p\u003e\n","description_plain":"Feel free to tell what you plan on doing this weekend and even ask for help or feedback.\r\n\r\nPlease keep in mind it’s more than OK to do nothing at all too!","comments_url":"https://lobste.rs/s/lkpxbs/what_are_you_doing_this_weekend","submitter_user":"caius","user_is_author":true,"tags":["ask","programming"]},{"short_id":"lefvgm","short_id_url":"https://lobste.rs/s/lefvgm","created_at":"2024-11-15T03:33:33.000-06:00","title":"Stop Making Me Memorize The Borrow Checker","url":"https://erikmcclure.com/blog/stop-making-me-memorize-borrow-checker/","score":47,"flags":0,"comment_count":34,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/lefvgm/stop_making_me_memorize_borrow_checker","submitter_user":"erikmcclure","user_is_author":true,"tags":["rust"]},{"short_id":"8lubts","short_id_url":"https://lobste.rs/s/8lubts","created_at":"2024-11-15T03:05:08.000-06:00","title":"Why is std::pin::Pin so weird?","url":"https://sander.saares.eu/2024/11/06/why-is-stdpinpin-so-weird/","score":9,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/8lubts/why_is_std_pin_pin_so_weird","submitter_user":"bitfield","user_is_author":false,"tags":["rust"]},{"short_id":"q3as3w","short_id_url":"https://lobste.rs/s/q3as3w","created_at":"2024-11-15T01:30:45.000-06:00","title":"Music production on POWER: an adventure in porting","url":"https://www.talospace.com/2024/09/music-production-on-power-adventure-in.html","score":5,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/q3as3w/music_production_on_power_adventure","submitter_user":"habibalamin","user_is_author":false,"tags":["programming"]},{"short_id":"oe3ir2","short_id_url":"https://lobste.rs/s/oe3ir2","created_at":"2024-11-15T00:08:30.000-06:00","title":"Final Encoding in RPython Interpreters","url":"https://pypy.org/posts/2024/11/guest-post-final-encoding-in-rpython.html","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/oe3ir2/final_encoding_rpython_interpreters","submitter_user":"Corbin","user_is_author":true,"tags":["compilers","plt","python"]},{"short_id":"vv6jns","short_id_url":"https://lobste.rs/s/vv6jns","created_at":"2024-11-14T21:56:53.000-06:00","title":"Plan 9 history and development (2023)","url":"http://youtube.com/watch?v=mCiRxM8dOSY","score":10,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/vv6jns/plan_9_history_development_2023","submitter_user":"alurm","user_is_author":false,"tags":["historical","osdev","unix","video"]},{"short_id":"x5cc0v","short_id_url":"https://lobste.rs/s/x5cc0v","created_at":"2024-11-14T21:24:33.000-06:00","title":"What makes concurrency so hard?","url":"https://buttondown.com/hillelwayne/archive/what-makes-concurrency-so-hard/","score":9,"flags":0,"comment_count":3,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/x5cc0v/what_makes_concurrency_so_hard","submitter_user":"av","user_is_author":false,"tags":["programming"]},{"short_id":"ybjlyw","short_id_url":"https://lobste.rs/s/ybjlyw","created_at":"2024-11-14T19:47:04.000-06:00","title":"Dusting off Dreamcast Linux","url":"http://oldvcr.blogspot.com/2023/02/dusting-off-dreamcast-linux.html?m=1","score":15,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/ybjlyw/dusting_off_dreamcast_linux","submitter_user":"UkiahSmith","user_is_author":false,"tags":["hardware","linux"]},{"short_id":"6k4rdq","short_id_url":"https://lobste.rs/s/6k4rdq","created_at":"2024-11-14T19:16:10.000-06:00","title":"Amazon S3 now supports up to 1 million buckets per AWS account","url":"https://aws.amazon.com/about-aws/whats-new/2024/11/amazon-s3-up-1-million-buckets-per-aws-account/","score":9,"flags":2,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/6k4rdq/amazon_s3_now_supports_up_1_million","submitter_user":"craigkerstiens","user_is_author":false,"tags":["programming"]},{"short_id":"6nzmkj","short_id_url":"https://lobste.rs/s/6nzmkj","created_at":"2024-11-14T17:28:19.000-06:00","title":"I've been working on a borrow checker for C... (also makes sure you `free`) (context in post text)","url":"https://gist.github.com/nikki93/2bb11237bf76fceb0bf687d6d9eef1b3#file-00-example-c","score":15,"flags":1,"comment_count":0,"description":"\u003cp\u003e[Making a quick post about this and I can write more in response to comments, but just wanted to share something from an experiment I did over the past couple weeks. I’ll do a writeup or video discussing more of this soon along with my C workflow generally.]\u003c/p\u003e\n\u003cp\u003eI wrote a borrow checker for C that uses libclang. You can see an example test case with the resulting checker output in the linked gist (this post’s title is the link).\u003c/p\u003e\n\u003cp\u003eBelow the checker output in the gist is the code for the borrow checker itself. The \u003ccode\u003emain\u003c/code\u003e function code quality is ¯_(ツ)_/¯ because it has some copypasta to read ‘compile_commands.json’ with libclang, and you should probably ignore that, I’ll be cleaning that up. The ‘Visit’ section is where the core of the checker lives. There’s a lot of statically-sized arrays and linear searches and repeat function calls but … it runs pretty fast and is far from the bottleneck in the build pipeline of project(s) I’m testing it on (checking takes 0.04 sec while the actual compile+link takes about 1 sec). The code is definitely still in a proof-of-concept state.\u003c/p\u003e\n\u003cp\u003eIt’s meant to pair with a codegen system I have that also generates \u003ccode\u003eTArray\u003c/code\u003e types and functions like \u003ccode\u003eTDealloc\u003c/code\u003e and \u003ccode\u003eTClone\u003c/code\u003e etc. that recurse through struct fields, and the codegen also generates other useful things like json serialization – that I use in my own projects. The codegen and checker currently work on a little game project I wrote as a pragmatic test for all this with Raylib. You can see what the codegen logic looks like here – \u003ca href=\"https://gist.github.com/nikki93/5752dff93fa4cb78c4750548cc588b64#file-00-generate-c-L318\" rel=\"ugc\"\u003ehttps://gist.github.com/nikki93/5752dff93fa4cb78c4750548cc588b64#file-00-generate-c-L318\u003c/a\u003e (big dump of my game’s code, not about the details as much as the structure) – there’s a simple ‘quasiquotation’ going on there, and you can see the game code in ‘game.c’ with ‘generated.{h,c}’ showing the generated API given the types in ‘game.c’. The codegen is from before I started using libclang so it uses a … homemade and incomplete … ‘parser’.\u003c/p\u003e\n\u003cp\u003e[Video of the game – https://youtu.be/EK_zuTqsKL4 – the first wave and first boss you see have their part layouts and firing patterns and emitters procedurally generated – I show some more generations and then also some hand-written bosses and opponents]\u003c/p\u003e\n\u003cp\u003eThe target use case is on app / game ‘business logic’ code written in a style that uses a bunch of arrays or other data structures and accesses things through ids or iteration, but has short-lived local pointers from those accesses and benefits from checking for invalidation of those pointers, and also of accidental copies or missed deallocs etc. of the data structures themselves. There can be a lot of this code that grows and churns with demands on project feature set and having automatic checking helps. I also always have asan+lsan running in development mode on my projects in addition to this. It’s not as catered right now towards, for example, the internal code of an allocator or something like that where you probably want some other system of checking correctness (lots of testing, fuzzing, proofs, thinking, …).\u003c/p\u003e\n\u003cp\u003e[For people familiar with Rust borrow check semantics / ‘linear types’ stuff generally: It avoids a lot of the complexities the Rust borrow checker deals with by not allowing structs to have pointers in them with (multiple) generic lifetime parameters, not needing to do much inference if at all, not dealing with escaping closures, etc. In the future it could have structs that just have one inferred lifetime parameter by analyzing them the same way as pointers currently. It also assumes the first parameter of a function is the one a returning pointer borrows from (eg. in \u003ccode\u003eFooArrayPush\u003c/code\u003e in the example), so you don’t need to annotate that.]\u003c/p\u003e\n\u003cp\u003e[This might miss some entire set of cases I didn’t think of yet, so there’s that…]\u003c/p\u003e\n\u003cp\u003e[Edit: Oh – it also doesn’t have immutable references yet, all references are mutable and exclusive (it does allow ‘reborrowing’) – \u003ccode\u003econst T *\u003c/code\u003e as an immutable borrow is something I will likely add]\u003c/p\u003e\n","description_plain":"[Making a quick post about this and I can write more in response to comments, but just wanted to share something from an experiment I did over the past couple weeks. I'll do a writeup or video discussing more of this soon along with my C workflow generally.]\r\n\r\nI wrote a borrow checker for C that uses libclang. You can see an example test case with the resulting checker output in the linked gist (this post's title is the link).\r\n\r\nBelow the checker output in the gist is the code for the borrow checker itself. The `main` function code quality is ¯\\_(ツ)_/¯ because it has some copypasta to read 'compile_commands.json' with libclang, and you should probably ignore that, I'll be cleaning that up. The 'Visit' section is where the core of the checker lives. There's a lot of statically-sized arrays and linear searches and repeat function calls but ... it runs pretty fast and is far from the bottleneck in the build pipeline of project(s) I'm testing it on (checking takes 0.04 sec while the actual compile+link takes about 1 sec). The code is definitely still in a proof-of-concept state.\r\n\r\nIt's meant to pair with a codegen system I have that also generates `TArray` types and functions like `TDealloc` and `TClone` etc. that recurse through struct fields, and the codegen also generates other useful things like json serialization -- that I use in my own projects. The codegen and checker currently work on a little game project I wrote as a pragmatic test for all this with Raylib. You can see what the codegen logic looks like here -- https://gist.github.com/nikki93/5752dff93fa4cb78c4750548cc588b64#file-00-generate-c-L318 (big dump of my game's code, not about the details as much as the structure) -- there's a simple 'quasiquotation' going on there, and you can see the game code in 'game.c' with 'generated.{h,c}' showing the generated API given the types in 'game.c'. The codegen is from before I started using libclang so it uses a ... homemade and incomplete ... 'parser'.\r\n\r\n[Video of the game -- https://youtu.be/EK_zuTqsKL4 -- the first wave and first boss you see have their part layouts and firing patterns and emitters procedurally generated -- I show some more generations and then also some hand-written bosses and opponents]\r\n\r\nThe target use case is on app / game 'business logic' code written in a style that uses a bunch of arrays or other data structures and accesses things through ids or iteration, but has short-lived local pointers from those accesses and benefits from checking for invalidation of those pointers, and also of accidental copies or missed deallocs etc. of the data structures themselves. There can be a lot of this code that grows and churns with demands on project feature set and having automatic checking helps. I also always have asan+lsan running in development mode on my projects in addition to this. It's not as catered right now towards, for example, the internal code of an allocator or something like that where you probably want some other system of checking correctness (lots of testing, fuzzing, proofs, thinking, ...).\r\n\r\n[For people familiar with Rust borrow check semantics / 'linear types' stuff generally: It avoids a lot of the complexities the Rust borrow checker deals with by not allowing structs to have pointers in them with (multiple) generic lifetime parameters, not needing to do much inference if at all, not dealing with escaping closures, etc. In the future it could have structs that just have one inferred lifetime parameter by analyzing them the same way as pointers currently. It also assumes the first parameter of a function is the one a returning pointer borrows from (eg. in `FooArrayPush` in the example), so you don't need to annotate that.]\r\n\r\n[This might miss some entire set of cases I didn't think of yet, so there's that...]\r\n\r\n[Edit: Oh -- it also doesn't have immutable references yet, all references are mutable and exclusive (it does allow 'reborrowing') -- `const T *` as an immutable borrow is something I will likely add]","comments_url":"https://lobste.rs/s/6nzmkj/i_ve_been_working_on_borrow_checker_for_c","submitter_user":"nikki93","user_is_author":true,"tags":["c"]},{"short_id":"mecr9q","short_id_url":"https://lobste.rs/s/mecr9q","created_at":"2024-11-14T17:18:09.000-06:00","title":"A Linux Desktop for the family","url":"https://chronicles.mad-scientist.club/tales/linux-desktop-for-the-family/","score":46,"flags":0,"comment_count":18,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/mecr9q/linux_desktop_for_family","submitter_user":"wezm","user_is_author":false,"tags":["linux"]},{"short_id":"swm85w","short_id_url":"https://lobste.rs/s/swm85w","created_at":"2024-11-14T16:55:49.000-06:00","title":"A rustc soundness bug in the wild","url":"https://specy.app/blog/posts/a-rustc-soundness-bug-in-the-wild","score":24,"flags":0,"comment_count":2,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/swm85w/rustc_soundness_bug_wild","submitter_user":"airdrop","user_is_author":false,"tags":["rust"]}]