[{"short_id":"wnmrkl","created_at":"2025-08-08T20:05:32.000-05:00","title":"A Spellchecker Used to Be a Major Feat of Software Engineering","url":"https://prog21.dadgum.com/29.html","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"runxiyu","user_is_author":false,"tags":["historical"],"short_id_url":"https://lobste.rs/s/wnmrkl","comments_url":"https://lobste.rs/s/wnmrkl/spellchecker_used_be_major_feat_software"},{"short_id":"vzr1b1","created_at":"2025-08-08T16:51:29.000-05:00","title":"Introducing spindle","url":"https://blog.tangled.sh/ci","score":1,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"adamcstephens","user_is_author":false,"tags":["nix","vcs"],"short_id_url":"https://lobste.rs/s/vzr1b1","comments_url":"https://lobste.rs/s/vzr1b1/introducing_spindle"},{"short_id":"bc53lh","created_at":"2025-08-08T16:35:30.000-05:00","title":"Lobsters Interview with Hwayne","url":"","score":9,"flags":0,"comment_count":3,"description":"\u003cp\u003eFor this \u003ca href=\"https://lobste.rs/t/interview\" rel=\"ugc\"\u003einterview\u003c/a\u003e, I spoke with \u003ca href=\"https://lobste.rs/~hwayne\" rel=\"ugc\"\u003ehwayne\u003c/a\u003e a few times.\u003c/p\u003e\n\u003cp\u003eLast week, we talked to \u003ca href=\"https://lobste.rs/s/2vfx6w/lobsters_interview_with_icefox\" rel=\"ugc\"\u003eicefox\u003c/a\u003e, next week we’ll hear from \u003ca href=\"https://lobste.rs/~matklad\" rel=\"ugc\"\u003ematklad\u003c/a\u003e. Thank you to my proof readers! \u0026lt;3\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eYo! To prove it’s me, here’s a hash of our last PM: \u003ccode\u003ea4332cf8fb02ff3f02de333343958021\u003c/code\u003e. Not for security, but to signal my values!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMuch of my childhood online was collecting common wisdom, memes, fuddlore and repeating them to signal my virtue. Growing has been the long path of killing those darlings. Anyway, I love your work!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLet’s see how fast I can disillusion you!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIntroduce yourself! How’d you discover programming and \u003ca href=\"https://en.wikipedia.org/wiki/Formal_methods\" rel=\"ugc\"\u003eFormal Methods\u003c/a\u003e (FM)?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI’m Hillel. I’m mostly known online for writing about software, especially FM (to make it more accessible), and history. In my free time I \u003ca href=\"https://www.instagram.com/p/COhMfsyA8z2/\" rel=\"ugc\"\u003ejuggle\u003c/a\u003e and make chocolate.\u003c/p\u003e\n\u003cp\u003eI always liked computers and tried to learn C++ to make video games as a teen: not an experience I’d recommend to people. (Actually, I learned Drape and Visual Basic before that. I also miss VB6, it had nice features). In college I did Physics and Math with the hope of becoming a physicist, but got scared off by grad school, because all of my friends who graduated before me, seemed miserable. Long hours, low pay, bad social life, and for five years…\u003c/p\u003e\n\u003cp\u003eBesides, universities and industrial labs push the boundaries of human knowledge, but I really like “pop research”: aggregating existing knowledge and presenting it in engaging or entertaining form. My dives into exotic languages are a good example, like \u003ca href=\"https://hillelwayne.com/post/j-notation/\" rel=\"ugc\"\u003eJ\u003c/a\u003e and Picat. Indeed, FM is a manifestation of my real passion of falling down rabbit holes researching. Besides, community puts me in touch with lots of academics and exotic tool users, who love to share their weird stuff with me, like \u003ca href=\"https://www.hillelwayne.com/post/minizinc/\" rel=\"ugc\"\u003eMiniZinc\u003c/a\u003e and constraint solving!\u003c/p\u003e\n\u003cp\u003eAnyway, I pivoted into programming because at the time (2013) that was the easiest way for educated people to switch career paths. And all the money was in webdev, so I became a webdev. Later at \u003cem\u003eespark\u003c/em\u003e, which managed iPad apps for elementary schools, our system ended up being “accidentally distributed”: interactions between us, Apple APIs, school infrastructure, and their mobile device managers led to lots of issues you see in distributed systems, despite us all doing Rails and JavaScript. At this point, two things happened:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eI researched Idris, which led me to internet arguments about FM, which in turn led me to reading the Amazon TLA+ paper “\u003ca href=\"https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf\" rel=\"ugc\"\u003eUse of FM at AWS\u003c/a\u003e”.\u003c/li\u003e\n\u003cli\u003eI was officially diagnosed with ADHD and put on Ritalin.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eImportant question for the interviewer: have you ever taken ADHD meds?\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI have not!\u003c/strong\u003e\nBasically, for the first couple of days after you start meds, you are a GOD. Nothing can stop you. You can do anything. After a few days, your body adjusts and balances out, so you get the ability to focus without the mania. For my first two days, I crammed TLA+. This head start really helped get over the hump. I immediately \u003ca href=\"https://medium.com/espark-engineering-blog/formal-methods-in-practice-8f20d72bce4f\" rel=\"ugc\"\u003ecaught some major bugs in the redesign\u003c/a\u003e, which made me fall in love. \u003cem\u003eCue years of trying to make it more accessible for people without the Ritalin God-mode head start!\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eBut evangelism is difficult. At \u003cem\u003eespark\u003c/em\u003e, nobody else wanted to learn TLA+ because I already knew it. The vibe was that it solved a one-off problem and they wouldn’t need it again. After I left, about once a quarter they would tell me about a new hairy bug that would have been caught by TLA+, always “a one-off problem that won’t happen again”.\u003c/p\u003e\n\u003cp\u003eI see this as a manifestation of just how high the cost is for these tools. If it took five minutes to learn and apply, they’d do it. But they expect weeks of practice to study and solve problems and think “ugh no”.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIn your evangelism, you talk of the business case sometimes. How do you balance that for a company vs. the personal effort/career hurdles of developers?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI often ask myself: Does spending ten hours learning FM or bash scripting really well help the average engineer more? Probably bash.  \u003cem\u003eRight now\u003c/em\u003e, FM is a very bottom-up practice where developers see it, get inspired, and apply it at their work. Very rarely is it top-down, where a VP or director mandates it. The researchers and evangelists —including me— are devs. The TLA+ foundation is trying to figure out how to make that jump though. We have \u003cem\u003eanecdotal\u003c/em\u003e claims of FM catching expensive bugs and saving money, but it’s hard to put numbers or measure the cost/reward, which makes decision-makers shy away.\u003c/p\u003e\n\u003cp\u003eThere’s then the perennial challenge of “okay we’ve modeled the specification, how do we actually make sure our implementation matches this?”\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe Go team wrote 2 implementations, to keep the \u003ca href=\"https://go.dev/ref/spec\" rel=\"ugc\"\u003espec\u003c/a\u003e honest.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePart of the value of a formal specification (spec) is that it can be so abstract. Specs omit many details a generator must make. But there’s vast potential in using specs to \u003cem\u003etest\u003c/em\u003e code. MongoDB has done a lot and I’ve made “test generators” for clients (which I’ll blog about.) I’m generally a fan of test driven development, because I know if I don’t write them ahead of time, I’ll never write them. \u003ca href=\"https://hillelwayne.com/post/why-tdd-isnt-crap/\" rel=\"ugc\"\u003eTDD\u003c/a\u003e and robust \u003ca href=\"https://hillelwayne.com/tags/testing/\" rel=\"ugc\"\u003etesting\u003c/a\u003e also mirror writing specifications, starting with simple types and actions in the state space and properties which should fail. (It’s always fun to see how much ground a single property test covers!) I wonder how Prolog would be for writing these kinds of tests.\u003c/p\u003e\n\u003cp\u003eI recently gave a \u003ca href=\"https://youtu.be/d9cM8f_qSLQ?t=522\" rel=\"ugc\"\u003etalk\u003c/a\u003e on FM where I proposed a concept of “test strength”: \u003ccode\u003eS =\u0026gt; W\u003c/code\u003e means that if test S passes, test T will pass too. A trivial example of this is that \u003ccode\u003emax([1,2,3]) == 3 =\u0026gt; max([1,2,3]) in [1,2,3]\u003c/code\u003e. Strong tests give you more bounds on the correctness of your code, weak tests give you more information about where bugs are. Wherever we have strong and weak tests, cultures tend to prefer few strong ones and lots of weak ones.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat’s your modeling workflow? For personal projects, I’ll e.g. start with comments on the steps required, then make tests for them, then code to solve the tests.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA common workflow with specs is:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWrite a spec\u003c/li\u003e\n\u003cli\u003eGenerate its state space\u003c/li\u003e\n\u003cli\u003eTake some of its behaviors as sequences of steps, then turn them into commands on the program [1]\u003c/li\u003e\n\u003cli\u003eVerify that the program ends up in the same state(s) when fed those commands\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe tricky bit’s that complex systems present idiosyncrasies when converting between specs and tests, precluding a one-size-fits-all solution. MongoDB just published a \u003ca href=\"https://will62794.github.io/assets/papers/mdb-txns-modular-verification.pdf\" rel=\"ugc\"\u003epaper\u003c/a\u003e on this. And you have to do it for a given language (and I was specifying \u003cem\u003eRuby\u003c/em\u003e of all things!)\u003c/p\u003e\n\u003cp\u003eBy the way, most of my work in FM is coming up with rigorous designs, not formally verifying code.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you handle notations?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGive ’em JSON! I have a gadget for turning TLA+ traces into JSON traces to parse in whatever language. Familiarity beats appropriateness 90% of the time.\u003c/p\u003e\n\u003cp\u003eOne of the important things about FM is that people only want to spend one innovation token. They don’t want to learn TLA+ \u003cem\u003eand\u003c/em\u003e Raku, they want something they can maintain after I’m gone, and that means limiting the amount of novelty. FM is already super novel.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow would you compare FM to Prolog?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAnyway, on the surface they’re very different. Logic Programming (LP) is first and foremost programming, while FM (well, formal specification) is about modeling a system. There’s ideally no I/O in FM. But both heavily rely on formal logic, in different ways. You can’t get anywhere in FM without a strong understanding of quantifiers and implication, and so much of Prolog is defining things in terms of existentials, in my experience.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFunctional core, imperative shell ~ Functional… FM armor for your core?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUnification and model checking are both representable as search problems. If Prolog is “depth-first search – the programming language”, then TLA+’s model checker is “breadth first search – the model checker”. This is more obvious in planner programming, where you write the list of steps a system can perform and have the unifier find a sequence that reaches a goal. \u003ca href=\"https://www.hillelwayne.com/post/picat/\" rel=\"ugc\"\u003ePicat\u003c/a\u003e has this built in, I think you can do it in Prolog with DCGs. Anyway, “this system violates property X” is equivalent to “the planner can reach goal !X”.\u003c/p\u003e\n\u003cp\u003eYou once asked me “why didn’t Prolog catch on” which has been bouncing around in my head ever since. God, I wish I knew why things succeeded or failed in general. It’s easy to come up with possible reasons, but so much harder to see if those reasons actually mattered. My own speculation is it’s less that LP failed and more that Structured Imperative Programming won. Perhaps, languages only become successful if they fulfill the population’s needs. For Haskell, the population was academics and the need was “write papers”. To be clear, this is not a dig against them: that need is valuable in society and has led to lots of amazing discoveries in FP. But the biggest need is “make money” and it seems the best languages for this (i.e. the languages businesses consistently adopt and have adopted) are imperative languages.\u003c/p\u003e\n\u003cp\u003eLike, since 2010, what were some of the biggest success stories in programming languages? Kotlin, Swift, Rust. Almost Go and Clojure. It’s debatable if that’s actually evidence: it could be that they were all just trying to be backwards compatible with existing imperative languages and/or were for low-level programming, where imperative dominates. Maybe this is a dead end without a lot more information and research. Maybe there’s something on how it’s easier to glue together libraries in an imperative framework or it’s the default for reasoning in certain circumstances…\u003c/p\u003e\n\u003cp\u003eAnyway, Prolog has unpredictable performance and didn’t evolve. I mean, how different is Go from the first imperative languages? Most people would say “not very” but it’s enormously different! Fortran → Algol-60 → CPL → BCPL → B → C and Go borrows from other places too like CLU. Picat? The chain goes Prolog → Picat. MiniKanren? Unsure, but it’s probably something short too. Compare these highly-iterated imperative languages (which again, might be very well suited for a broad range of business tasks) against low-iterated logic languages. If LP should get more popular, maybe it needs to be introduced via “LP-flavored imperative”. I don’t know.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow would you situate planner programming?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAny community which defines its \u003ca href=\"https://planning.wiki/_citedpapers/pddl1998.pdf\" rel=\"ugc\"\u003einterchange format\u003c/a\u003e in S-expressions must be Lisp-based. But Picat is the first language I encountered with planning and it fits the logic paradigm really really well. I keep looking for problems I could solve with planning, a hammer in search of a nail. But they’re often solvable with plain-old constraint solving.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you choose and approach diving into exotic languages?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI let ADHD guide me. Sometimes I learn a little bit and go “okay maybe some other time”, sometimes I get completely absorbed. But my backlog has grown really long from the book I’m writing.\u003c/p\u003e\n\u003cp\u003eConsulting is TLA+/Alloy. Personally, I can already solve a problem with tools I know, but I want to know what the “optimum” tool looks like. That’s what started me on LP. I was planning some activities for a vacation, with unusual enough constraints that a constraint solver wasn’t appropriate. While it was easy enough to do by hand, I wondered “what would happen if I tried LP?” This all, of course, depends on being exposed to a wide variety of niche tools, which Lobsters naturally encourages.\u003c/p\u003e\n\u003cp\u003eAnother important factor is whether I can write about it. When learning something new, I constantly ask myself: How can I explain why this is interesting to others? What would an article about this look like?\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you approach a blog post?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eEmbarrassingly, I have \u003cem\u003etwo\u003c/em\u003e “blogs”: \u003ca href=\"https://hillelwayne.com/\" rel=\"ugc\"\u003ehillelwayne.com\u003c/a\u003e and a \u003ca href=\"https://buttondown.com/hillelwayne/\" rel=\"ugc\"\u003enewsletter\u003c/a\u003e. The website’s for when I want feedback before publishing while the newsletter was written in a day (mission-creeped to 2–3 days.) This led to a weekly newsletter cadence and a monthly blog cadence, though I’ve been on hiatus due to the book consuming me.\u003c/p\u003e\n\u003cp\u003eThese constraints affect how I approach “designing” written material. If it’s a newsletter, I try to form the idea fully in my head and then just write it out, usually making adjustments if things are proving too messy. If it’s a blog post, I design and write with the expectation that it will not be close to the final product, that every word in it might be erased and replaced with a different structure. It’s never a waste of time to throw away a draft. The draft gives you the actual, better idea for the overarching structure.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you approach books?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFor my first book, having a publisher with a hard deadline really helped me, because I couldn’t dilly-dally. The current book is self-published, so I have to set my own deadlines. “Early access” helps here, seeing sales and feedback is a strong motivator.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow does self-publishing compare to writing a book with a publisher? \u003cem\u003eLogic for Programmers\u003c/em\u003e is self-published, why?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSelf-publishing is a ton more work! I have to pay for the book cover and copyediting, get an ISBN number, market beyond word of mouth, and stick to my own schedule. It’s all harder and less convenient. In return:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eI get to use the tech stack I want. For \u003cem\u003ePractical TLA+\u003c/em\u003e, I had to submit chapters to my publisher as Word documents. This is really hard for a technical book! For \u003cem\u003e\u003ca href=\"https://leanpub.com/logic\" rel=\"ugc\"\u003eLogic for Programmers\u003c/a\u003e\u003c/em\u003e I can write my books in \u003ca href=\"https://www.sphinx-doc.org/\" rel=\"ugc\"\u003eSphinx\u003c/a\u003e and compile them to LaTeX, which has its own issues, but gets me a lot more of the benefits I need.\u003c/li\u003e\n\u003cli\u003eI was able to put the book on “early access”, so people could buy it before it was done. So far it’s sold over 1,000 copies! That’s a huge motivation to get it finished.\u003c/li\u003e\n\u003cli\u003eIt pays a lot better. This was honestly the reason that led me to do this in the first place. My old publisher pays me 10% royalties on net profit of books sold, which ends up being more like 5% of the sale price. Leanpub is paying 80% on sticker price as royalties. One copy of LfP sold nets me about as much as 15 copies of Practical TLA+.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eI expected writing a book to make no financial sense directly.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI’m hoping I can turn this into talks/workshops/general consulting to make the bulk of the money back. But with self-publishing you do make some money: LfP has made about 20k while in prerelease, so I think it can potentially make a few multiples of that. It’s nothing like working full time as a software engineer though.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow would you approach your next book?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI’m 100% for sure not writing another book after this, ever. I said the same thing after writing \u003cem\u003ePractical TLA+\u003c/em\u003e, but this time I \u003cem\u003emean\u003c/em\u003e it. The biggest question is “can this topic support a whole book?” Many important and interesting topics in our field aren’t book-worthy, they’re blog or website worthy. It’s amazing that we have this great means of disseminating written information without people paying for a book. A book only makes sense if you have a lot to say. So is the topic something I have a lot to say about?\u003c/p\u003e\n\u003cp\u003eIn the case of Logic for Programmers, the answer was almost “no”. I was originally inspired to write about logic from teaching TLA+: I found that a couple of basic concepts in logic —implication and existential quantifiers— were huge stumbling blocks for students. They just had never been exposed to these tools before, which surprised me because I use them in so many different ways. In 2021, I started writing, then realized it didn’t need to be a book but 3 blog posts, at most. So I started writing those blog posts and realized I had a lot more to say, so it turned into a book again!\u003c/p\u003e\n\u003cp\u003eThis applies to everything, really. My first talk rehearsals look nothing like the final talks. Most LfP chapters have been rewritten unrecognizably from their originals.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWriting is an important tool of thought!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI can think without writing, I just can’t be thorough. I can still think about the emotional touchstones of a piece, or what feel like good examples, or what seems like the hardest to explain, etc. A surprising amount of time spent brainstorming a piece is finding a good example. \u003cstrong\u003eAn example showcases the topic without requiring too much background context, without feeling trivial, artificial or dismissible.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you approach teaching a course? It’s interesting how you massage the map of information for different formats and audiences.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe hard part of designing a course, for me, is feedback. With writing or talks, you can get rapid feedback on your draft. But you need to run a course for feedback. It’s bad enough for a 2 hour course, but some last 8 or 24 hours! Your only QA is the customer.\u003c/p\u003e\n\u003cp\u003eAs you say, I have a map of the information, so I know what needs to be covered. Courses don’t have to be as comprehensive as books and you’re under time pressure, so you have to throw away auxiliary or even essential information, due to priorities. In a class, everything has to feel useful and real.\u003c/p\u003e\n\u003cp\u003eIt’s so easy to make a class that makes something useful in an artificial environment, but then the students think “okay, but it doesn’t do anything for \u003cem\u003eme\u003c/em\u003e” or “\u003cem\u003eit doesn’t work in the real world with real problems\u003c/em\u003e”. This demands more of examples, not just good but \u003cem\u003ereal\u003c/em\u003e. So I always end FM courses by getting a specification from the class and modeling it live to show “yes, this can actually help you with your system, it’s not just make-believe”. This has the happy consequence of surfacing special topics particular to the class’ interests, so they get exposure to e.g. recursive data structure representations, reading specs in from CSVs or debug-modes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat does engineering mean to you?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI think about this a lot. I did a \u003ca href=\"https://www.hillelwayne.com/post/are-we-really-engineers/\" rel=\"ugc\"\u003eproject\u003c/a\u003e comparing software engineering to traditional engineering. They’re pretty similar but it didn’t get to the essence of engineering itself. To me, what separates software “engineering” from “programming” in general is the treatment of the software itself as a meaningful artifact and product. Many people program: artists, grad students, scientists, data people, Excel jockeys, people in game jams… But they rarely care about version control, backwards compatibility, API usability, modularity, etc. They think of software as a step to getting something done, not something important itself.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUnexpected! When looking at the legacy of Naur, of people late career coming to epiphanies that software’s less important than the mental models (documented through software)…\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI think here are 2 mental models: of the problem and of the software solving the problem. Software \u003cem\u003eengineering\u003c/em\u003e builds the second model too. Software engineering’s when you can’t just tell the LLM to “write a program to do X” and be satisfied, because you have to consider constraints and scope beyond the individual problem, beyond the functional requirements. Performance, security, auditability, privacy, compliance, even compatibility with your current tech stack, considering them makes it engineering.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you collect requirements adequately? You discussed the \u003ccode\u003espec-\u0026gt;implementation\u003c/code\u003e problem, what about the BA problem of \u003ccode\u003emysterious-world-\u0026gt;spec\u003c/code\u003e?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe answer is surprisingly boring: spend a lot of time speccing it with a domain expert. FM helps an engineer do their job better, but it doesn’t help an engineer who doesn’t want to do the job. Part of that job is figuring out what the problem to solve is.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOur industry ignores correctness. Tell me why!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJust the boring, cynical answer: “bugs don’t cost enough to be worth squashing early”. The companies most receptive to FM expect really expensive bugs to be both possible and subtle. Many companies aren’t interested because they think they can catch their bugs with other methods or think they don’t have expensive bugs at all. And if they’re wrong, they find out too late.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow technical does management need to be to consider these things? I find many businesses have poor oversight of internal operations and make poor assumptions when deciding opportunity costs, etc.\u003c/strong\u003e\nI believe management should be quite technical to catch these things, but I don’t want to be too judgmental; I have very little insight into what large businesses look like from the top. Maybe I’d take one look at that and give up on FM forever. Past a few hundred employees and you can’t form a good mental model of all your employees.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e[1] The original phrasing was:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOne common way of doing that: 1. write a spec. 2. generate the spec’s state space 3. take behaviors in that state space, sequences of steps, and turn that into a sequence of commands on the program. When fed the same commands, the program should end up in the same states.\u003c/p\u003e\n\u003c/blockquote\u003e\n","description_plain":"For this [interview](https://lobste.rs/t/interview), I spoke with [hwayne](https://lobste.rs/~hwayne) a few times.\r\n\r\nLast week, we talked to [icefox](https://lobste.rs/s/2vfx6w/lobsters_interview_with_icefox), next week we'll hear from [matklad](https://lobste.rs/~matklad). Thank you to my proof readers! \u003c3\r\n\r\n-------\r\n\r\nYo! To prove it's me, here's a hash of our last PM: `a4332cf8fb02ff3f02de333343958021`. Not for security, but to signal my values!\r\n\r\n**Much of my childhood online was collecting common wisdom, memes, fuddlore and repeating them to signal my virtue. Growing has been the long path of killing those darlings. Anyway, I love your work!**\r\n\r\nLet's see how fast I can disillusion you!\r\n\r\n**Introduce yourself! How'd you discover programming and [Formal Methods](https://en.wikipedia.org/wiki/Formal_methods) (FM)?**\r\n\r\nI'm Hillel. I'm mostly known online for writing about software, especially FM (to make it more accessible), and history. In my free time I [juggle](https://www.instagram.com/p/COhMfsyA8z2/) and make chocolate.\r\n\r\nI always liked computers and tried to learn C++ to make video games as a teen: not an experience I'd recommend to people. (Actually, I learned Drape and Visual Basic before that. I also miss VB6, it had nice features). In college I did Physics and Math with the hope of becoming a physicist, but got scared off by grad school, because all of my friends who graduated before me, seemed miserable. Long hours, low pay, bad social life, and for five years...\r\n\r\nBesides, universities and industrial labs push the boundaries of human knowledge, but I really like \"pop research\": aggregating existing knowledge and presenting it in engaging or entertaining form. My dives into exotic languages are a good example, like [J](https://hillelwayne.com/post/j-notation/) and Picat. Indeed, FM is a manifestation of my real passion of falling down rabbit holes researching. Besides, community puts me in touch with lots of academics and exotic tool users, who love to share their weird stuff with me, like [MiniZinc](https://www.hillelwayne.com/post/minizinc/) and constraint solving!\r\n\r\nAnyway, I pivoted into programming because at the time (2013) that was the easiest way for educated people to switch career paths. And all the money was in webdev, so I became a webdev. Later at _espark_, which managed iPad apps for elementary schools, our system ended up being \"accidentally distributed\": interactions between us, Apple APIs, school infrastructure, and their mobile device managers led to lots of issues you see in distributed systems, despite us all doing Rails and JavaScript. At this point, two things happened:\r\n\r\n1. I researched Idris, which led me to internet arguments about FM, which in turn led me to reading the Amazon TLA+ paper \"[Use of FM at AWS](https://lamport.azurewebsites.net/tla/formal-methods-amazon.pdf)\".\r\n2. I was officially diagnosed with ADHD and put on Ritalin.\r\n\r\nImportant question for the interviewer: have you ever taken ADHD meds?\r\n\r\n**I have not!**\r\nBasically, for the first couple of days after you start meds, you are a GOD. Nothing can stop you. You can do anything. After a few days, your body adjusts and balances out, so you get the ability to focus without the mania. For my first two days, I crammed TLA+. This head start really helped get over the hump. I immediately [caught some major bugs in the redesign](https://medium.com/espark-engineering-blog/formal-methods-in-practice-8f20d72bce4f), which made me fall in love. _Cue years of trying to make it more accessible for people without the Ritalin God-mode head start!_\r\n\r\nBut evangelism is difficult. At _espark_, nobody else wanted to learn TLA+ because I already knew it. The vibe was that it solved a one-off problem and they wouldn't need it again. After I left, about once a quarter they would tell me about a new hairy bug that would have been caught by TLA+, always \"a one-off problem that won't happen again\".\r\n\r\nI see this as a manifestation of just how high the cost is for these tools. If it took five minutes to learn and apply, they'd do it. But they expect weeks of practice to study and solve problems and think \"ugh no\".\r\n\r\n**In your evangelism, you talk of the business case sometimes. How do you balance that for a company vs. the personal effort/career hurdles of developers?**\r\n\r\nI often ask myself: Does spending ten hours learning FM or bash scripting really well help the average engineer more? Probably bash.  _Right now_, FM is a very bottom-up practice where developers see it, get inspired, and apply it at their work. Very rarely is it top-down, where a VP or director mandates it. The researchers and evangelists —including me— are devs. The TLA+ foundation is trying to figure out how to make that jump though. We have _anecdotal_ claims of FM catching expensive bugs and saving money, but it's hard to put numbers or measure the cost/reward, which makes decision-makers shy away.\r\n\r\nThere's then the perennial challenge of \"okay we've modeled the specification, how do we actually make sure our implementation matches this?\"\r\n\r\n**The Go team wrote 2 implementations, to keep the [spec](https://go.dev/ref/spec) honest.**\r\n\r\nPart of the value of a formal specification (spec) is that it can be so abstract. Specs omit many details a generator must make. But there's vast potential in using specs to *test* code. MongoDB has done a lot and I've made \"test generators\" for clients (which I'll blog about.) I'm generally a fan of test driven development, because I know if I don't write them ahead of time, I'll never write them. [TDD](https://hillelwayne.com/post/why-tdd-isnt-crap/) and robust [testing](https://hillelwayne.com/tags/testing/) also mirror writing specifications, starting with simple types and actions in the state space and properties which should fail. (It's always fun to see how much ground a single property test covers!) I wonder how Prolog would be for writing these kinds of tests.\r\n\r\nI recently gave a [talk](https://youtu.be/d9cM8f_qSLQ?t=522) on FM where I proposed a concept of \"test strength\": `S =\u003e W` means that if test S passes, test T will pass too. A trivial example of this is that `max([1,2,3]) == 3 =\u003e max([1,2,3]) in [1,2,3]`. Strong tests give you more bounds on the correctness of your code, weak tests give you more information about where bugs are. Wherever we have strong and weak tests, cultures tend to prefer few strong ones and lots of weak ones.\r\n\r\n**What's your modeling workflow? For personal projects, I'll e.g. start with comments on the steps required, then make tests for them, then code to solve the tests.**\r\n\r\nA common workflow with specs is:\r\n\r\n1. Write a spec\r\n2. Generate its state space\r\n3. Take some of its behaviors as sequences of steps, then turn them into commands on the program [1]\r\n4. Verify that the program ends up in the same state(s) when fed those commands\r\n\r\nThe tricky bit's that complex systems present idiosyncrasies when converting between specs and tests, precluding a one-size-fits-all solution. MongoDB just published a [paper](https://will62794.github.io/assets/papers/mdb-txns-modular-verification.pdf) on this. And you have to do it for a given language (and I was specifying _Ruby_ of all things!)\r\n\r\nBy the way, most of my work in FM is coming up with rigorous designs, not formally verifying code.\r\n\r\n**How do you handle notations?**\r\n\r\nGive 'em JSON! I have a gadget for turning TLA+ traces into JSON traces to parse in whatever language. Familiarity beats appropriateness 90% of the time.\r\n\r\nOne of the important things about FM is that people only want to spend one innovation token. They don't want to learn TLA+ *and* Raku, they want something they can maintain after I'm gone, and that means limiting the amount of novelty. FM is already super novel.\r\n\r\n**How would you compare FM to Prolog?** \r\n\r\nAnyway, on the surface they're very different. Logic Programming (LP) is first and foremost programming, while FM (well, formal specification) is about modeling a system. There's ideally no I/O in FM. But both heavily rely on formal logic, in different ways. You can't get anywhere in FM without a strong understanding of quantifiers and implication, and so much of Prolog is defining things in terms of existentials, in my experience.\r\n\r\n**Functional core, imperative shell ~ Functional... FM armor for your core?**\r\n\r\nUnification and model checking are both representable as search problems. If Prolog is \"depth-first search – the programming language\", then TLA+'s model checker is \"breadth first search – the model checker\". This is more obvious in planner programming, where you write the list of steps a system can perform and have the unifier find a sequence that reaches a goal. [Picat](https://www.hillelwayne.com/post/picat/) has this built in, I think you can do it in Prolog with DCGs. Anyway, \"this system violates property X\" is equivalent to \"the planner can reach goal !X\".\r\n\r\nYou once asked me \"why didn't Prolog catch on\" which has been bouncing around in my head ever since. God, I wish I knew why things succeeded or failed in general. It's easy to come up with possible reasons, but so much harder to see if those reasons actually mattered. My own speculation is it's less that LP failed and more that Structured Imperative Programming won. Perhaps, languages only become successful if they fulfill the population's needs. For Haskell, the population was academics and the need was \"write papers\". To be clear, this is not a dig against them: that need is valuable in society and has led to lots of amazing discoveries in FP. But the biggest need is \"make money\" and it seems the best languages for this (i.e. the languages businesses consistently adopt and have adopted) are imperative languages.\r\n\r\nLike, since 2010, what were some of the biggest success stories in programming languages? Kotlin, Swift, Rust. Almost Go and Clojure. It's debatable if that's actually evidence: it could be that they were all just trying to be backwards compatible with existing imperative languages and/or were for low-level programming, where imperative dominates. Maybe this is a dead end without a lot more information and research. Maybe there's something on how it's easier to glue together libraries in an imperative framework or it's the default for reasoning in certain circumstances...\r\n\r\nAnyway, Prolog has unpredictable performance and didn't evolve. I mean, how different is Go from the first imperative languages? Most people would say \"not very\" but it's enormously different! Fortran → Algol-60 → CPL → BCPL → B → C and Go borrows from other places too like CLU. Picat? The chain goes Prolog → Picat. MiniKanren? Unsure, but it's probably something short too. Compare these highly-iterated imperative languages (which again, might be very well suited for a broad range of business tasks) against low-iterated logic languages. If LP should get more popular, maybe it needs to be introduced via \"LP-flavored imperative\". I don't know.\r\n\r\n**How would you situate planner programming?**\r\n\r\nAny community which defines its [interchange format](https://planning.wiki/_citedpapers/pddl1998.pdf) in S-expressions must be Lisp-based. But Picat is the first language I encountered with planning and it fits the logic paradigm really really well. I keep looking for problems I could solve with planning, a hammer in search of a nail. But they're often solvable with plain-old constraint solving.\r\n\r\n**How do you choose and approach diving into exotic languages?**\r\n\r\nI let ADHD guide me. Sometimes I learn a little bit and go \"okay maybe some other time\", sometimes I get completely absorbed. But my backlog has grown really long from the book I'm writing.\r\n\r\nConsulting is TLA+/Alloy. Personally, I can already solve a problem with tools I know, but I want to know what the \"optimum\" tool looks like. That's what started me on LP. I was planning some activities for a vacation, with unusual enough constraints that a constraint solver wasn't appropriate. While it was easy enough to do by hand, I wondered \"what would happen if I tried LP?\" This all, of course, depends on being exposed to a wide variety of niche tools, which Lobsters naturally encourages.\r\n\r\nAnother important factor is whether I can write about it. When learning something new, I constantly ask myself: How can I explain why this is interesting to others? What would an article about this look like?\r\n\r\n**How do you approach a blog post?**\r\n\r\nEmbarrassingly, I have _two_ \"blogs\": [hillelwayne.com](https://hillelwayne.com/) and a [newsletter](https://buttondown.com/hillelwayne/). The website's for when I want feedback before publishing while the newsletter was written in a day (mission-creeped to 2–3 days.) This led to a weekly newsletter cadence and a monthly blog cadence, though I've been on hiatus due to the book consuming me.\r\n\r\nThese constraints affect how I approach \"designing\" written material. If it's a newsletter, I try to form the idea fully in my head and then just write it out, usually making adjustments if things are proving too messy. If it's a blog post, I design and write with the expectation that it will not be close to the final product, that every word in it might be erased and replaced with a different structure. It's never a waste of time to throw away a draft. The draft gives you the actual, better idea for the overarching structure.\r\n\r\n**How do you approach books?**\r\n\r\nFor my first book, having a publisher with a hard deadline really helped me, because I couldn't dilly-dally. The current book is self-published, so I have to set my own deadlines. \"Early access\" helps here, seeing sales and feedback is a strong motivator.\r\n\r\n**How does self-publishing compare to writing a book with a publisher? *Logic for Programmers* is self-published, why?**\r\n\r\nSelf-publishing is a ton more work! I have to pay for the book cover and copyediting, get an ISBN number, market beyond word of mouth, and stick to my own schedule. It's all harder and less convenient. In return:\r\n\r\n1. I get to use the tech stack I want. For *Practical TLA+*, I had to submit chapters to my publisher as Word documents. This is really hard for a technical book! For *[Logic for Programmers](https://leanpub.com/logic)* I can write my books in [Sphinx](https://www.sphinx-doc.org/) and compile them to LaTeX, which has its own issues, but gets me a lot more of the benefits I need.\r\n2. I was able to put the book on \"early access\", so people could buy it before it was done. So far it's sold over 1,000 copies! That's a huge motivation to get it finished.\r\n3. It pays a lot better. This was honestly the reason that led me to do this in the first place. My old publisher pays me 10% royalties on net profit of books sold, which ends up being more like 5% of the sale price. Leanpub is paying 80% on sticker price as royalties. One copy of LfP sold nets me about as much as 15 copies of Practical TLA+.\r\n\r\n**I expected writing a book to make no financial sense directly.**\r\n\r\nI'm hoping I can turn this into talks/workshops/general consulting to make the bulk of the money back. But with self-publishing you do make some money: LfP has made about 20k while in prerelease, so I think it can potentially make a few multiples of that. It's nothing like working full time as a software engineer though.\r\n\r\n**How would you approach your next book?**\r\n\r\nI'm 100% for sure not writing another book after this, ever. I said the same thing after writing *Practical TLA+*, but this time I *mean* it. The biggest question is \"can this topic support a whole book?\" Many important and interesting topics in our field aren't book-worthy, they're blog or website worthy. It's amazing that we have this great means of disseminating written information without people paying for a book. A book only makes sense if you have a lot to say. So is the topic something I have a lot to say about?\r\n\r\nIn the case of Logic for Programmers, the answer was almost \"no\". I was originally inspired to write about logic from teaching TLA+: I found that a couple of basic concepts in logic —implication and existential quantifiers— were huge stumbling blocks for students. They just had never been exposed to these tools before, which surprised me because I use them in so many different ways. In 2021, I started writing, then realized it didn't need to be a book but 3 blog posts, at most. So I started writing those blog posts and realized I had a lot more to say, so it turned into a book again!\r\n\r\nThis applies to everything, really. My first talk rehearsals look nothing like the final talks. Most LfP chapters have been rewritten unrecognizably from their originals.\r\n\r\n**Writing is an important tool of thought!**\r\n\r\nI can think without writing, I just can't be thorough. I can still think about the emotional touchstones of a piece, or what feel like good examples, or what seems like the hardest to explain, etc. A surprising amount of time spent brainstorming a piece is finding a good example. **An example showcases the topic without requiring too much background context, without feeling trivial, artificial or dismissible.**\r\n\r\n**How do you approach teaching a course? It's interesting how you massage the map of information for different formats and audiences.**\r\n\r\nThe hard part of designing a course, for me, is feedback. With writing or talks, you can get rapid feedback on your draft. But you need to run a course for feedback. It's bad enough for a 2 hour course, but some last 8 or 24 hours! Your only QA is the customer.\r\n\r\nAs you say, I have a map of the information, so I know what needs to be covered. Courses don't have to be as comprehensive as books and you're under time pressure, so you have to throw away auxiliary or even essential information, due to priorities. In a class, everything has to feel useful and real.\r\n\r\nIt's so easy to make a class that makes something useful in an artificial environment, but then the students think \"okay, but it doesn't do anything for _me_\" or \"_it doesn't work in the real world with real problems_\". This demands more of examples, not just good but _real_. So I always end FM courses by getting a specification from the class and modeling it live to show \"yes, this can actually help you with your system, it's not just make-believe\". This has the happy consequence of surfacing special topics particular to the class' interests, so they get exposure to e.g. recursive data structure representations, reading specs in from CSVs or debug-modes.\r\n\r\n**What does engineering mean to you?**\r\n\r\nI think about this a lot. I did a [project](https://www.hillelwayne.com/post/are-we-really-engineers/) comparing software engineering to traditional engineering. They're pretty similar but it didn't get to the essence of engineering itself. To me, what separates software \"engineering\" from \"programming\" in general is the treatment of the software itself as a meaningful artifact and product. Many people program: artists, grad students, scientists, data people, Excel jockeys, people in game jams... But they rarely care about version control, backwards compatibility, API usability, modularity, etc. They think of software as a step to getting something done, not something important itself.\r\n\r\n**Unexpected! When looking at the legacy of Naur, of people late career coming to epiphanies that software's less important than the mental models (documented through software)...**\r\n\r\nI think here are 2 mental models: of the problem and of the software solving the problem. Software _engineering_ builds the second model too. Software engineering's when you can't just tell the LLM to \"write a program to do X\" and be satisfied, because you have to consider constraints and scope beyond the individual problem, beyond the functional requirements. Performance, security, auditability, privacy, compliance, even compatibility with your current tech stack, considering them makes it engineering.\r\n\r\n**How do you collect requirements adequately? You discussed the `spec-\u003eimplementation` problem, what about the BA problem of `mysterious-world-\u003espec`?**\r\n\r\nThe answer is surprisingly boring: spend a lot of time speccing it with a domain expert. FM helps an engineer do their job better, but it doesn't help an engineer who doesn't want to do the job. Part of that job is figuring out what the problem to solve is.\r\n\r\n**Our industry ignores correctness. Tell me why!**\r\n\r\nJust the boring, cynical answer: \"bugs don't cost enough to be worth squashing early\". The companies most receptive to FM expect really expensive bugs to be both possible and subtle. Many companies aren't interested because they think they can catch their bugs with other methods or think they don't have expensive bugs at all. And if they're wrong, they find out too late.\r\n\r\n**How technical does management need to be to consider these things? I find many businesses have poor oversight of internal operations and make poor assumptions when deciding opportunity costs, etc.**\r\nI believe management should be quite technical to catch these things, but I don't want to be too judgmental; I have very little insight into what large businesses look like from the top. Maybe I'd take one look at that and give up on FM forever. Past a few hundred employees and you can't form a good mental model of all your employees.\r\n\r\n-----\r\n\r\n[1] The original phrasing was:\r\n\r\n\u003e One common way of doing that: 1. write a spec. 2. generate the spec's state space 3. take behaviors in that state space, sequences of steps, and turn that into a sequence of commands on the program. When fed the same commands, the program should end up in the same states.","submitter_user":"veqq","user_is_author":true,"tags":["formalmethods","interview","person"],"short_id_url":"https://lobste.rs/s/bc53lh","comments_url":"https://lobste.rs/s/bc53lh/lobsters_interview_with_hwayne"},{"short_id":"qtm9uv","created_at":"2025-08-08T16:20:21.000-05:00","title":"A puzzling Python program","url":"https://jo3-l.dev/posts/python-countdown/","score":10,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"jo3_l","user_is_author":true,"tags":["python"],"short_id_url":"https://lobste.rs/s/qtm9uv","comments_url":"https://lobste.rs/s/qtm9uv/puzzling_python_program"},{"short_id":"w6xvpd","created_at":"2025-08-08T14:34:03.000-05:00","title":"Overview of Jepsen at BugBash 2025","url":"https://antithesis.com/blog/2025/bugbash_2025/kyle_kingsbury/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"alethkit","user_is_author":false,"tags":["databases","distributed","testing"],"short_id_url":"https://lobste.rs/s/w6xvpd","comments_url":"https://lobste.rs/s/w6xvpd/overview_jepsen_at_bugbash_2025"},{"short_id":"hct5qg","created_at":"2025-08-08T14:10:23.000-05:00","title":"Breaking the Sorting Barrier for Directed Single-Source Shortest Paths","url":"https://arxiv.org/abs/2504.17033","score":5,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"panadestein","user_is_author":false,"tags":["compsci"],"short_id_url":"https://lobste.rs/s/hct5qg","comments_url":"https://lobste.rs/s/hct5qg/breaking_sorting_barrier_for_directed"},{"short_id":"na3kwy","created_at":"2025-08-08T12:59:53.000-05:00","title":"Jeff Geerling clustered four Framework Mainboards to test huge LLMs","url":"https://www.jeffgeerling.com/blog/2025/i-clustered-four-framework-mainboards-test-huge-llms","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"creature","user_is_author":false,"tags":["distributed","hardware"],"short_id_url":"https://lobste.rs/s/na3kwy","comments_url":"https://lobste.rs/s/na3kwy/jeff_geerling_clustered_four_framework"},{"short_id":"qq2x8t","created_at":"2025-08-08T12:43:40.000-05:00","title":"LVFS Sustainability Plan","url":"https://blogs.gnome.org/hughsie/2025/08/08/lvfs-sustainability-plan/","score":4,"flags":0,"comment_count":4,"description":"","description_plain":"","submitter_user":"strugee","user_is_author":false,"tags":["linux"],"short_id_url":"https://lobste.rs/s/qq2x8t","comments_url":"https://lobste.rs/s/qq2x8t/lvfs_sustainability_plan"},{"short_id":"zrbpds","created_at":"2025-08-08T10:30:03.000-05:00","title":"Hypothesis is now thread-safe","url":"https://hypothesis.works/articles/thread-safe/","score":30,"flags":0,"comment_count":5,"description":"","description_plain":"","submitter_user":"ngoldbaum","user_is_author":false,"tags":["python","testing"],"short_id_url":"https://lobste.rs/s/zrbpds","comments_url":"https://lobste.rs/s/zrbpds/hypothesis_is_now_thread_safe"},{"short_id":"fswjtl","created_at":"2025-08-08T10:00:28.000-05:00","title":"Programming as Extended Cognition","url":"https://ieeexplore.ieee.org/document/11119124","score":15,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"gfairbanks","user_is_author":true,"tags":["programming"],"short_id_url":"https://lobste.rs/s/fswjtl","comments_url":"https://lobste.rs/s/fswjtl/programming_as_extended_cognition"},{"short_id":"stxzc8","created_at":"2025-08-08T08:58:25.000-05:00","title":"Updated Google Project Zero disclosure policy","url":"https://googleprojectzero.blogspot.com/2025/07/reporting-transparency.html","score":4,"flags":0,"comment_count":5,"description":"\u003cp\u003eSee also \u003ca href=\"https://www.schneier.com/blog/archives/2025/08/google-project-zero-changes-its-disclosure-policy.html\" rel=\"ugc\"\u003eSchneier’s (limited) commentary\u003c/a\u003e.\u003c/p\u003e\n","description_plain":"See also [Schneier's (limited) commentary](https://www.schneier.com/blog/archives/2025/08/google-project-zero-changes-its-disclosure-policy.html).","submitter_user":"strugee","user_is_author":false,"tags":["security"],"short_id_url":"https://lobste.rs/s/stxzc8","comments_url":"https://lobste.rs/s/stxzc8/updated_google_project_zero_disclosure"},{"short_id":"ec20br","created_at":"2025-08-08T08:53:22.000-05:00","title":"devenv with Domen Kožar","url":"https://fulltimenix.com/episodes/devenv-with-domen-kozar","score":-1,"flags":3,"comment_count":0,"description":"","description_plain":"","submitter_user":"mightyiam","user_is_author":true,"tags":["audio","nix"],"short_id_url":"https://lobste.rs/s/ec20br","comments_url":"https://lobste.rs/s/ec20br/devenv_with_domen_kozar"},{"short_id":"gk3luv","created_at":"2025-08-08T08:36:25.000-05:00","title":"How long does it take to upgrade an eBook?","url":"https://shkspr.mobi/blog/2025/08/how-long-does-it-take-to-upgrade-an-ebook/","score":32,"flags":0,"comment_count":6,"description":"","description_plain":"","submitter_user":"mtlynch","user_is_author":false,"tags":["a11y"],"short_id_url":"https://lobste.rs/s/gk3luv","comments_url":"https://lobste.rs/s/gk3luv/how_long_does_it_take_upgrade_ebook"},{"short_id":"qllaru","created_at":"2025-08-08T07:59:03.000-05:00","title":"HTTP is not simple","url":"https://daniel.haxx.se/blog/2025/08/08/http-is-not-simple/","score":44,"flags":0,"comment_count":16,"description":"","description_plain":"","submitter_user":"refi64","user_is_author":false,"tags":["web"],"short_id_url":"https://lobste.rs/s/qllaru","comments_url":"https://lobste.rs/s/qllaru/http_is_not_simple"},{"short_id":"y3jsqb","created_at":"2025-08-08T07:31:53.000-05:00","title":"Preventing ZIP parser confusion attacks on Python package installers","url":"https://blog.pypi.org/posts/2025-08-07-wheel-archive-confusion-attacks/","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"dcreager","user_is_author":false,"tags":["python","security"],"short_id_url":"https://lobste.rs/s/y3jsqb","comments_url":"https://lobste.rs/s/y3jsqb/preventing_zip_parser_confusion_attacks"},{"short_id":"uzvf6k","created_at":"2025-08-08T07:02:21.000-05:00","title":"Introducing Wassette: WebAssembly-based tools for AI agents","url":"https://opensource.microsoft.com/blog/2025/08/06/introducing-wassette-webassembly-based-tools-for-ai-agents/","score":5,"flags":0,"comment_count":2,"description":"","description_plain":"","submitter_user":"alper","user_is_author":false,"tags":["vibecoding","wasm"],"short_id_url":"https://lobste.rs/s/uzvf6k","comments_url":"https://lobste.rs/s/uzvf6k/introducing_wassette_webassembly_based"},{"short_id":"ziaooy","created_at":"2025-08-08T05:43:07.000-05:00","title":"iOS client for Proton Authenticator","url":"https://github.com/protonpass/ios-authenticator","score":2,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"JulianWgs","user_is_author":false,"tags":["release","security"],"short_id_url":"https://lobste.rs/s/ziaooy","comments_url":"https://lobste.rs/s/ziaooy/ios_client_for_proton_authenticator"},{"short_id":"xqcpmc","created_at":"2025-08-08T05:34:34.000-05:00","title":"Understanding not just Clojure's comp function by re-implementing it","url":"https://www.evalapply.org/posts/lessons-from-reimplementing-clojure-comp-function/index.html","score":9,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"adityaathalye","user_is_author":true,"tags":["clojure"],"short_id_url":"https://lobste.rs/s/xqcpmc","comments_url":"https://lobste.rs/s/xqcpmc/understanding_not_just_clojure_s_comp"},{"short_id":"q5bgc5","created_at":"2025-08-08T04:34:16.000-05:00","title":"Abusing Ubuntu 24.04 features for root privilege escalation (2024)","url":"https://labs.snyk.io/resources/abusing-ubuntu-root-privilege-escalation/","score":12,"flags":0,"comment_count":2,"description":"","description_plain":"","submitter_user":"freddyb","user_is_author":false,"tags":["linux","security"],"short_id_url":"https://lobste.rs/s/q5bgc5","comments_url":"https://lobste.rs/s/q5bgc5/abusing_ubuntu_24_04_features_for_root"},{"short_id":"o2zxif","created_at":"2025-08-08T04:17:19.000-05:00","title":"Oops Safari, I think You Spilled Something","url":"https://blog.exodusintel.com/2025/08/04/oops-safari-i-think-you-spilled-something/","score":4,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"freddyb","user_is_author":false,"tags":["mac","security"],"short_id_url":"https://lobste.rs/s/o2zxif","comments_url":"https://lobste.rs/s/o2zxif/oops_safari_i_think_you_spilled_something"},{"short_id":"s7wj5y","created_at":"2025-08-08T03:46:10.000-05:00","title":"How I ended up writing Gleam for a living","url":"https://www.youtube.com/watch?v=BfPRcanTWXA","score":20,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"kamila","user_is_author":false,"tags":["gleam","video"],"short_id_url":"https://lobste.rs/s/s7wj5y","comments_url":"https://lobste.rs/s/s7wj5y/how_i_ended_up_writing_gleam_for_living"},{"short_id":"qr1kro","created_at":"2025-08-08T03:31:14.000-05:00","title":"What are you doing this weekend?","url":"","score":5,"flags":0,"comment_count":15,"description":"\u003cp\u003eFeel free to tell what you plan on doing this weekend and even ask for help or feedback.\u003c/p\u003e\n\u003cp\u003ePlease keep in mind it’s more than OK to do nothing at all too!\u003c/p\u003e\n","description_plain":"Feel free to tell what you plan on doing this weekend and even ask for help or feedback.\r\n\r\nPlease keep in mind it’s more than OK to do nothing at all too!","submitter_user":"caius","user_is_author":true,"tags":["ask","programming"],"short_id_url":"https://lobste.rs/s/qr1kro","comments_url":"https://lobste.rs/s/qr1kro/what_are_you_doing_this_weekend"},{"short_id":"cn7crr","created_at":"2025-08-08T02:06:22.000-05:00","title":"Writing surtoget.no with gleam","url":"https://lindbakk.com/blog/introducing-surtoget_no","score":30,"flags":0,"comment_count":6,"description":"","description_plain":"","submitter_user":"raffomania","user_is_author":false,"tags":["gleam"],"short_id_url":"https://lobste.rs/s/cn7crr","comments_url":"https://lobste.rs/s/cn7crr/writing_surtoget_no_with_gleam"},{"short_id":"zxppfh","created_at":"2025-08-08T01:55:32.000-05:00","title":"All the cool kids are doing it","url":"https://www.scattered-thoughts.net/writing/all-the-cool-kids-are-doing-it/","score":37,"flags":0,"comment_count":20,"description":"","description_plain":"","submitter_user":"matklad","user_is_author":false,"tags":["vibecoding"],"short_id_url":"https://lobste.rs/s/zxppfh","comments_url":"https://lobste.rs/s/zxppfh/all_cool_kids_are_doing_it"},{"short_id":"t00vt8","created_at":"2025-08-08T00:50:54.000-05:00","title":"Exploiting Retbleed in the real world","url":"https://bughunters.google.com/blog/6243730100977664/exploiting-retbleed-in-the-real-world","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"fro","user_is_author":false,"tags":["hardware","security"],"short_id_url":"https://lobste.rs/s/t00vt8","comments_url":"https://lobste.rs/s/t00vt8/exploiting_retbleed_real_world"}]