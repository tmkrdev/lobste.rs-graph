[{"short_id":"vlreib","created_at":"2025-10-10T00:28:08.000-05:00","title":"Is Odin Just a More Boring C?","url":"https://dayvster.com/blog/is-odin-just-a-more-boring-c/","score":4,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"rcalixte","user_is_author":false,"tags":["c","plt"],"short_id_url":"https://lobste.rs/s/vlreib","comments_url":"https://lobste.rs/s/vlreib/is_odin_just_more_boring_c"},{"short_id":"p8hshz","created_at":"2025-10-10T00:27:58.000-05:00","title":"Lobsters Interview with Zdsmith","url":"","score":6,"flags":0,"comment_count":1,"description":"\u003cp\u003eI had the pleasure of interviewing and befriending \u003ca href=\"https://lobste.rs/~zdsmith\" rel=\"ugc\"\u003e@zdsmith\u003c/a\u003e whose passions are very close to my heart. He explores the different forms of notation (Iverson, Naur), makes \u003ca href=\"https://tacittalk.com/2024/09/27/Episode-5.html\" rel=\"ugc\"\u003ecombinatory programming\u003c/a\u003e approachable, ported \u003ca href=\"https://jnj.li/\" rel=\"ugc\"\u003eJ to Janet\u003c/a\u003e, created an ergonomic \u003ca href=\"https://pantagruel-language.com/\" rel=\"ugc\"\u003enotation\u003c/a\u003e for requirements gathering, designed his own \u003ca href=\"https://blog.zdsmith.com/series/shorthands.html\" rel=\"ugc\"\u003eshorthands\u003c/a\u003e, attended the Recurse center and much \u003ca href=\"https://buttondown.com/zdsmith/archive/\" rel=\"ugc\"\u003emore\u003c/a\u003e. We talk about:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003etacit and combinatory programming\u003c/li\u003e\n\u003cli\u003edomain modeling\u003c/li\u003e\n\u003cli\u003elisp vs. type systems\u003c/li\u003e\n\u003cli\u003emanagement and motivation\u003c/li\u003e\n\u003cli\u003emusic and card games\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eCould you please introduce yourself?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI'm a programmer from New York City. I have a variety of interests, primarily writing systems, systems of notation and poetics. Within the realm of programming, my closest focus is combinatory programming. I do my personal programming in Janet or \u003ca href=\"https://lfe.io/\" rel=\"ugc\"\u003eLisp Flavored Erlang\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTraditional card games, still played in a given village for hundreds of years, are my true love in life (email me if you like them!) Card games are both complete systems and social mediums, happening between people. They don't exist without people and help them interact. Games are \u003ca href=\"https://blog.zdsmith.com/posts/what-makes-a-good-culture-game.html\" rel=\"ugc\"\u003eculture\u003c/a\u003e, evolving like food, language or dress. Modern games are designed, which I have less interest in.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow did you discover combinatorics?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTo clarify, combinatorics is the study of sort of combinations of things while combinatory programming is using combinators, which I focus on.\u003c/p\u003e\n\u003cp\u003eOne of the most salient features of array languages, especially J and APL is \u003cstrong\u003etacit programming\u003c/strong\u003e (equivalent to point-free style in e.g. Haskell). Conor Hoekstra (\u003ca href=\"https://www.youtube.com/@code_report/videos\" rel=\"ugc\"\u003ecodereport\u003c/a\u003e) was the first person (I'm aware of) to say \"hold on a second, there's this whole realm of logic and mathematics called combinatoric logic. If we squint, these behaviors that we love so much in tacit programming are actually examples of combinators.\" I found this concept very compelling. In particular, it prompted me to wonder whether we could pull that behavior out of the array world so that it was no longer \u003cem\u003etacit\u003c/em\u003e, what it would look like in generic programming languages.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConor even \u003ca href=\"https://tacittalk.com/2024/09/27/Episode-5.html\" rel=\"ugc\"\u003einterviewed you\u003c/a\u003e about this! How have you employed combinatory programming at work or your other pursuits?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhat distinguishes me, I think, from many folks enjoying this, is that I'm interested in how to apply it to the actual work of programming, professionally or as an amateur, solo or in an organization. I'm a programmer, you're a programmer, we write programs. I'm interested in this experience, the phenomenology of programming, how to make it easier, funner. Not only how to make it easier for myself to write programs, but to read other people's programs too. That's exactly the question I want to explore with combinators.\u003c/p\u003e\n\u003cp\u003eTacit programming is undoubtedly more terse; you type fewer characters. For an array language enthusiast, typing fewer characters is already the name of the game. But I want to extract it from that context, to explore whether they themselves make programs easier to read or write, instead of merely appreciating them for their theoretical beauty. They're fun, exciting, tickle your brain. But compare it to functional programming, which has been relatively successful in industry, because you write fewer bugs with clearer intent using map instead of for loops, using destructuring and construction rather than in place mutation. I've had the benefit and privilege of working in places with this approach. So I'm interested how combinatory programming lives or dies in a real-world environment.\u003c/p\u003e\n\u003cp\u003eBut more recently I've been doing more management. I did refactor a small function at work with this style, in TypeScript. The code owner, understandably, said \"please don't do this\". It was not a point-free codebase. Ultimately, these techniques are political or social questions. If a long-lived codebases gradually became functional over time, it's not because one engineer got really excited about Haskell and wrote functors and applicatives all over the place. There was actual a discussion that had to be made, with a social and political argument for why it was worth doing. I'm not at the point where I want to advocate to 100 engineers in my organization and say \"alright, we should no longer use variables, no longer use named lambdas\". I want to experiment and see what the value of this stuff is in a real environment.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow did you first discover programming, what were you doing before hearing Conor's revelation?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIt was fairly late in life. In high school, I luckily had an APCS course in C and C++. I loved my teacher and the work, found it incredibly satisfying, but also very difficult manually constructing linked lists and managing memory. It was really hard to wrap my head around the connection between getting a program to compile and making programs that do useful work. So I didn't follow up on programming at university. I didn't graduate at all, I fixed laptops and did data recovery for 10 years, but realized that wasn't what I wanted to do for the rest of my life and tried programming again. Python had become more popular, so I self-studied for 3 months in 2014. I had the enormous good fortune to find out about and get accepted into Hacker School (now \u003ca href=\"https://www.recurse.com/\" rel=\"ugc\"\u003eRecurse\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eMany of the more intellectually rigorous and creative people writing software or about programming have gone there or are part of that community. And I got to spend 3 months with 55 of them in a single office for 4-5 days a week, just working on open source software, any project, but with collaboration, teaching, being taught. So I learned an extraordinary amount in a short time and got a job right after.\u003c/p\u003e\n\u003cp\u003eI wrote in Python and Nim for a few years. I loved Erlang, BEAM, OTP etc. and ended up at an Elixir shop, but the last 5 years have been using TypeScript, professionally.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat did you do with Nim in industry?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMy first programming job was at a logistics company with storage, vans and trucks. We had rudimentary software doing route planning in Python. But we had one incredibly hot loop with a (relatively) complex algorithm. I settled on Nim because it was fast with good c inter-op and a low barrier to entry. I was sufficiently green and naive that I underrated the price of introducing a new language no one else spoke into the tech stack. You have to be very fool-hardy to make that decision and I was in the right place at the right time.\u003c/p\u003e\n\u003cp\u003eBut it turned out perfectly fine! The code was simple and well-written enough that they just had to keep it running without any changes. At any rate, the company stopped existing before it became a problem.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you view management? I also do half programming, half managing, but consider them quite similar, where software development's like industrial engineering, with business analysts documenting or creating processes, tasks which can be performed by people, machines or programs according to cost, efficiency and accuracy. For me, hiring, training and caring for a person or provisioning an environment for a program, ensuring the computer has power, working parts etc. are similar. What's your framework for all of this?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI don't see myself doing the same work when programming or managing.\u003c/p\u003e\n\u003cp\u003eThere are some tremendous, technically adept engineers who produce amazing things that others take and make useful. But most us aren't like that. To be useful or \"deliver value\", we must ensure we're writing the right software for the right reasons while communicating to the right people what we're doing and how to change it later. These are all important parts of making yourself and your code useful on the job.\u003c/p\u003e\n\u003cp\u003eGuiding and advising engineers in such matters is management, to me. Good management won't just think about being maximally useful for the organization but will help each engineer remain excited, have fun ad grow, if they want growth. Everything works better that way. I've worked with teams of brilliant engineers where we spent 6 months producing nothing of value because we weren't going in the right direction and hadn't determined whether the organization actually told us what they wanted or decided to buy this. That's the ideal at least, arranging all of these necessary pieces to help engineers make useful things.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow can we help our teammates grow, have fun, do these things?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eImplicit in your question is, you don't have to be a manager to do this. Right! That's so critical. Sometimes you're the senior person in the team or lower on the totem pole, but you have e.g. the emotional intelligence to see when somebody's stuck or gets more excited about something. The simplest advice is to ask yourself and your colleagues what motivates you individually. \u003cstrong\u003eProgramming's fueled by flow states, excitement, curiosity.\u003c/strong\u003e If you're not feeling it, if you're sluggish and uninspired, you can only do so much. This isn't a mechanical field, but requires creativity and enthusiasm. An easy pitfall, especially for leaders, is assuming everybody's motivated by the same stuff. Startup founders are often motivated by a vision of the future of software or the future of their product domain, but other people can be motivated by hard challenges, supporting and doing right by their team mates, or simply material compensation. For me, I'm committed to supporting my team and making sure they're getting enough of what they need to stay motivated.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat actually motivates you personally? As a manager, you want to help your team, but why do you want to work with a team? What about when you're working on a personal project?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn a professional scenario, anybody's who's been in a field for a long time comes to recognize that people are more important than what you're actually doing at any moment. It's certainly true that the software you write's very likely to be thrown away within a year (and you should hope that it is!) The company you're working in might not exist in 5 years (though you should hope it does). That's the reality of the work. It's rare that any particular software or program will make as much of an impact as the individuals you work with. You can form true relationships with them and impact each others'' lives. We often miss how much we can impact other people's lives by showing up in a certain way. Thinking about how I conduct my whole life, work included, I orient around how I can show up for the people I'll \u003cem\u003ecrash into\u003c/em\u003e that day.\u003c/p\u003e\n\u003cp\u003eFor personal projects, a library or shorthand, I have almost diametrically opposed motivations. What does it mean for other people to engage with your work? What first hooked my to programming was opening a REPL, building, encoding a little system of rules with classes and methods, then watch it go. I love writing down what I know and producing novelty, actually seeing this complex system you can't possibly keep in your head produce emergent behavior. For every project, I have an idea about some individual rules and primitives and want to discover what happens at that inflection moment when there's enough there to move and change on their own steam.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat scratched this itch before you (re)discovered programming?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI've been making \u003ca href=\"https://en.wikipedia.org/wiki/Shorthand\" rel=\"ugc\"\u003eshorthands\u003c/a\u003e and writing systems for myself since 2006. These are systems of rules and signs you elegantly compose to produce something useful. Writing music especially with other people also scratches that itch, with electronic or mechanical means. I used to compose generative or aleatoric music or translate a set of signs, information or data from some domain into the Western scale or another set of pitches! Piling a few relatively simple things which each fit into your head, on top of each other, gives you something complex and rich, indescribable! It's like you have a little compression algorithm and are seeing what it decompresses to.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThere's a long history of generative music in Lisp. \u003ca href=\"https://ccrma.stanford.edu/software/clm/\" rel=\"ugc\"\u003eCommon Lisp Music\u003c/a\u003e, \u003ca href=\"http://repmus.ircam.fr/openmusic/home\" rel=\"ugc\"\u003eOpen Music\u003c/a\u003e, \u003ca href=\"https://incudine.sourceforge.net/\" rel=\"ugc\"\u003eIncudine\u003c/a\u003e, \u003ca href=\"https://www.opusmodus.com/\" rel=\"ugc\"\u003eOpusModus\u003c/a\u003e, \u003ca href=\"https://github.com/ormf/cm\" rel=\"ugc\"\u003eCommon Music\u003c/a\u003e, \u003ca href=\"https://en.wikipedia.org/wiki/David_Cope\" rel=\"ugc\"\u003eDavid Cope\u003c/a\u003e's many books on GOFAI music. More recently I discovered \u003ca href=\"https://lisp.trane.studio/\" rel=\"ugc\"\u003etrane\u003c/a\u003e written in Janet and from the array side, Marshall Lochbaum's doing \u003ca href=\"https://mlochbaum.github.io/BQN-Musician/index.html\" rel=\"ugc\"\u003emusic\u003c/a\u003e with BQN, an array language and Stanley Jordan's been \u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/75144.75174\" rel=\"ugc\"\u003eusing APL\u003c/a\u003e for a long time.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBut you weren't programming then, were you just throwing things at the wall or engaging with another body of work?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMore in the throwing things at the wall school. As an example, 20 years ago, I was thinking about how a musical score isn't the same as a piece of music and is just a sketch, a blueprint. Thinking of \u003ca href=\"https://www.dynamicmath.xyz/strange-attractors/\" rel=\"ugc\"\u003estrange attractors\u003c/a\u003e, where chaotic systems with enough points can define a trend, I thought layering many individual performances of a piece could approach the mean of the music itself. So I lined up as many performances of Schumann's piano concerto in A Minor's first movement, one of my favorite pieces, with normalized tempo and listened.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhich array language did you learn first?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI played around with J a bit and returned to the Recurse Center in 2021, where I \u003ca href=\"https://jnj.li/\" rel=\"ugc\"\u003eembedded\u003c/a\u003e the J runtime into Janet. But I understand K the best, which ironically has middling support for tacit programming, but it tickles my brain and thinking in arrays is a really powerful mental tool.\u003c/p\u003e\n\u003cp\u003eK has the least ranks which would require you to grok matrices and vectors. You can stick to low-dimensional arrays without being encouraged to pile on adverbs which change the rank of your verb.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow much math did and do you know?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eVery little. Like many people, I was never really exposed to math and thought myself bad at it. Later, I read \u003ca href=\"https://worrydream.com/refs/Lockhart_2002_-_A_Mathematician%27s_Lament.pdf\" rel=\"ugc\"\u003eA Mathematician's Lament\u003c/a\u003e and found it incredibly moving. I played around with number and group theory, programming simple things. The \u003ca href=\"https://oeis.org/\" rel=\"ugc\"\u003eOn-Line Encyclopedia of Integer Sequences\u003c/a\u003e is one of my favorite places ever. So I learned there's a vast variety of structures and systems you can play with, but I only engage with them in a very shallow way.\u003c/p\u003e\n\u003cp\u003eThat's why with combinatory stuff, it's important for me to come back to practical programming. We can look at functional programming through category theory, which has produced useful programming techniques. But the techniques themselves have to be useful, critically, without understanding the theory. The whole point's that we can put it on the computer and not have to suspend it in our heads anymore.\u003c/p\u003e\n\u003cp\u003ePeople often learn lisp to overcome a hurdle. For me, it was macros. For array languages and K, I wanted to escape this rigid adherence to iterative for loops or reduce way of thinking. So it wasn't terribly important to master linear algebra, because I don't deal with those kinds of problems.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIverson and others wrote many books teaching math through APL and J.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThey're really breezy, since you don't have to do everything by hand. Most of calculus is learning rules of thumb, methods to solve or guess. But with a computational tool, it's so easy! Iverson had a tremendous mind, Notation as a Tool of Thought is really wonderful. But you could make many counter arguments to the Iversonian array school's idea of terseness unlocking clarity, faster thinking.\u003c/p\u003e\n\u003cp\u003eSome say it overindexes on the wrong things. The time saved typing fewer characters is negiligible, because the real work in APL is rephrasing your problem unti it fits the model and your 10 symbols are correct, which can take as long as writing verbose Python. In a future with less code generated by humans, this matters even less. If AIs spit out and review hundreds of lines of Python, with no human in the loop, I'm not sure how array programming presents an alternative.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://youtu.be/eVddGSTjEd0?si=pO1EHj8GQ6v-2Gbm\u0026amp;t=51\" rel=\"ugc\"\u003eIt's the kids who are wrong.\u003c/a\u003e I mean circling back, what does it mean for someone to engage with someone's work? Why do we want to code in the first place?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eRestricting ourselves to personal projects or blog posts, my ideal was putting things out there with polish, dedicating myself to the project but also documenting it with a fun website, so I'm really creating something I can personally feel good about, a perfect realization of what I wanted to create. My ideal was that this was enough.\u003c/p\u003e\n\u003cp\u003eBut I became frustrated that I didn't have people to talk about these things. You've mentioned shorthand a few times and this occupies a lot of my personal thinking. You'd be surprised to hear, but not a lot of people in my daily life are interested. Shocking, I know, but my friends, coworkers, loved ones think it's cool but don't want to create their own writing systems and discuss them! There's a community \u003ca href=\"https://www.reddit.com/r/shorthand/\" rel=\"ugc\"\u003eon Reddit\u003c/a\u003e, so I spend time there now.\u003c/p\u003e\n\u003cp\u003eI also think a lot about poetics, the relationship between poetic form and mathematics, the use of mathematical techniques to \u003ca href=\"https://blog.zdsmith.com/posts/an-algebraic-sketch-of-poetic-form.html\" rel=\"ugc\"\u003egenerate\u003c/a\u003e poetic forms. I don't have many people to discuss this with, so the reality's that I don't need people to \u003cem\u003euse\u003c/em\u003e the software I write (though it's incredibly gratifying when I hear people do) and I certainly don't need people to tell me how smart I am, what a great blog post, but it's really important for me to know who my audience is and engage in dialogue around the things which interest me. Perhaps I share to connect with others, create points of common and shared interests. For the full person, it's important for me to know there's someone on the other side who thinks any of this is as interesting as I do.\u003c/p\u003e\n\u003cp\u003eI possess the feeling, if not conviction, that other programmers share many of my interests because they all feel so deeply connected. On the other hand, I've posted about card games and shorthand and watched them drop like stones. I have an SSG \u003ca href=\"https://bagatto.co/\" rel=\"ugc\"\u003eBagatto\u003c/a\u003e which people actually use, so people ask for help in different places. In their minds, they're using a piece of software with a community, but to me it's my weird little thing! The moment it hits the internet and is decontextualized, it just becomes part of the internet, of the literature. Recently, my partner got a kind, thoughtful email from a stranger and, it's a truism, it is so nice to get a nice email. That's a microcosm of everything. I want to be in a community and the community, my people, are just people who decided to put something out there.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCall to Action: Send those emails! Tell obscure project how much you like their small projects and make friends! What cool people would you like to broadcast to the world?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eConor Hoekstra is great, walking the line between theory and practice. He has all these nerdy interests but tries to popularize them in podcasts and on youtube. \u003ca href=\"https://jvns.ca/\" rel=\"ugc\"\u003eJulia Evans\u003c/a\u003e does the same with fantastic zines. Anyone in New York should go to the Recurse Center's events to meet people doing the same thing. I just went to Breakpoint which is like a science fair for people who get an idea, build a thing then take the extra step to make it accessible (via readme, making sure it compiles on other people's machines or going to events). There's also \u003ca href=\"https://toddwords.com/wordhack/\" rel=\"ugc\"\u003ewordhack\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you personally approach pretty websites and documentation?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYou can force it, honestly. There are ebbs and flows of motivation. You have to find a way to work with them, be okay with writing something down which you can return to in 6 months. There's some sort of personal organization in making a system to find what you were half-way happy with before putting it away, which you can return to with fresh eyes and passion. \u003ca href=\"https://github.com/Voultapher/sort-research-rs/blob/main/writeup/unreasonable/text.md\" rel=\"ugc\"\u003eThe unreasonable effectiveness of modern sorting algorithms\u003c/a\u003e is relevant; industry and programming has continued to optimize because we've realized how magic numbers matter, per-computation, L1 caches and all of that.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat makes a program beautiful?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBecause I think this goes right back to the question of form. The aesthetic\nexperience of programming seems to me to be a direct engagement with a formal\nsystem, as instantiated in that part of our brain that has evolved to work with\npatterns.\u003c/p\u003e\n\u003cp\u003eThat's why I think it's aesthetically pleasing to write programs. And insofar\nas a program is an arrangement of concepts via relations into some form, it\nseems that we recognize that form as beautiful when it exhibits properties that\nwe admire in other sets-of-relations, viz., mathematical objects, games,\nriddles, and so on. Symmetry, simplicity (as measured against productive\npower), an economy of unique objects, and so on.\u003c/p\u003e\n\u003cp\u003eThis is how I tend to think of it. But it's a hypothesis I haven't been able to\ntest yet. It seems to me that if this is true, I should be able to communicate\nthe beauty of a particular program, via translation, to someone who doesn't\nknow computer programming. I haven't hit on an effective way to do that.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTo what extent should a program be a lookup table?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ePurely industrial programs will often be lookup tables. My personal programs are about systems, ideas I want to explore, so a readable, elegant expression of an \"algorithm\" is the most important thing. None of them need to sacrifice clarity and transparency for efficiency. Indeed, most of the stuff I write for work is just a big map and indexing into it. You can solve many problems this way. Make it a prefix tree if you really want to flex.\u003c/p\u003e\n\u003cp\u003eJanet is a great exemplar of this, ruthlessly pragmatic. A lisp which throws away everything you'd expect of a traditional lisp if it leads to more convenient or pragmatic approaches. Famously like Clojure, Janet's tuples and arrays aren't linked lists, because repeated pointer dereferencing isn't the most efficient way to write programs on modern hardware. But it has everything I want from a lisp: s-expressions and macros.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow did you discover lisp and \u003ca href=\"https://janet-lang.org/docs/index.html\" rel=\"ugc\"\u003eJanet\u003c/a\u003e specifically?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eRecurse is a wonderful place for finding out about the most esoteric and exotic things for programmers. In 2014, Haskell was most exemplary, with everyone wanting to learn Haskell and Hindley-Millner. Lisp is similar. As language family it's fascinating, but as a social phenomenon too! It has an incredible reputation, earned and unearned. There's that \u003ca href=\"https://xkcd.com/224/\" rel=\"ugc\"\u003eXKCD\u003c/a\u003e, Let over Lambda, Paul Graham and Eric Raymond's silly things. So early on, I was introduced to it as something incredibly powerful, hard to understand and very old. But I decided to really learn it from the inside out, 5 years ago, specifically to master macros, which I had only lightly encountered in industry but which seemed directly practical. So I decided to learn a lisp to explore and master macros, work through the books with etc.\u003c/p\u003e\n\u003cp\u003eJanet was a Goldilocks thing for me. I wanted an every day language I could write command line utilities and script in. I would have learned Clojure, but the JVM means running a 45 line script would launch a huge VM which just wouldn't cut it for me. Janet felt clean, didn't have decades of cruft (though it \u003cem\u003edoes\u003c/em\u003e have cruft) and is fast and easy to use.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShorthands, \u003ca href=\"https://github.com/kparc/ksimple/blob/main/a.c\" rel=\"ugc\"\u003eArthur-Whitney-style\u003c/a\u003e C, tactic programming terseness and compression... They're all pretty linked.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI hypothesize the underlying value of tacit programming is reducing the conceptual inventory of a program, not the number of characters or tokens, but the size of the ontology. Less things exist in that universe when you remove a name in favor of a common pattern of function application. That's what I want to compress. That's my elevator pitch for combinator programming.\u003c/p\u003e\n\u003cp\u003eIf there's any universal benefit to macros or Arthur Whitney's style, it's whether we can come up with names to encapsulate these common patterns or combinations of objects rather than just make our name shorter. In fact, I have no interest in shortening the names. I am highly skeptical of the school of thought claiming the more code you can \u003ca href=\"https://github.com/tlack/b-decoded?tab=readme-ov-file#arthur-style\" rel=\"ugc\"\u003efit on your screen\u003c/a\u003e, the better. But stripping unnecessary objects are really worth interrogating and investigating.\u003c/p\u003e\n\u003cp\u003eI wouldn't claim shorthand has similar aims. Shorthand is incredibly practical, it was a business tool for the whole era of writing until typewriters, for anyone who needed to write really fast then actually read what they wrote. For many people, it was an essential skill to make money, falling on the industrial not theoretical side. Yet what I want from my own shorthand system, what makes one beautiful or enjoyable (no longer pure utility but beauty and elegance), is reducing the number of things. I've written a bunch of software to design this over the last year. One of those programs takes the entire inventory finds all the unique concepts in the system and expresses the ratio between that and the inventory of sounds in the English language. There are, of course, more entities in my shorthand than sounds in English, but now you can think about economy. You can arbitrarily compress spoken English with more entities which are less utilized, but can you find the inflection point where you have the most bang for your buck getting the maximal compression without too complex of a system?\u003c/p\u003e\n\u003cp\u003eMinimalism is why people find lisp so beautiful, especially scheme. They've tried to identify the smallest number of primitives necessary. If you look at \u003ca href=\"https://en.wikipedia.org/wiki/SKI_combinator_calculus\" rel=\"ugc\"\u003eSKI combinators\u003c/a\u003e, we can express all Turing complete logic with three or really two primitives. We can also express everything with a Turing machine. But those aren't good systems to actually use. I want to find the inflection point where a system is both easy and pleasing to use, but also sufficiently minimal for our aesthetic sense.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTo what extent do languages do this vs. frameworks for some domain?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI think that's the data model. I'm not a programming language creator. I \u003cem\u003ehave\u003c/em\u003e made languages for domain specific things but I'm not interested in creating a general purpose language. But representing a domain with enough primitives to say what you need without being verbose tickles my brain. Having few enough primitives which compose well that you can keep in your brain, is the name of the game for any business programming. Any time you need to model a domain, you need to create a language or a calculus, a few primitives or basic concepts which compose together to express everything that matters. That set me on fire about programming. I'll be honest, I'm not super interested in logistics, but that basic challenge of modeling everything our logistic team knows and cares about, that's fun!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eType-driven programming is quite different from lisp. How does that influence your modeling?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWorking the last 5 years in TypeScript really colors this, as I've done very little work on larger codebases in lisp. I have done a lot of teamwork in Elixir and BEAM codebases, but I think type systems are a fantastic tool for data modeling in industry, where your code should be maximally understandable and modifiable to someone seeing it for the first time (including you in 6 months). Composing types is a really fantastic, especially with a fast compiler letting you do type inference and higher level typing which stays out of your way. I rely on the compiler a lot. On the other hand, when I'm writing something in e.g. Janet which is both dynamic and \u003cem\u003every\u003c/em\u003e mutable, I get very nervous and fearful about changing the data model. Immutability or types give you a lot of confidence.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you jump into a new domain and truly understand it in order to then model it?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThis comes to my side project \u003ca href=\"https://pantagruel-language.com/\" rel=\"ugc\"\u003ePantagruel\u003c/a\u003e. Returning to the Iversonian question of \u003ca href=\"https://www.jsoftware.com/papers/tot.htm#\" rel=\"ugc\"\u003eNotation as a Tool of Thought\u003c/a\u003e, what's an appropriate notation for domains? A domain is entities, rules or  invariants if you want to sound more mathy. Systems composed of things and rules or truths of how they interact.\u003c/p\u003e\n\u003cp\u003eOne of the real shames of our industry is that we know we have to truly understand a domain before doing anything on the computer, making sure you have the theory down. We know it's critical and some of the thinkers I admire the most really hammer down on this. \u003ca href=\"https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1\" rel=\"ugc\"\u003eProgramming as Theory Building\u003c/a\u003e is my bible. Rich Hickley talks about \u003ca href=\"https://www.youtube.com/watch?v=f84n5oFoZBc\" rel=\"ugc\"\u003eHammock-driven development\u003c/a\u003e. But we don't have good notations or tools for this work. We just write it down with boxes and lines on a whiteboard or use natural languages, both crude and error-prone.\u003c/p\u003e\n\u003cp\u003eMy experimental language Pantagruel is a notation for describing systems. You can describe the rules of a card game, mathematical rules or tickets you need to implement. So we have a domain for our software like video clips which can combine into timelines, be organized in folders and you want to express some property of that system, like a folder can't have a folder with 0 timelines in it. Pantagruel is a very simple notation designed for writing by hand to express these things tersely, but you can also write it on a computer and do static analysis to ensure you've not accidentally gone from a scalar to a vector, single to plural, which plain English wouldn't catch. I want to see if it's actually useful, better than the tools we have today.\u003c/p\u003e\n\u003cp\u003eI came up with a set of syntactical constructions and expressed as many things as possible. If I found myself writing too much or thinking too hard about something, I would add a construct. But if I didn't use something often or could simply combine others to get it, I could eliminate a construct. That's how I generated Pantagruel. It looks nothing like it did when I first started it. My shorthand has gone through dozens of these iterations in the past year.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAre there any other similar tools to Pantagruel?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI've surprisingly not found any. The formal methods world is closest, but it has that theory vs. practice/industry issue. It's very intensive to get a complete model of your domain up in them. The reward's incredible power. But my little system's explicitly easier to pick up (and less powerful). Unfortunately, anyone interested in formal systems or methods thinks my system is nonsense, not worth doing anything worth their time, while the rest of the world is scared off by propositional logic.\u003c/p\u003e\n","description_plain":"I had the pleasure of interviewing and befriending @zdsmith whose passions are very close to my heart. He explores the different forms of notation (Iverson, Naur), makes [combinatory programming](https://tacittalk.com/2024/09/27/Episode-5.html) approachable, ported [J to Janet](https://jnj.li/), created an ergonomic [notation](https://pantagruel-language.com/) for requirements gathering, designed his own [shorthands](https://blog.zdsmith.com/series/shorthands.html), attended the Recurse center and much [more](https://buttondown.com/zdsmith/archive/). We talk about:\r\n- tacit and combinatory programming\r\n- domain modeling\r\n- lisp vs. type systems\r\n- management and motivation\r\n- music and card games\r\n\r\n----\r\n\r\n**Could you please introduce yourself?**\r\n\r\nI'm a programmer from New York City. I have a variety of interests, primarily writing systems, systems of notation and poetics. Within the realm of programming, my closest focus is combinatory programming. I do my personal programming in Janet or [Lisp Flavored Erlang](https://lfe.io/).\r\n\r\nTraditional card games, still played in a given village for hundreds of years, are my true love in life (email me if you like them!) Card games are both complete systems and social mediums, happening between people. They don't exist without people and help them interact. Games are [culture](https://blog.zdsmith.com/posts/what-makes-a-good-culture-game.html), evolving like food, language or dress. Modern games are designed, which I have less interest in.\r\n\r\n**How did you discover combinatorics?**\r\n\r\nTo clarify, combinatorics is the study of sort of combinations of things while combinatory programming is using combinators, which I focus on.\r\n\r\nOne of the most salient features of array languages, especially J and APL is **tacit programming** (equivalent to point-free style in e.g. Haskell). Conor Hoekstra ([codereport](https://www.youtube.com/@code_report/videos)) was the first person (I'm aware of) to say \"hold on a second, there's this whole realm of logic and mathematics called combinatoric logic. If we squint, these behaviors that we love so much in tacit programming are actually examples of combinators.\" I found this concept very compelling. In particular, it prompted me to wonder whether we could pull that behavior out of the array world so that it was no longer _tacit_, what it would look like in generic programming languages.\r\n\r\n**Conor even [interviewed you](https://tacittalk.com/2024/09/27/Episode-5.html) about this! How have you employed combinatory programming at work or your other pursuits?**\r\n\r\nWhat distinguishes me, I think, from many folks enjoying this, is that I'm interested in how to apply it to the actual work of programming, professionally or as an amateur, solo or in an organization. I'm a programmer, you're a programmer, we write programs. I'm interested in this experience, the phenomenology of programming, how to make it easier, funner. Not only how to make it easier for myself to write programs, but to read other people's programs too. That's exactly the question I want to explore with combinators.\r\n\r\nTacit programming is undoubtedly more terse; you type fewer characters. For an array language enthusiast, typing fewer characters is already the name of the game. But I want to extract it from that context, to explore whether they themselves make programs easier to read or write, instead of merely appreciating them for their theoretical beauty. They're fun, exciting, tickle your brain. But compare it to functional programming, which has been relatively successful in industry, because you write fewer bugs with clearer intent using map instead of for loops, using destructuring and construction rather than in place mutation. I've had the benefit and privilege of working in places with this approach. So I'm interested how combinatory programming lives or dies in a real-world environment.\r\n\r\n\r\nBut more recently I've been doing more management. I did refactor a small function at work with this style, in TypeScript. The code owner, understandably, said \"please don't do this\". It was not a point-free codebase. Ultimately, these techniques are political or social questions. If a long-lived codebases gradually became functional over time, it's not because one engineer got really excited about Haskell and wrote functors and applicatives all over the place. There was actual a discussion that had to be made, with a social and political argument for why it was worth doing. I'm not at the point where I want to advocate to 100 engineers in my organization and say \"alright, we should no longer use variables, no longer use named lambdas\". I want to experiment and see what the value of this stuff is in a real environment.\r\n\r\n**How did you first discover programming, what were you doing before hearing Conor's revelation?**\r\n\r\nIt was fairly late in life. In high school, I luckily had an APCS course in C and C++. I loved my teacher and the work, found it incredibly satisfying, but also very difficult manually constructing linked lists and managing memory. It was really hard to wrap my head around the connection between getting a program to compile and making programs that do useful work. So I didn't follow up on programming at university. I didn't graduate at all, I fixed laptops and did data recovery for 10 years, but realized that wasn't what I wanted to do for the rest of my life and tried programming again. Python had become more popular, so I self-studied for 3 months in 2014. I had the enormous good fortune to find out about and get accepted into Hacker School (now [Recurse](https://www.recurse.com/)).\r\n\r\nMany of the more intellectually rigorous and creative people writing software or about programming have gone there or are part of that community. And I got to spend 3 months with 55 of them in a single office for 4-5 days a week, just working on open source software, any project, but with collaboration, teaching, being taught. So I learned an extraordinary amount in a short time and got a job right after.\r\n\r\nI wrote in Python and Nim for a few years. I loved Erlang, BEAM, OTP etc. and ended up at an Elixir shop, but the last 5 years have been using TypeScript, professionally.\r\n\r\n**What did you do with Nim in industry?**\r\n\r\nMy first programming job was at a logistics company with storage, vans and trucks. We had rudimentary software doing route planning in Python. But we had one incredibly hot loop with a (relatively) complex algorithm. I settled on Nim because it was fast with good c inter-op and a low barrier to entry. I was sufficiently green and naive that I underrated the price of introducing a new language no one else spoke into the tech stack. You have to be very fool-hardy to make that decision and I was in the right place at the right time.\r\n\r\nBut it turned out perfectly fine! The code was simple and well-written enough that they just had to keep it running without any changes. At any rate, the company stopped existing before it became a problem.\r\n\r\n**How do you view management? I also do half programming, half managing, but consider them quite similar, where software development's like industrial engineering, with business analysts documenting or creating processes, tasks which can be performed by people, machines or programs according to cost, efficiency and accuracy. For me, hiring, training and caring for a person or provisioning an environment for a program, ensuring the computer has power, working parts etc. are similar. What's your framework for all of this?**\r\n\r\nI don't see myself doing the same work when programming or managing.\r\n\r\nThere are some tremendous, technically adept engineers who produce amazing things that others take and make useful. But most us aren't like that. To be useful or \"deliver value\", we must ensure we're writing the right software for the right reasons while communicating to the right people what we're doing and how to change it later. These are all important parts of making yourself and your code useful on the job.\r\n\r\nGuiding and advising engineers in such matters is management, to me. Good management won't just think about being maximally useful for the organization but will help each engineer remain excited, have fun ad grow, if they want growth. Everything works better that way. I've worked with teams of brilliant engineers where we spent 6 months producing nothing of value because we weren't going in the right direction and hadn't determined whether the organization actually told us what they wanted or decided to buy this. That's the ideal at least, arranging all of these necessary pieces to help engineers make useful things.\r\n\r\n**How can we help our teammates grow, have fun, do these things?**\r\n\r\nImplicit in your question is, you don't have to be a manager to do this. Right! That's so critical. Sometimes you're the senior person in the team or lower on the totem pole, but you have e.g. the emotional intelligence to see when somebody's stuck or gets more excited about something. The simplest advice is to ask yourself and your colleagues what motivates you individually. **Programming's fueled by flow states, excitement, curiosity.** If you're not feeling it, if you're sluggish and uninspired, you can only do so much. This isn't a mechanical field, but requires creativity and enthusiasm. An easy pitfall, especially for leaders, is assuming everybody's motivated by the same stuff. Startup founders are often motivated by a vision of the future of software or the future of their product domain, but other people can be motivated by hard challenges, supporting and doing right by their team mates, or simply material compensation. For me, I'm committed to supporting my team and making sure they're getting enough of what they need to stay motivated.\r\n\r\n**What actually motivates you personally? As a manager, you want to help your team, but why do you want to work with a team? What about when you're working on a personal project?**\r\n\r\nIn a professional scenario, anybody's who's been in a field for a long time comes to recognize that people are more important than what you're actually doing at any moment. It's certainly true that the software you write's very likely to be thrown away within a year (and you should hope that it is!) The company you're working in might not exist in 5 years (though you should hope it does). That's the reality of the work. It's rare that any particular software or program will make as much of an impact as the individuals you work with. You can form true relationships with them and impact each others'' lives. We often miss how much we can impact other people's lives by showing up in a certain way. Thinking about how I conduct my whole life, work included, I orient around how I can show up for the people I'll _crash into_ that day.\r\n\r\nFor personal projects, a library or shorthand, I have almost diametrically opposed motivations. What does it mean for other people to engage with your work? What first hooked my to programming was opening a REPL, building, encoding a little system of rules with classes and methods, then watch it go. I love writing down what I know and producing novelty, actually seeing this complex system you can't possibly keep in your head produce emergent behavior. For every project, I have an idea about some individual rules and primitives and want to discover what happens at that inflection moment when there's enough there to move and change on their own steam.\r\n\r\n**What scratched this itch before you (re)discovered programming?**\r\n\r\nI've been making [shorthands](https://en.wikipedia.org/wiki/Shorthand) and writing systems for myself since 2006. These are systems of rules and signs you elegantly compose to produce something useful. Writing music especially with other people also scratches that itch, with electronic or mechanical means. I used to compose generative or aleatoric music or translate a set of signs, information or data from some domain into the Western scale or another set of pitches! Piling a few relatively simple things which each fit into your head, on top of each other, gives you something complex and rich, indescribable! It's like you have a little compression algorithm and are seeing what it decompresses to.\r\n\r\n**There's a long history of generative music in Lisp. [Common Lisp Music](https://ccrma.stanford.edu/software/clm/), [Open Music](http://repmus.ircam.fr/openmusic/home), [Incudine](https://incudine.sourceforge.net/), [OpusModus](https://www.opusmodus.com/), [Common Music](https://github.com/ormf/cm), [David Cope](https://en.wikipedia.org/wiki/David_Cope)'s many books on GOFAI music. More recently I discovered [trane](https://lisp.trane.studio/) written in Janet and from the array side, Marshall Lochbaum's doing [music](https://mlochbaum.github.io/BQN-Musician/index.html) with BQN, an array language and Stanley Jordan's been [using APL](https://dl.acm.org/doi/pdf/10.1145/75144.75174) for a long time.**\r\n\r\n**But you weren't programming then, were you just throwing things at the wall or engaging with another body of work?**\r\n\r\nMore in the throwing things at the wall school. As an example, 20 years ago, I was thinking about how a musical score isn't the same as a piece of music and is just a sketch, a blueprint. Thinking of [strange attractors](https://www.dynamicmath.xyz/strange-attractors/), where chaotic systems with enough points can define a trend, I thought layering many individual performances of a piece could approach the mean of the music itself. So I lined up as many performances of Schumann's piano concerto in A Minor's first movement, one of my favorite pieces, with normalized tempo and listened.\r\n\r\n**Which array language did you learn first?**\r\n\r\nI played around with J a bit and returned to the Recurse Center in 2021, where I [embedded](https://jnj.li/) the J runtime into Janet. But I understand K the best, which ironically has middling support for tacit programming, but it tickles my brain and thinking in arrays is a really powerful mental tool.\r\n\r\nK has the least ranks which would require you to grok matrices and vectors. You can stick to low-dimensional arrays without being encouraged to pile on adverbs which change the rank of your verb. \r\n\r\n**How much math did and do you know?**\r\n\r\nVery little. Like many people, I was never really exposed to math and thought myself bad at it. Later, I read [A Mathematician's Lament](https://worrydream.com/refs/Lockhart_2002_-_A_Mathematician%27s_Lament.pdf) and found it incredibly moving. I played around with number and group theory, programming simple things. The [On-Line Encyclopedia of Integer Sequences](https://oeis.org/) is one of my favorite places ever. So I learned there's a vast variety of structures and systems you can play with, but I only engage with them in a very shallow way.\r\n\r\nThat's why with combinatory stuff, it's important for me to come back to practical programming. We can look at functional programming through category theory, which has produced useful programming techniques. But the techniques themselves have to be useful, critically, without understanding the theory. The whole point's that we can put it on the computer and not have to suspend it in our heads anymore.\r\n\r\nPeople often learn lisp to overcome a hurdle. For me, it was macros. For array languages and K, I wanted to escape this rigid adherence to iterative for loops or reduce way of thinking. So it wasn't terribly important to master linear algebra, because I don't deal with those kinds of problems.\r\n\r\n**Iverson and others wrote many books teaching math through APL and J.**\r\n\r\nThey're really breezy, since you don't have to do everything by hand. Most of calculus is learning rules of thumb, methods to solve or guess. But with a computational tool, it's so easy! Iverson had a tremendous mind, Notation as a Tool of Thought is really wonderful. But you could make many counter arguments to the Iversonian array school's idea of terseness unlocking clarity, faster thinking.\r\n\r\nSome say it overindexes on the wrong things. The time saved typing fewer characters is negiligible, because the real work in APL is rephrasing your problem unti it fits the model and your 10 symbols are correct, which can take as long as writing verbose Python. In a future with less code generated by humans, this matters even less. If AIs spit out and review hundreds of lines of Python, with no human in the loop, I'm not sure how array programming presents an alternative.\r\n\r\n**[It's the kids who are wrong.](https://youtu.be/eVddGSTjEd0?si=pO1EHj8GQ6v-2Gbm\u0026t=51) I mean circling back, what does it mean for someone to engage with someone's work? Why do we want to code in the first place?**\r\n\r\nRestricting ourselves to personal projects or blog posts, my ideal was putting things out there with polish, dedicating myself to the project but also documenting it with a fun website, so I'm really creating something I can personally feel good about, a perfect realization of what I wanted to create. My ideal was that this was enough.\r\n\r\nBut I became frustrated that I didn't have people to talk about these things. You've mentioned shorthand a few times and this occupies a lot of my personal thinking. You'd be surprised to hear, but not a lot of people in my daily life are interested. Shocking, I know, but my friends, coworkers, loved ones think it's cool but don't want to create their own writing systems and discuss them! There's a community [on Reddit](https://www.reddit.com/r/shorthand/), so I spend time there now.\r\n\r\nI also think a lot about poetics, the relationship between poetic form and mathematics, the use of mathematical techniques to [generate](https://blog.zdsmith.com/posts/an-algebraic-sketch-of-poetic-form.html) poetic forms. I don't have many people to discuss this with, so the reality's that I don't need people to _use_ the software I write (though it's incredibly gratifying when I hear people do) and I certainly don't need people to tell me how smart I am, what a great blog post, but it's really important for me to know who my audience is and engage in dialogue around the things which interest me. Perhaps I share to connect with others, create points of common and shared interests. For the full person, it's important for me to know there's someone on the other side who thinks any of this is as interesting as I do.\r\n\r\nI possess the feeling, if not conviction, that other programmers share many of my interests because they all feel so deeply connected. On the other hand, I've posted about card games and shorthand and watched them drop like stones. I have an SSG [Bagatto](https://bagatto.co/) which people actually use, so people ask for help in different places. In their minds, they're using a piece of software with a community, but to me it's my weird little thing! The moment it hits the internet and is decontextualized, it just becomes part of the internet, of the literature. Recently, my partner got a kind, thoughtful email from a stranger and, it's a truism, it is so nice to get a nice email. That's a microcosm of everything. I want to be in a community and the community, my people, are just people who decided to put something out there.\r\n\r\n**Call to Action: Send those emails! Tell obscure project how much you like their small projects and make friends! What cool people would you like to broadcast to the world?**\r\n\r\nConor Hoekstra is great, walking the line between theory and practice. He has all these nerdy interests but tries to popularize them in podcasts and on youtube. [Julia Evans](https://jvns.ca/) does the same with fantastic zines. Anyone in New York should go to the Recurse Center's events to meet people doing the same thing. I just went to Breakpoint which is like a science fair for people who get an idea, build a thing then take the extra step to make it accessible (via readme, making sure it compiles on other people's machines or going to events). There's also [wordhack](https://toddwords.com/wordhack/).\r\n\r\n**How do you personally approach pretty websites and documentation?**\r\n\r\nYou can force it, honestly. There are ebbs and flows of motivation. You have to find a way to work with them, be okay with writing something down which you can return to in 6 months. There's some sort of personal organization in making a system to find what you were half-way happy with before putting it away, which you can return to with fresh eyes and passion. [The unreasonable effectiveness of modern sorting algorithms](https://github.com/Voultapher/sort-research-rs/blob/main/writeup/unreasonable/text.md) is relevant; industry and programming has continued to optimize because we've realized how magic numbers matter, per-computation, L1 caches and all of that.\r\n\r\n\r\n**What makes a program beautiful?**\r\n\r\nBecause I think this goes right back to the question of form. The aesthetic\r\nexperience of programming seems to me to be a direct engagement with a formal\r\nsystem, as instantiated in that part of our brain that has evolved to work with\r\npatterns.\r\n\r\nThat's why I think it's aesthetically pleasing to write programs. And insofar\r\nas a program is an arrangement of concepts via relations into some form, it\r\nseems that we recognize that form as beautiful when it exhibits properties that\r\nwe admire in other sets-of-relations, viz., mathematical objects, games,\r\nriddles, and so on. Symmetry, simplicity (as measured against productive\r\npower), an economy of unique objects, and so on.\r\n\r\nThis is how I tend to think of it. But it's a hypothesis I haven't been able to\r\ntest yet. It seems to me that if this is true, I should be able to communicate\r\nthe beauty of a particular program, via translation, to someone who doesn't\r\nknow computer programming. I haven't hit on an effective way to do that.\r\n\r\n**To what extent should a program be a lookup table?**\r\n\r\nPurely industrial programs will often be lookup tables. My personal programs are about systems, ideas I want to explore, so a readable, elegant expression of an \"algorithm\" is the most important thing. None of them need to sacrifice clarity and transparency for efficiency. Indeed, most of the stuff I write for work is just a big map and indexing into it. You can solve many problems this way. Make it a prefix tree if you really want to flex.\r\n\r\nJanet is a great exemplar of this, ruthlessly pragmatic. A lisp which throws away everything you'd expect of a traditional lisp if it leads to more convenient or pragmatic approaches. Famously like Clojure, Janet's tuples and arrays aren't linked lists, because repeated pointer dereferencing isn't the most efficient way to write programs on modern hardware. But it has everything I want from a lisp: s-expressions and macros.\r\n\r\n**How did you discover lisp and [Janet](https://janet-lang.org/docs/index.html) specifically?**\r\n\r\nRecurse is a wonderful place for finding out about the most esoteric and exotic things for programmers. In 2014, Haskell was most exemplary, with everyone wanting to learn Haskell and Hindley-Millner. Lisp is similar. As language family it's fascinating, but as a social phenomenon too! It has an incredible reputation, earned and unearned. There's that [XKCD](https://xkcd.com/224/), Let over Lambda, Paul Graham and Eric Raymond's silly things. So early on, I was introduced to it as something incredibly powerful, hard to understand and very old. But I decided to really learn it from the inside out, 5 years ago, specifically to master macros, which I had only lightly encountered in industry but which seemed directly practical. So I decided to learn a lisp to explore and master macros, work through the books with etc.\r\n\r\nJanet was a Goldilocks thing for me. I wanted an every day language I could write command line utilities and script in. I would have learned Clojure, but the JVM means running a 45 line script would launch a huge VM which just wouldn't cut it for me. Janet felt clean, didn't have decades of cruft (though it _does_ have cruft) and is fast and easy to use.\r\n\r\n**Shorthands, [Arthur-Whitney-style](https://github.com/kparc/ksimple/blob/main/a.c) C, tactic programming terseness and compression... They're all pretty linked.**\r\n\r\nI hypothesize the underlying value of tacit programming is reducing the conceptual inventory of a program, not the number of characters or tokens, but the size of the ontology. Less things exist in that universe when you remove a name in favor of a common pattern of function application. That's what I want to compress. That's my elevator pitch for combinator programming.\r\n\r\nIf there's any universal benefit to macros or Arthur Whitney's style, it's whether we can come up with names to encapsulate these common patterns or combinations of objects rather than just make our name shorter. In fact, I have no interest in shortening the names. I am highly skeptical of the school of thought claiming the more code you can [fit on your screen](https://github.com/tlack/b-decoded?tab=readme-ov-file#arthur-style), the better. But stripping unnecessary objects are really worth interrogating and investigating.\r\n\r\nI wouldn't claim shorthand has similar aims. Shorthand is incredibly practical, it was a business tool for the whole era of writing until typewriters, for anyone who needed to write really fast then actually read what they wrote. For many people, it was an essential skill to make money, falling on the industrial not theoretical side. Yet what I want from my own shorthand system, what makes one beautiful or enjoyable (no longer pure utility but beauty and elegance), is reducing the number of things. I've written a bunch of software to design this over the last year. One of those programs takes the entire inventory finds all the unique concepts in the system and expresses the ratio between that and the inventory of sounds in the English language. There are, of course, more entities in my shorthand than sounds in English, but now you can think about economy. You can arbitrarily compress spoken English with more entities which are less utilized, but can you find the inflection point where you have the most bang for your buck getting the maximal compression without too complex of a system?\r\n\r\nMinimalism is why people find lisp so beautiful, especially scheme. They've tried to identify the smallest number of primitives necessary. If you look at [SKI combinators](https://en.wikipedia.org/wiki/SKI_combinator_calculus), we can express all Turing complete logic with three or really two primitives. We can also express everything with a Turing machine. But those aren't good systems to actually use. I want to find the inflection point where a system is both easy and pleasing to use, but also sufficiently minimal for our aesthetic sense.\r\n\r\n**To what extent do languages do this vs. frameworks for some domain?**\r\n\r\nI think that's the data model. I'm not a programming language creator. I _have_ made languages for domain specific things but I'm not interested in creating a general purpose language. But representing a domain with enough primitives to say what you need without being verbose tickles my brain. Having few enough primitives which compose well that you can keep in your brain, is the name of the game for any business programming. Any time you need to model a domain, you need to create a language or a calculus, a few primitives or basic concepts which compose together to express everything that matters. That set me on fire about programming. I'll be honest, I'm not super interested in logistics, but that basic challenge of modeling everything our logistic team knows and cares about, that's fun!\r\n\r\n**Type-driven programming is quite different from lisp. How does that influence your modeling?**\r\n\r\nWorking the last 5 years in TypeScript really colors this, as I've done very little work on larger codebases in lisp. I have done a lot of teamwork in Elixir and BEAM codebases, but I think type systems are a fantastic tool for data modeling in industry, where your code should be maximally understandable and modifiable to someone seeing it for the first time (including you in 6 months). Composing types is a really fantastic, especially with a fast compiler letting you do type inference and higher level typing which stays out of your way. I rely on the compiler a lot. On the other hand, when I'm writing something in e.g. Janet which is both dynamic and _very_ mutable, I get very nervous and fearful about changing the data model. Immutability or types give you a lot of confidence.\r\n\r\n**How do you jump into a new domain and truly understand it in order to then model it?**\r\n\r\nThis comes to my side project [Pantagruel](https://pantagruel-language.com/). Returning to the Iversonian question of [Notation as a Tool of Thought](https://www.jsoftware.com/papers/tot.htm#), what's an appropriate notation for domains? A domain is entities, rules or  invariants if you want to sound more mathy. Systems composed of things and rules or truths of how they interact. \r\n\r\nOne of the real shames of our industry is that we know we have to truly understand a domain before doing anything on the computer, making sure you have the theory down. We know it's critical and some of the thinkers I admire the most really hammer down on this. [Programming as Theory Building](https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1) is my bible. Rich Hickley talks about [Hammock-driven development](https://www.youtube.com/watch?v=f84n5oFoZBc). But we don't have good notations or tools for this work. We just write it down with boxes and lines on a whiteboard or use natural languages, both crude and error-prone.\r\n\r\nMy experimental language Pantagruel is a notation for describing systems. You can describe the rules of a card game, mathematical rules or tickets you need to implement. So we have a domain for our software like video clips which can combine into timelines, be organized in folders and you want to express some property of that system, like a folder can't have a folder with 0 timelines in it. Pantagruel is a very simple notation designed for writing by hand to express these things tersely, but you can also write it on a computer and do static analysis to ensure you've not accidentally gone from a scalar to a vector, single to plural, which plain English wouldn't catch. I want to see if it's actually useful, better than the tools we have today.\r\n\r\nI came up with a set of syntactical constructions and expressed as many things as possible. If I found myself writing too much or thinking too hard about something, I would add a construct. But if I didn't use something often or could simply combine others to get it, I could eliminate a construct. That's how I generated Pantagruel. It looks nothing like it did when I first started it. My shorthand has gone through dozens of these iterations in the past year.\r\n\r\n**Are there any other similar tools to Pantagruel?**\r\n\r\nI've surprisingly not found any. The formal methods world is closest, but it has that theory vs. practice/industry issue. It's very intensive to get a complete model of your domain up in them. The reward's incredible power. But my little system's explicitly easier to pick up (and less powerful). Unfortunately, anyone interested in formal systems or methods thinks my system is nonsense, not worth doing anything worth their time, while the rest of the world is scared off by propositional logic.","submitter_user":"veqq","user_is_author":true,"tags":["person"],"short_id_url":"https://lobste.rs/s/p8hshz","comments_url":"https://lobste.rs/s/p8hshz/lobsters_interview_with_zdsmith"},{"short_id":"qhs3l8","created_at":"2025-10-09T23:17:59.000-05:00","title":"The Physics of Euler's Formula | Laplace Transform Prelude","url":"https://youtu.be/-j8PzkZ70Lg","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"LesleyLai","user_is_author":false,"tags":["math","video"],"short_id_url":"https://lobste.rs/s/qhs3l8","comments_url":"https://lobste.rs/s/qhs3l8/physics_euler_s_formula_laplace"},{"short_id":"uvr468","created_at":"2025-10-09T18:56:56.000-05:00","title":"Dear Rubyists: Shopify Isnt Your Enemy","url":"https://byroot.github.io/opensource/ruby/2025/10/09/dear-rubyists.html","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"Jackevansevo","user_is_author":false,"tags":["ruby"],"short_id_url":"https://lobste.rs/s/uvr468","comments_url":"https://lobste.rs/s/uvr468/dear_rubyists_shopify_isn_t_your_enemy"},{"short_id":"4dzvlr","created_at":"2025-10-09T18:40:48.000-05:00","title":"Finding a VS Code Memory Leak","url":"https://randomascii.wordpress.com/2025/10/09/finding-a-vs-code-memory-leak/","score":5,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"wheybags","user_is_author":false,"tags":["c++","windows"],"short_id_url":"https://lobste.rs/s/4dzvlr","comments_url":"https://lobste.rs/s/4dzvlr/finding_vs_code_memory_leak"},{"short_id":"esvr7z","created_at":"2025-10-09T18:01:09.000-05:00","title":"GitHub Will Prioritize Migrating to Azure Over Feature Development","url":"https://thenewstack.io/github-will-prioritize-migrating-to-azure-over-feature-development/","score":10,"flags":2,"comment_count":10,"description":"","description_plain":"","submitter_user":"JordiGH","user_is_author":false,"tags":["scaling"],"short_id_url":"https://lobste.rs/s/esvr7z","comments_url":"https://lobste.rs/s/esvr7z/github_will_prioritize_migrating_azure"},{"short_id":"6kfcqo","created_at":"2025-10-09T15:38:52.000-05:00","title":"magnolia: Interactive shell navigation and history","url":"https://codeberg.org/mtmn/magnolia","score":6,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"miro","user_is_author":true,"tags":["a11y","databases","linux","rust"],"short_id_url":"https://lobste.rs/s/6kfcqo","comments_url":"https://lobste.rs/s/6kfcqo/magnolia_interactive_shell_navigation"},{"short_id":"yzfo82","created_at":"2025-10-09T15:08:02.000-05:00","title":"Making Slint Desktop-Ready","url":"https://slint.dev/blog/making-slint-desktop-ready","score":17,"flags":1,"comment_count":6,"description":"","description_plain":"","submitter_user":"dryya","user_is_author":false,"tags":["graphics","rust"],"short_id_url":"https://lobste.rs/s/yzfo82","comments_url":"https://lobste.rs/s/yzfo82/making_slint_desktop_ready"},{"short_id":"niramb","created_at":"2025-10-09T14:46:25.000-05:00","title":"Code is Never Neutral: Why All Software is Political","url":"https://www.youtube.com/watch?v=Kpfff6TS018","score":13,"flags":4,"comment_count":9,"description":"","description_plain":"","submitter_user":"FedericoSchonborn","user_is_author":false,"tags":["culture","video"],"short_id_url":"https://lobste.rs/s/niramb","comments_url":"https://lobste.rs/s/niramb/code_is_never_neutral_why_all_software_is"},{"short_id":"rwvh6g","created_at":"2025-10-09T14:32:27.000-05:00","title":"Examples are the best documentation","url":"https://rakhim.exotext.com/examples-are-the-best-documentation","score":42,"flags":0,"comment_count":18,"description":"","description_plain":"","submitter_user":"rbr","user_is_author":false,"tags":["practices"],"short_id_url":"https://lobste.rs/s/rwvh6g","comments_url":"https://lobste.rs/s/rwvh6g/examples_are_best_documentation"},{"short_id":"biqecl","created_at":"2025-10-09T13:49:11.000-05:00","title":"Rubygems.org AWS Root Access Event  September 2025","url":"https://rubycentral.org/news/rubygems-org-aws-root-access-event-september-2025/","score":4,"flags":0,"comment_count":4,"description":"","description_plain":"","submitter_user":"bt","user_is_author":false,"tags":["ruby","security"],"short_id_url":"https://lobste.rs/s/biqecl","comments_url":"https://lobste.rs/s/biqecl/rubygems_org_aws_root_access_event"},{"short_id":"pds2zb","created_at":"2025-10-09T13:06:53.000-05:00","title":"A small number of samples can poison LLMs of any size","url":"https://www.anthropic.com/research/small-samples-poison","score":27,"flags":0,"comment_count":8,"description":"","description_plain":"","submitter_user":"teymour","user_is_author":false,"tags":["ai"],"short_id_url":"https://lobste.rs/s/pds2zb","comments_url":"https://lobste.rs/s/pds2zb/small_number_samples_can_poison_llms_any"},{"short_id":"dhegkj","created_at":"2025-10-09T12:06:26.000-05:00","title":"Fedora floats AI-assisted contributions policy","url":"https://lwn.net/Articles/1039623/","score":6,"flags":0,"comment_count":5,"description":"","description_plain":"","submitter_user":"gnyeki","user_is_author":false,"tags":["linux","vibecoding"],"short_id_url":"https://lobste.rs/s/dhegkj","comments_url":"https://lobste.rs/s/dhegkj/fedora_floats_ai_assisted_contributions"},{"short_id":"pydvse","created_at":"2025-10-09T11:49:22.000-05:00","title":"Fireman Sam (COMMODORE 64)","url":"http://retrovania-vgjunk.blogspot.com/2016/11/fireman-sam-commodore-64.html","score":1,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"raymii","user_is_author":false,"tags":["games"],"short_id_url":"https://lobste.rs/s/pydvse","comments_url":"https://lobste.rs/s/pydvse/fireman_sam_commodore_64"},{"short_id":"3hamiv","created_at":"2025-10-09T11:00:48.000-05:00","title":"What is Algebraic about Algebraic Effects?","url":"https://interjectedfuture.com/what-is-algebraic-about-algebraic-effects/","score":7,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"iamwil","user_is_author":true,"tags":["programming"],"short_id_url":"https://lobste.rs/s/3hamiv","comments_url":"https://lobste.rs/s/3hamiv/what_is_algebraic_about_algebraic"},{"short_id":"twddhr","created_at":"2025-10-09T10:55:05.000-05:00","title":"Two Kinds of \"Relicensing\" (2023)","url":"https://writing.kemitchell.com/2023/09/23/Two-Kinds-Relicensing","score":11,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"jeezy","user_is_author":false,"tags":["law"],"short_id_url":"https://lobste.rs/s/twddhr","comments_url":"https://lobste.rs/s/twddhr/two_kinds_relicensing_2023"},{"short_id":"0j2e2w","created_at":"2025-10-09T10:40:05.000-05:00","title":"The Write Stuff: Concurrent Write Transactions in SQLite","url":"https://oldmoe.blog/2024/07/08/the-write-stuff-concurrent-write-transactions-in-sqlite/","score":7,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"WA9ACE","user_is_author":false,"tags":["databases","ruby"],"short_id_url":"https://lobste.rs/s/0j2e2w","comments_url":"https://lobste.rs/s/0j2e2w/write_stuff_concurrent_write"},{"short_id":"mczi9m","created_at":"2025-10-09T10:05:09.000-05:00","title":"Four years, Five failures, One compiler - The journey","url":"https://daymare.net/blogs/four-years-five-failures-one-compiler/","score":10,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"hwayne","user_is_author":false,"tags":["compilers"],"short_id_url":"https://lobste.rs/s/mczi9m","comments_url":"https://lobste.rs/s/mczi9m/four_years_five_failures_one_compiler"},{"short_id":"c3dnrm","created_at":"2025-10-09T09:35:18.000-05:00","title":"How to store ordered information in a Relational Database (2015)","url":"https://softwareengineering.stackexchange.com/questions/304593/how-to-store-ordered-information-in-a-relational-database","score":12,"flags":1,"comment_count":7,"description":"","description_plain":"","submitter_user":"vrolfs","user_is_author":false,"tags":["databases"],"short_id_url":"https://lobste.rs/s/c3dnrm","comments_url":"https://lobste.rs/s/c3dnrm/how_store_ordered_information"},{"short_id":"83xufu","created_at":"2025-10-09T09:21:16.000-05:00","title":"Solving Git's Pain Points with Jujutsu","url":"https://www.youtube.com/watch?v=ulJ_Pw8qqsE","score":19,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"PuercoPop","user_is_author":false,"tags":["vcs","video"],"short_id_url":"https://lobste.rs/s/83xufu","comments_url":"https://lobste.rs/s/83xufu/solving_git_s_pain_points_with_jujutsu"},{"short_id":"digojk","created_at":"2025-10-09T09:18:19.000-05:00","title":"Intel's Open-Source Strategy Is Changing At Odds With The Ethos Of Open-Source","url":"https://www.phoronix.com/review/intel-open-source-2025","score":25,"flags":1,"comment_count":3,"description":"","description_plain":"","submitter_user":"theelx","user_is_author":false,"tags":["linux","programming"],"short_id_url":"https://lobste.rs/s/digojk","comments_url":"https://lobste.rs/s/digojk/intel_s_open_source_strategy_is_changing"},{"short_id":"dpm6uh","created_at":"2025-10-09T08:53:00.000-05:00","title":"TIL: Python's splitlines does a lot more than just newlines","url":"https://yossarian.net/til/post/python-s-splitlines-does-a-lot-more-than-just-newlines/","score":29,"flags":0,"comment_count":6,"description":"","description_plain":"","submitter_user":"yossarian","user_is_author":true,"tags":["python"],"short_id_url":"https://lobste.rs/s/dpm6uh","comments_url":"https://lobste.rs/s/dpm6uh/til_python_s_splitlines_does_lot_more_than"},{"short_id":"yjipld","created_at":"2025-10-09T05:35:21.000-05:00","title":"1k LEDs Is No Limit","url":"https://xayax.net/1k_leds_is_no_limit/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"HugoDaniel","user_is_author":false,"tags":["graphics","hardware"],"short_id_url":"https://lobste.rs/s/yjipld","comments_url":"https://lobste.rs/s/yjipld/1k_leds_is_no_limit"},{"short_id":"fysgz3","created_at":"2025-10-09T05:29:38.000-05:00","title":"Introducing the React Foundation: The New Home for React \u0026 React Native","url":"https://engineering.fb.com/2025/10/07/open-source/introducing-the-react-foundation-the-new-home-for-react-react-native/","score":20,"flags":2,"comment_count":3,"description":"","description_plain":"","submitter_user":"mitsuhiko","user_is_author":false,"tags":["javascript"],"short_id_url":"https://lobste.rs/s/fysgz3","comments_url":"https://lobste.rs/s/fysgz3/introducing_react_foundation_new_home"},{"short_id":"n6jiog","created_at":"2025-10-09T04:55:56.000-05:00","title":"How I Learned to Code (using Japanese Method)","url":"https://blog.stackademic.com/how-i-learned-to-code-using-japanese-method-a01a74c35224","score":3,"flags":6,"comment_count":2,"description":"","description_plain":"","submitter_user":"mysticmode","user_is_author":false,"tags":["philosophy","practices","programming"],"short_id_url":"https://lobste.rs/s/n6jiog","comments_url":"https://lobste.rs/s/n6jiog/how_i_learned_code_using_japanese_method"}]