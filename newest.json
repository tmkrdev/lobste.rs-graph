[{"short_id":"uihcec","created_at":"2025-10-06T01:22:42.000-05:00","title":"gem.coop","url":"https://gem.coop/","score":10,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"kevinc","user_is_author":false,"tags":["ruby"],"short_id_url":"https://lobste.rs/s/uihcec","comments_url":"https://lobste.rs/s/uihcec/gem_coop"},{"short_id":"voi3sp","created_at":"2025-10-06T01:15:28.000-05:00","title":"Simple automated deployments using git push (2024)","url":"https://garrido.io/notes/simple-automated-deployments-git-push/","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"eduard","user_is_author":false,"tags":["devops","vcs"],"short_id_url":"https://lobste.rs/s/voi3sp","comments_url":"https://lobste.rs/s/voi3sp/simple_automated_deployments_using_git"},{"short_id":"gg8l3g","created_at":"2025-10-05T22:44:33.000-05:00","title":"The Server in the Closet","url":"https://robertgreiner.com/the-server-in-the-closet/","score":3,"flags":2,"comment_count":0,"description":"","description_plain":"","submitter_user":"kmatt","user_is_author":false,"tags":["ai"],"short_id_url":"https://lobste.rs/s/gg8l3g","comments_url":"https://lobste.rs/s/gg8l3g/server_closet"},{"short_id":"zo5arc","created_at":"2025-10-05T19:42:16.000-05:00","title":"NIRS fire destroys [South Korean] government's cloud storage system, no backups available","url":"https://koreajoongangdaily.joins.com/news/2025-10-01/national/socialAffairs/NIRS-fire-destroys-governments-cloud-storage-system-no-backups-available/2412936","score":29,"flags":2,"comment_count":0,"description":"","description_plain":"","submitter_user":"teymour","user_is_author":false,"tags":["hardware"],"short_id_url":"https://lobste.rs/s/zo5arc","comments_url":"https://lobste.rs/s/zo5arc/nirs_fire_destroys_south_korean"},{"short_id":"jx047q","created_at":"2025-10-05T17:44:11.000-05:00","title":"Premature Generalization","url":"https://youtu.be/P5lNzRA8rYI","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"krig","user_is_author":false,"tags":["practices","video"],"short_id_url":"https://lobste.rs/s/jx047q","comments_url":"https://lobste.rs/s/jx047q/premature_generalization"},{"short_id":"3p1uht","created_at":"2025-10-05T16:06:29.000-05:00","title":"cargo-subspace: Make rust-analyzer work better with very large cargo workspaces","url":"https://github.com/ethowitz/cargo-subspace","score":5,"flags":0,"comment_count":5,"description":"\u003cp\u003e\u003cstrong\u003eLet me preface all of this by saying that rust-analyzer is an amazing project, and I am eternally grateful for the many people who contribute to it! It makes developing rust code a breeze, and it has surely significantly contributed to Rust's widespread adoption.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIf you've ever worked with a very large cargo workspace (think hundreds of crates), you know that rust-analyzer eagerly builds compile time dependencies (e.g. proc macros) and indexes all the crates in your workspace at startup. For very large workspaces, this can take quite a while. Even after indexing is complete, operations like searching for symbols and autocomplete can be laggy. If you often open and close your editor (shout out to all the (neo)vim users out there), it can take a few minutes for rust-analyzer to finish starting up again. Setting \u003ccode\u003echeck.workspace = false\u003c/code\u003e and \u003ccode\u003ecachePriming.enable = false\u003c/code\u003e can help significantly, but in my experience, they don't solve the problem completely.\u003c/p\u003e\n\u003cp\u003eAfter reading through the rust-analyzer manual, I noticed that rust-analyzer supports integrating with third party build tools, like bazel and buck. In short, it is possible to point rust-analyzer to a command that it will invoke with a path to a source code file to discover information about the crate that the file belongs to. This \"automatic project discovery\" is intended to give third party build tools a way to communicate information about the structure of a project (e.g. the dependency graph) such that rust-analyzer doesn't need to use cargo. I realized that, theoretically, it should be possible to write a tool that still uses cargo under the hood and selectively tells rust-analyzer about a workspace's dependency graph as new files are opened.\u003c/p\u003e\n\u003cp\u003eThat's where cargo-subspace comes in. cargo-subspace is a CLI tool that takes a path to a source code file as an argument and prints out information about the crate that the file belongs to and that crate's dependencies. It works like this:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFind the manifest path (i.e. the path to the Cargo.toml) for the source code file's crate to determine the crate that owns the file\u003c/li\u003e\n\u003cli\u003eInvoke \u003ccode\u003ecargo metadata\u003c/code\u003e, which returns the full dependency graph for the workspace\u003c/li\u003e\n\u003cli\u003ePrune the dependency graph so that it only contains the file's crate and that crate's dependencies\u003c/li\u003e\n\u003cli\u003eBuild compile time dependencies (e.g. proc macros and build scripts) for only the crates in the pruned dependency graph\u003c/li\u003e\n\u003cli\u003ePrint the pruned dependency graph in the JSON format expected by rust-analyzer\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs you open new files in your editor, rust-analyzer will invoke the tool to discover information about how the crate fits into the larger dependency graph of the workspace, lazily indexing and building compile time dependencies as you go. I've found that this approach significantly reduces rust-analyzer's startup time and makes it much zipper and more stable.\u003c/p\u003e\n\u003cp\u003eIf you frequently work with very large cargo workspaces, I'd love for you to try it out and give me some feedback. I tested it myself and it seems to work the way I'd expect, but I'm sure there are some edge cases I haven't considered. There are also some other features I'm considering adding (e.g. an option to include all the dependents of a crate in the dependency graph and not just the dependencies, the ability to read from an \"allowlist\" file to always index and load a subset of the crates in the workspace, etc.), and I'd be curious to hear if y'all have any other ideas/requests.  Installation and configuration instructions can be found in the README.\u003c/p\u003e\n\u003cp\u003eThanks for reading, and happy rusting!\u003c/p\u003e\n","description_plain":"**Let me preface all of this by saying that rust-analyzer is an amazing project, and I am eternally grateful for the many people who contribute to it! It makes developing rust code a breeze, and it has surely significantly contributed to Rust's widespread adoption.**\r\n\r\nIf you've ever worked with a very large cargo workspace (think hundreds of crates), you know that rust-analyzer eagerly builds compile time dependencies (e.g. proc macros) and indexes all the crates in your workspace at startup. For very large workspaces, this can take quite a while. Even after indexing is complete, operations like searching for symbols and autocomplete can be laggy. If you often open and close your editor (shout out to all the (neo)vim users out there), it can take a few minutes for rust-analyzer to finish starting up again. Setting `check.workspace = false` and `cachePriming.enable = false` can help significantly, but in my experience, they don't solve the problem completely.\r\n\r\nAfter reading through the rust-analyzer manual, I noticed that rust-analyzer supports integrating with third party build tools, like bazel and buck. In short, it is possible to point rust-analyzer to a command that it will invoke with a path to a source code file to discover information about the crate that the file belongs to. This \"automatic project discovery\" is intended to give third party build tools a way to communicate information about the structure of a project (e.g. the dependency graph) such that rust-analyzer doesn't need to use cargo. I realized that, theoretically, it should be possible to write a tool that still uses cargo under the hood and selectively tells rust-analyzer about a workspace's dependency graph as new files are opened.\r\n\r\nThat's where cargo-subspace comes in. cargo-subspace is a CLI tool that takes a path to a source code file as an argument and prints out information about the crate that the file belongs to and that crate's dependencies. It works like this:\r\n\r\n- Find the manifest path (i.e. the path to the Cargo.toml) for the source code file's crate to determine the crate that owns the file\r\n- Invoke `cargo metadata`, which returns the full dependency graph for the workspace\r\n- Prune the dependency graph so that it only contains the file's crate and that crate's dependencies\r\n- Build compile time dependencies (e.g. proc macros and build scripts) for only the crates in the pruned dependency graph\r\n- Print the pruned dependency graph in the JSON format expected by rust-analyzer\r\n\r\nAs you open new files in your editor, rust-analyzer will invoke the tool to discover information about how the crate fits into the larger dependency graph of the workspace, lazily indexing and building compile time dependencies as you go. I've found that this approach significantly reduces rust-analyzer's startup time and makes it much zipper and more stable.\r\n\r\nIf you frequently work with very large cargo workspaces, I'd love for you to try it out and give me some feedback. I tested it myself and it seems to work the way I'd expect, but I'm sure there are some edge cases I haven't considered. There are also some other features I'm considering adding (e.g. an option to include all the dependents of a crate in the dependency graph and not just the dependencies, the ability to read from an \"allowlist\" file to always index and load a subset of the crates in the workspace, etc.), and I'd be curious to hear if y'all have any other ideas/requests.  Installation and configuration instructions can be found in the README.\r\n\r\nThanks for reading, and happy rusting!","submitter_user":"aerolime","user_is_author":true,"tags":["rust"],"short_id_url":"https://lobste.rs/s/3p1uht","comments_url":"https://lobste.rs/s/3p1uht/cargo_subspace_make_rust_analyzer_work"},{"short_id":"unhv2p","created_at":"2025-10-05T16:01:27.000-05:00","title":"Packing The World For Longest Lines Of Sight","url":"https://tombh.co.uk/packing-world-lines-of-sight","score":9,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"tombh","user_is_author":true,"tags":["rust"],"short_id_url":"https://lobste.rs/s/unhv2p","comments_url":"https://lobste.rs/s/unhv2p/packing_world_for_longest_lines_sight"},{"short_id":"y3yauw","created_at":"2025-10-05T14:25:19.000-05:00","title":"How and why EasyOS is different","url":"https://easyos.org/about/how-and-why-easyos-is-different.html","score":14,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"untrusem","user_is_author":false,"tags":["linux"],"short_id_url":"https://lobste.rs/s/y3yauw","comments_url":"https://lobste.rs/s/y3yauw/how_why_easyos_is_different"},{"short_id":"q6c4ur","created_at":"2025-10-05T12:57:23.000-05:00","title":"valuetier.org (and some thoughts on LLMs)","url":"https://ericphanson.com/blog/2025/valuetier.org-and-some-thoughts-on-llms/","score":4,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"eph","user_is_author":true,"tags":["philosophy","vibecoding"],"short_id_url":"https://lobste.rs/s/q6c4ur","comments_url":"https://lobste.rs/s/q6c4ur/valuetier_org_some_thoughts_on_llms"},{"short_id":"id2sr5","created_at":"2025-10-05T12:23:26.000-05:00","title":"How to Discover the Binary System as a Child","url":"https://www.youtube.com/watch?v=lg0RYLlmjJM","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"nrposner","user_is_author":false,"tags":["education","math","video"],"short_id_url":"https://lobste.rs/s/id2sr5","comments_url":"https://lobste.rs/s/id2sr5/how_discover_binary_system_as_child"},{"short_id":"dwz05l","created_at":"2025-10-05T12:11:48.000-05:00","title":"The Temporal Dead Zone, or why the TypeScript codebase is littered with var statements","url":"https://vincentrolfs.dev/blog/ts-var","score":14,"flags":0,"comment_count":8,"description":"","description_plain":"","submitter_user":"jado","user_is_author":false,"tags":["performance","web"],"short_id_url":"https://lobste.rs/s/dwz05l","comments_url":"https://lobste.rs/s/dwz05l/temporal_dead_zone_why_typescript"},{"short_id":"dckg9i","created_at":"2025-10-05T12:10:35.000-05:00","title":"TESID: Textualised Encrypted Sequential Identifiers","url":"https://temp.chrismorgan.info/2025-09-17-tesid/","score":4,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"silby","user_is_author":false,"tags":["databases"],"short_id_url":"https://lobste.rs/s/dckg9i","comments_url":"https://lobste.rs/s/dckg9i/tesid_textualised_encrypted_sequential"},{"short_id":"ycveqa","created_at":"2025-10-05T11:43:08.000-05:00","title":"UUIDv47 = v4 privacy + v7 performance","url":"https://github.com/stateless-me/uuidv47","score":18,"flags":0,"comment_count":5,"description":"","description_plain":"","submitter_user":"pushcx","user_is_author":false,"tags":["c"],"short_id_url":"https://lobste.rs/s/ycveqa","comments_url":"https://lobste.rs/s/ycveqa/uuidv47_v4_privacy_v7_performance"},{"short_id":"nsrig5","created_at":"2025-10-05T10:59:24.000-05:00","title":"Announcing GoboLinux 017.01 - Passing the Torch","url":"https://gobolinux.org//news/119.html","score":8,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"Daniel-V1","user_is_author":false,"tags":["linux","release"],"short_id_url":"https://lobste.rs/s/nsrig5","comments_url":"https://lobste.rs/s/nsrig5/announcing_gobolinux_017_01_passing"},{"short_id":"7myscg","created_at":"2025-10-05T09:50:47.000-05:00","title":"Exit the Feed: The Best Coders Should Walk Away","url":"https://abner.page/post/exit-the-feed/","score":53,"flags":7,"comment_count":24,"description":"","description_plain":"","submitter_user":"abnercoimbre","user_is_author":true,"tags":["culture","philosophy"],"short_id_url":"https://lobste.rs/s/7myscg","comments_url":"https://lobste.rs/s/7myscg/exit_feed_best_coders_should_walk_away"},{"short_id":"tu789k","created_at":"2025-10-05T08:33:16.000-05:00","title":"Personal data storage is an idea whose time has come","url":"https://blog.muni.town/personal-data-storage-idea/","score":15,"flags":0,"comment_count":12,"description":"","description_plain":"","submitter_user":"erlend_sh","user_is_author":true,"tags":["browsers","privacy","web"],"short_id_url":"https://lobste.rs/s/tu789k","comments_url":"https://lobste.rs/s/tu789k/personal_data_storage_is_idea_whose_time"},{"short_id":"szoe3m","created_at":"2025-10-05T08:10:53.000-05:00","title":"Conventional Commits considered harmful","url":"https://larr.net/p/cc.html","score":33,"flags":0,"comment_count":18,"description":"","description_plain":"","submitter_user":"lr0","user_is_author":true,"tags":["rant","vcs"],"short_id_url":"https://lobste.rs/s/szoe3m","comments_url":"https://lobste.rs/s/szoe3m/conventional_commits_considered"},{"short_id":"nsl5gr","created_at":"2025-10-05T08:07:31.000-05:00","title":"The Case for Learned Index Structures","url":"https://dl.acm.org/doi/10.1145/3183713.3196909","score":7,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"j4m3s","user_is_author":false,"tags":["ai","compsci"],"short_id_url":"https://lobste.rs/s/nsl5gr","comments_url":"https://lobste.rs/s/nsl5gr/case_for_learned_index_structures"},{"short_id":"atveg7","created_at":"2025-10-05T07:54:51.000-05:00","title":"RacketCon - Day 2 - Livestream","url":"https://con.racket-lang.org/","score":2,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"soegaard","user_is_author":false,"tags":["event","lisp"],"short_id_url":"https://lobste.rs/s/atveg7","comments_url":"https://lobste.rs/s/atveg7/racketcon_day_2_livestream"},{"short_id":"azrzic","created_at":"2025-10-05T07:31:26.000-05:00","title":"86 GB/s bitpacking with ARM SIMD (single thread)","url":"https://github.com/ashtonsix/perf-portfolio/tree/main/bytepack","score":6,"flags":1,"comment_count":0,"description":"","description_plain":"","submitter_user":"ashtonsix","user_is_author":true,"tags":["c++","performance"],"short_id_url":"https://lobste.rs/s/azrzic","comments_url":"https://lobste.rs/s/azrzic/86_gb_s_bitpacking_with_arm_simd_single"},{"short_id":"owxdcr","created_at":"2025-10-05T06:26:36.000-05:00","title":"Attack paths for exfiltrating data using 1Password CLI","url":"https://codeberg.org/manchicken/1password-cli-vuln-disclosure","score":2,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"hoistbypetard","user_is_author":false,"tags":["security"],"short_id_url":"https://lobste.rs/s/owxdcr","comments_url":"https://lobste.rs/s/owxdcr/attack_paths_for_exfiltrating_data_using"},{"short_id":"rgxngu","created_at":"2025-10-05T05:21:37.000-05:00","title":"Wherever you get your Podcasts","url":"https://knotbin.leaflet.pub/3lx3uqveyj22f","score":15,"flags":0,"comment_count":6,"description":"","description_plain":"","submitter_user":"diktomat","user_is_author":false,"tags":["culture"],"short_id_url":"https://lobste.rs/s/rgxngu","comments_url":"https://lobste.rs/s/rgxngu/wherever_you_get_your_podcasts"},{"short_id":"x6vgkj","created_at":"2025-10-05T05:12:21.000-05:00","title":"Hobby Hilbert Simplex","url":"https://nedbatchelder.com/blog/202509/hobby_hilbert_simplex.html","score":15,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"gerikson","user_is_author":false,"tags":["graphics","math"],"short_id_url":"https://lobste.rs/s/x6vgkj","comments_url":"https://lobste.rs/s/x6vgkj/hobby_hilbert_simplex"},{"short_id":"5jplbc","created_at":"2025-10-05T04:01:59.000-05:00","title":"Adding Stride Scheduling to xv6","url":"https://nickchandler.dev/articles/2025/10/03/lab-report-adding-stride-scheduling-to-xv6/","score":7,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"bitfield","user_is_author":false,"tags":["compsci","osdev"],"short_id_url":"https://lobste.rs/s/5jplbc","comments_url":"https://lobste.rs/s/5jplbc/adding_stride_scheduling_xv6"},{"short_id":"opqxdh","created_at":"2025-10-05T03:36:18.000-05:00","title":"Unlocking Modern CPU Power - Next-Gen C++ Optimization Techniques (2024)","url":"https://www.youtube.com/watch?v=wGSSUSeaLgA","score":2,"flags":0,"comment_count":0,"description":"\u003cp\u003e(I was kind of put off by the AI-generated illustrations, but the talk itself is pretty good.)\u003c/p\u003e\n","description_plain":"(I was kind of put off by the AI-generated illustrations, but the talk itself is pretty good.)","submitter_user":"tmcb","user_is_author":false,"tags":["c++","hardware","video"],"short_id_url":"https://lobste.rs/s/opqxdh","comments_url":"https://lobste.rs/s/opqxdh/unlocking_modern_cpu_power_next_gen_c"}]