[{"short_id":"tbo1nr","created_at":"2025-08-22T22:08:06.000-05:00","title":"Materialized views are obviously useful","url":"https://sophiebits.com/2025/08/22/materialized-views-are-obviously-useful","score":5,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"carlana","user_is_author":false,"tags":["databases"],"short_id_url":"https://lobste.rs/s/tbo1nr","comments_url":"https://lobste.rs/s/tbo1nr/materialized_views_are_obviously_useful"},{"short_id":"nun8rm","created_at":"2025-08-22T21:49:52.000-05:00","title":"An Introduction to Trellis-Owl (1986)","url":"https://dl.acm.org/doi/pdf/10.1145/960112.28699","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"lorddimwit","user_is_author":false,"tags":["plt"],"short_id_url":"https://lobste.rs/s/nun8rm","comments_url":"https://lobste.rs/s/nun8rm/introduction_trellis_owl_1986"},{"short_id":"sxk1le","created_at":"2025-08-22T20:14:05.000-05:00","title":"The 9 Go test assertions I use (and why)","url":"https://www.alexedwards.net/blog/the-9-go-test-assertions-i-use","score":4,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"carlana","user_is_author":false,"tags":["go","testing"],"short_id_url":"https://lobste.rs/s/sxk1le","comments_url":"https://lobste.rs/s/sxk1le/9_go_test_assertions_i_use_why"},{"short_id":"8bnfjy","created_at":"2025-08-22T17:59:56.000-05:00","title":"On the use of LLM assistants for kernel development","url":"https://lwn.net/Articles/1032612/","score":5,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"gnyeki","user_is_author":false,"tags":["linux","vibecoding"],"short_id_url":"https://lobste.rs/s/8bnfjy","comments_url":"https://lobste.rs/s/8bnfjy/on_use_llm_assistants_for_kernel"},{"short_id":"roq4rt","created_at":"2025-08-22T17:44:16.000-05:00","title":"Adventures in State Space","url":"https://www.youtube.com/watch?v=YGLNyHd2w10","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"linkdd","user_is_author":false,"tags":["math","video"],"short_id_url":"https://lobste.rs/s/roq4rt","comments_url":"https://lobste.rs/s/roq4rt/adventures_state_space"},{"short_id":"kpcjmr","created_at":"2025-08-22T16:58:07.000-05:00","title":"Teletype code cards","url":"https://www.rtty.com/CODECARD/codecrd1.htm","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"classichasclass","user_is_author":false,"tags":["historical"],"short_id_url":"https://lobste.rs/s/kpcjmr","comments_url":"https://lobste.rs/s/kpcjmr/teletype_code_cards"},{"short_id":"ysmsfu","created_at":"2025-08-22T15:03:05.000-05:00","title":"No, Google Did Not Unilaterally Decide to Kill XSLT","url":"https://meyerweb.com/eric/thoughts/2025/08/22/no-google-did-not-unilaterally-decide-to-kill-xslt/","score":28,"flags":1,"comment_count":9,"description":"","description_plain":"","submitter_user":"simonw","user_is_author":false,"tags":["web"],"short_id_url":"https://lobste.rs/s/ysmsfu","comments_url":"https://lobste.rs/s/ysmsfu/no_google_did_not_unilaterally_decide"},{"short_id":"0ktx6s","created_at":"2025-08-22T14:52:41.000-05:00","title":"A string formatting library in 65 lines of C++","url":"https://riki.house/fmt","score":6,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"riki","user_is_author":true,"tags":["c++","programming"],"short_id_url":"https://lobste.rs/s/0ktx6s","comments_url":"https://lobste.rs/s/0ktx6s/string_formatting_library_65_lines_c"},{"short_id":"pc87c0","created_at":"2025-08-22T14:30:58.000-05:00","title":"Why Was Apache Kafka Created?","url":"https://bigdatastream.substack.com/p/why-was-apache-kafka-created","score":11,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"topicpartition","user_is_author":true,"tags":["distributed"],"short_id_url":"https://lobste.rs/s/pc87c0","comments_url":"https://lobste.rs/s/pc87c0/why_was_apache_kafka_created"},{"short_id":"xltjpn","created_at":"2025-08-22T14:04:51.000-05:00","title":"nitro: a tiny but flexible init system and process supervisor","url":"https://git.vuxu.org/nitro/about/","score":15,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"sstephenson","user_is_author":false,"tags":["unix"],"short_id_url":"https://lobste.rs/s/xltjpn","comments_url":"https://lobste.rs/s/xltjpn/nitro_tiny_flexible_init_system_process"},{"short_id":"kl2nwa","created_at":"2025-08-22T13:51:57.000-05:00","title":"The First MoQ CDN: Cloudflare","url":"https://moq.dev/blog/first-cdn/","score":14,"flags":2,"comment_count":1,"description":"","description_plain":"","submitter_user":"kixelated","user_is_author":true,"tags":["javascript","networking","rust","web"],"short_id_url":"https://lobste.rs/s/kl2nwa","comments_url":"https://lobste.rs/s/kl2nwa/first_moq_cdn_cloudflare"},{"short_id":"lsxzfy","created_at":"2025-08-22T12:26:27.000-05:00","title":"Optimizing our way through Metroid","url":"https://antithesis.com/blog/2025/metroid/","score":11,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"hwayne","user_is_author":false,"tags":["games","testing"],"short_id_url":"https://lobste.rs/s/lsxzfy","comments_url":"https://lobste.rs/s/lsxzfy/optimizing_our_way_through_metroid"},{"short_id":"snhdea","created_at":"2025-08-22T12:16:03.000-05:00","title":"w65c832: W65C832 (32 bit 6502) in an FPGA","url":"https://github.com/mikeakohn/w65c832","score":8,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"lproven","user_is_author":false,"tags":["hardware","retrocomputing"],"short_id_url":"https://lobste.rs/s/snhdea","comments_url":"https://lobste.rs/s/snhdea/w65c832_w65c832_32_bit_6502_fpga"},{"short_id":"rmga0q","created_at":"2025-08-22T12:02:20.000-05:00","title":"bubbletea-rs: A rust implementation of Bubbletea","url":"https://github.com/whit3rabbit/bubbletea-rs","score":19,"flags":0,"comment_count":8,"description":"","description_plain":"","submitter_user":"jasonjmcghee","user_is_author":false,"tags":["rust"],"short_id_url":"https://lobste.rs/s/rmga0q","comments_url":"https://lobste.rs/s/rmga0q/bubbletea_rs_rust_implementation"},{"short_id":"u9v6jj","created_at":"2025-08-22T11:07:24.000-05:00","title":"Closing the Nix Gap: From Environments to Packaged Applications for Rust","url":"https://devenv.sh/blog/2025/08/22/closing-the-nix-gap-from-environments-to-packaged-applications-for-rust/","score":11,"flags":0,"comment_count":6,"description":"","description_plain":"","submitter_user":"jacekg","user_is_author":false,"tags":["devops","nix","rust"],"short_id_url":"https://lobste.rs/s/u9v6jj","comments_url":"https://lobste.rs/s/u9v6jj/closing_nix_gap_from_environments"},{"short_id":"othw2q","created_at":"2025-08-22T09:48:27.000-05:00","title":"Go is still not good","url":"https://blog.habets.se/2025/07/Go-is-still-not-good.html","score":54,"flags":1,"comment_count":22,"description":"","description_plain":"","submitter_user":"rrm","user_is_author":false,"tags":["go","rant"],"short_id_url":"https://lobste.rs/s/othw2q","comments_url":"https://lobste.rs/s/othw2q/go_is_still_not_good"},{"short_id":"cw265v","created_at":"2025-08-22T09:38:21.000-05:00","title":"Have smart glasses finally hit an inflection point?","url":"https://torment-nexus.mathewingram.com/have-smart-glasses-finally-hit-an-inflection-point/","score":7,"flags":2,"comment_count":6,"description":"","description_plain":"","submitter_user":"levlaz","user_is_author":false,"tags":["hardware"],"short_id_url":"https://lobste.rs/s/cw265v","comments_url":"https://lobste.rs/s/cw265v/have_smart_glasses_finally_hit"},{"short_id":"nhrlya","created_at":"2025-08-22T09:08:37.000-05:00","title":"To be a better programmer, write little proofs in your head","url":"https://the-nerve-blog.ghost.io/to-be-a-better-programmer-write-little-proofs-in-your-head/","score":18,"flags":0,"comment_count":7,"description":"","description_plain":"","submitter_user":"soni","user_is_author":false,"tags":["practices"],"short_id_url":"https://lobste.rs/s/nhrlya","comments_url":"https://lobste.rs/s/nhrlya/be_better_programmer_write_little_proofs"},{"short_id":"ntruuu","created_at":"2025-08-22T08:55:12.000-05:00","title":"Lobsters Interview with Matklad","url":"","score":85,"flags":0,"comment_count":17,"description":"\u003cp\u003eI am targeting a fortnightly cadence, going forward. \u003ca href=\"https://lobste.rs/~susam\" rel=\"ugc\"\u003e@susam\u003c/a\u003e and \u003ca href=\"https://lobste.rs/~zdsmith\" rel=\"ugc\"\u003e@zdsmith\u003c/a\u003e will be next. I spoke with \u003ca href=\"https://lobste.rs/~matklad\" rel=\"ugc\"\u003e@matklad\u003c/a\u003e for a few hours, resulting in this feast! Thank you to him and my proof readers!\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eHi Matt!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMy name is not in fact Matt.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOh.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBut I’m lax about my name. Anything unambiguous works! My name is too common where every 2nd guy has it!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat’s your computing environment like?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI worked at least half of my professional career on Rust tooling, so I care. But our tooling is so much worse than it could be that I don’t try to optimize it all that much. My journey went from Emacs to IntelliJ (working at JetBrains on \u003ca href=\"http://github.com/intellij-rust/intellij-rust\" rel=\"ugc\"\u003eIntellij-Rust\u003c/a\u003e), which at the time had unparalled capabilities to actually understand and edit your code as a statically typed language instead of just UTF-8 codepoints. It’s been a decade since that time when I was using IntelliJ, but I don’t think anyone is actually any closer to what IntelliJ was capable of doing a decade ago.\u003c/p\u003e\n\u003cp\u003eTo give a simple example, while experimenting with vibe coding, it wrote stupid code where if a condition doesn’t hold we do this, otherwise we do that. Of course, you could just flip the branches to remove negation. My time with IntelliJ gave me the reflex to place my cursor on the \u003ccode\u003eif\u003c/code\u003e and do a code action to flip it. But even such a basic feature doesn’t work for TypeScript. You don’t even have to understand the language’s semantics to a deep level; it’s purely a syntax transformation.\u003c/p\u003e\n\u003cp\u003eMany programmers dream of working on a farm or living in the woods, but when I retire, I’ll just be coding Java in Intellij all day, because that was good and nothing else is really there.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI did not see that coming, I love it! What do you think keeps our tooling from getting there?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe most important part’s history. What the world looks like today’s determined by how it looked a year ago. It’s all supercontigent. Nobody really tried to make this work outside of JetBrains. In 2005, Martin Fowler wrote \u003ca href=\"https://martinfowler.com/bliki/PostIntelliJ.html\" rel=\"ugc\"\u003ePost-Intellij\u003c/a\u003e and said they’d been talking about Smalltalk IDEs forever but finally had something next-level, which let you extract methods etc. The world forked at that point. People in the JetBrains ecosystem (IntelliJ and ReSharper) took it for granted, because it just worked. But no one else was doing it, because it’s a non-trivial problem. If you get IntelliJ-envy with C++, you’d think your compiler knows everything and ask it to parse and mark things but actually compilers are quite different. There were few successes outside of JetBrains, who weren’t interested in an open protocol until Microsoft came out with LSP. This was obvious, but no one’d cared yet. It wasn’t common for a language to have good tooling yet.\u003c/p\u003e\n\u003cp\u003eBut we’re still behind the quality JetBrains was doing, because the last 20% requires a lot of effort and thoughtful language design. Now, tooling-friendliness was accidental with Java because it’s simple. But Go was explicitly designed to be tooling-friendly and has some of the best IDE support. But Rust has many features which make it hard to implement an IDE. A lof of effort goes into fighting the language semantics instead of implementing features. Earlier, before we expected great tooling by default, ecosystems couldn’t coordinate the concentrated effort necessary. With LSP and higher expectations, I expect everything to be good in a decade, but maybe we’ll abandon that static-type driven approach for LLMs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat about editors for languages without types?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJS with TypeScript, Python, Ruby etc. now have types. If you have a language without ypes, maybe you should think about retrofitting them in. Add them for good tooling support the way TypeScript did instead of Python’s vague Platonic reasons. But at the same time, I’m very curious about this different branch of IDEs around image-based programming. I wish a huge fan of Smalltalk or Lisp Machines would write a blog post destroying IntelliJ, explaining how they were doing those things in the 80s! I’m not qualified to talk, but I think you could actually solve problems relying on language dynamics. Smalltalk had this \u003ca href=\"https://wiki.c2.com/?RefactoringBrowser\" rel=\"ugc\"\u003eRefactoring Browser\u003c/a\u003e. If you want to rename a method, you need to update all call sites, which they did at runtime. So you didn’t rename the method but said \u003cem\u003ewhen you call this method, actually call me and make a list\u003c/em\u003e. So if you run your test suite, it discovers all the call sites dynamically which you update in the image. Obviously it works, but I’m skeptical about scale. It reminds me of REPL debates too. Lispers love their REPLs but it always felt like worse tests to me. Do you manually redo all those checks in the REPL again? REPL seems good for exploring, but not ensuring things remain correct. But why write tests to check if your variables’ names are correct when you could have a static type system? I believe doing it statically is strictly better (especially as the code base grows), but I’m not a zealot.\u003c/p\u003e\n\u003cp\u003eI find that talking about programming languages is misguided because languages do not really matter. What really matters is the runtime, and dynamic languages usually have pretty impressive runtimes. For example, you could have dynamic code loading: reading programs from disk into a running program and making them part of the running image. That capability is key in plugin-heavy systems like code editors and shells. Languages with static semantics and runtimes struggle here. But you’ll want static types eventually which isn’t always easy. That’s why Java’s brilliant. Java has a very dynamic runtime but a boring and standard static type system!\u003c/p\u003e\n\u003cp\u003eThen there’re questions of iteration speed and compilation time. There’s a platonic ideal of a statically typed, static language which compiles fast, but Rust is horribly slow to compile. Zig is slow too, because you still use LLVM. They’re working on it, but I’m on ARM…\u003c/p\u003e\n\u003cp\u003eIf we were redoing our entire computing infrastructure from zero, would I have space for dynamically typed languages? Maybe something gradually TypeScript where you generally have static types but could match the shape of data and dynamically walk the code. Writing a compiler in Zig, you’d have a ton of code generation using \u003ca href=\"https://zig.guide/language-basics/comptime/\" rel=\"ugc\"\u003ecomptime\u003c/a\u003e, but in TypeScript you can specify this is a multiplication expression or a file, they’re typed. Then there’s one function with objects and keys which maps or iterates through everything conveniently. So, even in this hypothetical Matklad computing universe, I’d still want some dynamicism for cross application scripting with \u003ca href=\"https://janet-lang.org\" rel=\"ugc\"\u003eJanet\u003c/a\u003e or Lua, so that users can include their own code in your program, e.g. mods for a game. But I would only allow one gradually typed language.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI love Janet!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn that hypothetical world where Matklad has infinite time, I definitely want to write a modern take on Emacs using Janet as the core language.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHave you seen \u003ca href=\"https://lem-project.github.io/\" rel=\"ugc\"\u003eLem\u003c/a\u003e?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI looked at it briefly but bounced because it clamors you with Common Lisp. There’s this war between Scheme and Common Lisp, but then there’s Janet which doesn’t care and doesn’t bother with hygienic macros. It’s just arrays and tables, not even cons cells, which feels like a strict improvement to me. I’m not a fan of syntactic metaprogramming. Lispers also valorize the languages to an excessive degree. Like, every language is Turing-complete and has capabilities for abstraction, it doesn’t really matter what language you use. It’s just a tool. Janet’s more pragmatic in this sense. So knowing nothing about Scheme or Common Lisp, I feel like Janet would be an all around better tool for writing a new Emacs.\u003c/p\u003e\n\u003cp\u003eI’m not a fan of extending languages syntactically because it feels like it makes systems harder to understand. It allows for some expressivity but it’s bounded. Zig’s comptime doesn’t operate on syntax but types, which is more natural and powerful. The synctactic approach creates beautiful but inscrutable \u003ca href=\"https://willcrichton.net/notes/systems-programming/\" rel=\"ugc\"\u003esystems\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eSo for my ideal Emacs, I want like JavaScript with TypeScript syntax and semantics with UTF-8 strings. A reasonably fast and small implementation would be cool too, which is where Janet comes in again. I don’t think they do JIT compilation right now, but I’ve heard they’re working on it.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eInteresting, I love making DSLs. What don’t you like about that approach?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI think Lisp falls into the same kind of trap as OOP. The big idea is that you have late binding, this very dynamic, extensible, flexible system. The problem’s that it helps 10% of your system, but 90% of your code shouldn’t be extensible. This is the solution to the \u003ca href=\"https://en.wikipedia.org/wiki/Expression_problem\" rel=\"ugc\"\u003eexpression problem\u003c/a\u003e. Do you want to extend a data type in terms of variance or methods? Neither! 90% of the code should be concrete types like hash maps. You don’t want the user to extend your hash maps. The problem with OOP is that it puts this extensibility front and center, so all systems become extensible in ways they shouldn’t. Extensibility is a big constraint on how you can evolve your system and is a tax on understanding things.\u003c/p\u003e\n\u003cp\u003eLisps excel at building new programming languages, because they solved parsing. They give you a balanced parenthesis sequence which you can trivially parse and transform. So if you’re working with languages, it’s the perfect tool. That’s what got me interested in Janet. At TigerBeetle, we support clients for 5-6 languages and I want to build an in-process model of TigerBeetle in the host language. So if you’re writing in Python and want to run tests, you don’t have to be in the TigerBeetle binary nor embed it, you’d just have a Python module which re-implements the same logic in Python. So I’m thinking of implementing the TigerBeetle state machine in an abstract language and then compile it down to Python, JavaScript, Java etc. Lisp is perfect for this. You start your abstract language with an intermediate syntax tree (IST) implemented as s-expressions, then lower it into syntax trees for Python, Ruby, whatever but also implemented as s-expressions. Then there’s a simple function which takes this Python IST and produces a string.\u003c/p\u003e\n\u003cp\u003eLisps are really good at manipulating trees, but you don’t want to make every problem in your codebase a problem of defining your language. There’s a limited amount of languages you can keep in your head and you only want to go that far if the payoff is really great. With OOP, if you’re building an extensible code editor like VSCode, making the interface into an object-oriented program is a good idea, it’s exactly where you want this open-world extensibility and the vocabulary of OOP really fits. But you don’t want that through your entire codebase. It’s the same with custom languages. Sometimes you can benefit from a DSL, but don’t try to turn every program into one!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCould you go more into solving the expression problem?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYou can extend a data structure in terms of data variance or operations. OOP lets you add more kinds of data to the same interface, sum types let you cheaply add more operations. But most of the time you want neither, your code should be absolutely closed. Rust’s hash map is not extensible, there’s no hash map trait because no one needs it. There’s also no reason to add a custom hash map operation. This is a pattern of general cognitive biases in programming; we think hard about expressivity, allowing stuff. But extensibility always has costs and good systems design is when you can limit extensibility. Good systems are extensible, but through a specific, narrow crisp interfaces.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you approach modeling a problem or domain?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe top level question’s whether I am modeling a program domain or what my CPU is actually going to do? These are two very different vantage points to approach programming from. On one hand, we have mathematical modeling, where you describe your problem as a mathematical object with some operations and how it is transformed over time. Your goal there, as a programmer, is to capture fuzzy intuition about the world into rigid, executable mathematical specifications. The other vantage point is what the CPU is doing, getting the most of your CPU cores and making every instruction count. You have to think in terms of bytes, CPU cycles, latency numbers etc.\u003c/p\u003e\n\u003cp\u003eSo first, determine what regime you’re functioning in; because if you don’t have performance constraints, you should be thinking about modeling the problem for a human to understand. If you care about performance, you should think about what’s efficient to execute and change your problem to map cleanly to hardware. The purpose of computers ultimately is making things fast and you totally should change your problem, what your program is doing, to make it. If modeling things, I’ll try to identify some core abstraction, some invariance etc. But there’s always interplay. Rust, in particular, is pretty great and lets you do both at the same time, to some extent.\u003c/p\u003e\n\u003cp\u003eSecond, think about the program and its evolution over time. Coding is easy. You can just write a program (or even ask a GPU to write it for you) and it’s there. Evolving it over time is hard. Can you change it? Are you promising any public interfaces? If I can change it tomorrow, I don’t care what I write today because I can always improve it. You could draw on paper what the nouns, verbs, data and fundamental data transformations are, figure out how it’ll evolve. But I don’t honestly do much upfront modeling. Normally, there’s just something obvious to do next, so I’m always doing that.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you approach writing a blog post?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIf I have a good title, I’ll just write it all up then and there! If I can’t find a good title, it just sits in the drafts forever until I forget about it. If it doesn’t get done in one sitting, it won’t get finished. So I’ll sometimes stay up all night doing it, while still in the \u003ca href=\"https://en.wikipedia.org/wiki/Flow_(psychology)\" rel=\"ugc\"\u003eflow\u003c/a\u003e. This is why I write blog posts, not books: I can finish them before I die of starvation!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do talks go? You can’t just wing it based on the title, because you have slides prepared!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe night before the talk! Talks are harder because they’re announced, while if I never publish a blog post I was working on, \u003cem\u003eno one knows\u003c/em\u003e. But it’s too easy to commit to talks 6 months out, because only the future Matklad will have to deal with the consequences of my decisions today. Even if he’ll hate me now, he’s committed and has to push himself! But yeah, I’m not super keen on the talks; I like reading stuff. It’s quicker and gets into my brain better. The purpose of conferences aren’t really talks, but bringing like minded people to the same room for networking, collaborating, solving a coordination problem. But most talks would be better as a blog post.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow did you end up in programming?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAt school, I didn’t program at all and only did mathematics, but I wanted to do something more tangible. However, in Russia, a software engineering degree is physics, analysis, differential equations, topology etc. so I do have a mathematically inclined brain. I tried a MA to see if I’d like theoretical computer science, but several months in, I realized proving theorems about Turing machines is fun, but what keeps me up at night was hacking on a little visualization of that Turing machine in JavaScript. The tangible part brought me to programming instead of proving theorems.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDo you write much JS these days?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI have VS Code extensions where I use it and routinely use the web stack for visualizations, GUIs etc. but like 2005-style. But I know flexbox, that’s super important! Before that, layouts were a complete nightmare!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you learn something new?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI always try to learn the underlying idea, not the actual thing. I try to just type the API, expecting stuff to be there. If it’s not, either the library is missing a feature or I need to fix my mental model. All knowledge is super compressible, so once you understand the general idea, you should be able to derive the rest and not need to learn every detail.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou mentioned that Rust is very good at both modeling for humans and the machine, how would you put compare Zig and others?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eZig is strictly a machine level language. An example for the last question, how do you learn Zig? You learn that it’s a DSL for producing machine code. Once you understand that, you’ll know why it has inline for. Because inline for is a way to specify a DSL that you want to have a similar but different fragment of assembly to be repeated.\u003c/p\u003e\n\u003cp\u003eI’d describe Rust as better than everything else. It’s not \u003cem\u003egreat\u003c/em\u003e, there’s a lot of stuff that could be better. Zig’s pretty close to optimal for its goal of producing machine code. There’s little fat to the language.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI’d love for you to explain the domain models of literally every technology possible, but that’s too much to ask. So, how do computers work? I mean, I read some books, did nand2tetris etc. so I know how they worked 40 years ago, but now that IST is emulating old machines, there’s magic everywhere… How do you know what’s going on, that Zig can be a DSL to? It seems inscrutable!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThat’s a good question. To be honest, I also have a vague understanding about what my CPU is actually doing. We’re programming against x86 or Arm64 instruction sets, which are just abstractions. In my computer, there’s a smaller computer transforming my x86 program into an actual program for the hardware. It’s layers all the way down. Useful to keep in mind, Andrew Kelly’s definition of what systems programming is: Programming against the underlying platform APIs. So, programming for the browser, you can program in C because it’s the systems programming language, compile it into WASM and run WASM in the browser, but are you doing systems programming because it’s C? No! You can’t do browser systems programming in WASM, because systems APIs aren’t exposed to WASM today. Systems programming in the browser is necessarily in JavaScript, because that is the underlying system API, the final level without indirection you can code against.\u003c/p\u003e\n\u003cp\u003eSo we can’t say what happens in a CPU, by design, because it gives designers flexibility to change things. As I was saying before, the most important thing about a system isn’t how you model a domain, but how you upgrade it! It’s remarkable how Apple could transition from Power to x86 to Arm, because they thought it through. When you code in Zig, you can’t know what happens underneath your assembly, beneath machine code, but you have tight control of the machine code while being target-independent, without inline assembly. There’s a fundamental abstraction required to make target-independence possible. It doesn’t prioritize particular patterns. For example, there are at least 2 ways to do dynamic dispatch. C++‘s style has an object start with an object header with a pointer to the vtable. Rust’s obviously superior way uses wide pointers with a pointer to the data and a pointer to the vtable, so you can flexibly combine arbitrary data and vtables, which Go and Swift also do. C++ and Rust hardcode these approaches. Zig provides you with nothing, so you have to write your own abstraction. You could do polymorphism through \u003ca href=\"https://www.ryanliptak.com/blog/zig-fieldparentptr-for-dumbos/\" rel=\"ugc\"\u003eFieldParentPtr\u003c/a\u003e, it doesn’t matter! But it’s the curse of choice, it’s on you as a programmer to build your primitive abstractions, which isn’t what you want to do if you’re programming in the mathematical domain modeling approach to software engineering. It’s important that Zig’s a language, not just portable micro assembly, because Zig enables you to abstract over those patterns or machine code. This is the difference of metaprogramming between Lisp and Zig: In Lisp you abstract source code, the text of your program, because a macro expands to the source code. In Zig, you want to abstract over and expand to machine code, thinking about copy-pasted fragments of assembly, not fragments of source code.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCircling back to Matklad’s user space redux…\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAlso kernel space! The user space is the easy part. A historical issue defining our computer landscape is that modern kernels try really hard to provide the illusion of a blocking API. You write a file, which takes time then you continue when it’s done. This is smoke and mirrors, this isn’t how hardware works at all! It’s always fire and forget: Write this, here’s a region of memory, wake me up when it’s over. It’s fundamentally asynchronous. The OS provides these thread and process abstractions which make you think the API’s blocking. The horrible side effect’s that language designers get an out of jail card for async programming, they don’t have to think about it! When writing to a file, they don’t need to make sure the bytes aren’t moved during the operation while running something. No, you just bind to the POSIX API and enjoy this blocking world illusion.\u003c/p\u003e\n\u003cp\u003eBut historically, hyperscalers then found the blocking APIs kind of slow, so languages retrofitted async without planning for it, with mediocre results. We don’t know how to write asynchronous code, because we allow language designers to design languages which just rely on the OS for that part of the runtime. Coroutines are implemented in the kernel, but should be in languages, so I’d start with the kernel!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eA friend wanted to know what you think of Zig’s async vs. Rust’s.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe biggest difference is that Rust async actually exists so you can use it, but Zig’s async doesn’t really exist yet. But it’s absolutely brilliant that Zig makes a sharp distinction between API used to express concurrency and asynchrony and the implementation. Zig says this is the API, how you model async flows, but the actual runtime might be synchronous or multi-threaded. This is good, because there are a lot of questions about how to implement asynchrony, again because we all rely on one suboptimal implementation in the kernel. Then we have a second implementation in the user space and they fight with each other.\u003c/p\u003e\n\u003cp\u003eBut another can of worms is how you actually express that something’s concurrency. We don’t have any answers yet. I am slightly hesitant that Zig goes for a library based approach where creating an asynchronous flow of execution, a future, a coroutine is like a library call, I feel this has to be built into the language. I believe asynchrony is a universal construct like a \u003ccode\u003efor\u003c/code\u003e loop. You don’t \u003cem\u003ehave\u003c/em\u003e to write a language with a \u003ccode\u003efor\u003c/code\u003e loop, you could use \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003ewhile\u003c/code\u003e but we figured out \u003ccode\u003efor\u003c/code\u003e is a pretty universal construct, which wasn’t obvious before. Dijkstra wrote his diatribe about how we should do structured programming with this theory which proves how \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003efor\u003c/code\u003e are enough to code everything without \u003ccode\u003egoto\u003c/code\u003e. It took some time to realize we didn’t have to use assembly but could write in high-level languages like C! With concurrency, I feel we’re still in this \u003ccode\u003egoto\u003c/code\u003e phase. We try to solve it with library design, futures, promises, channels, nurseries, bundles… I think we need a few keywords like semicolon, where what’s before and after can go fully parallel or something. But I’m not a language designer. My observation’s that we don’t force language designers to answer this question, which is a shame.\u003c/p\u003e\n\u003cp\u003eSo I’m really happy Zig distinguishes between implementation and interface, but sad the implementation is just a library, because it’s a local optimum. I think it makes sense to come up with 5 keywords to describe it like control flow, to describe everything, but don’t ask me what those 5 keywords are.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat are those 5 keywords?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFundamentally, you want to describe a tree shaped stack. A stack which branches. You need keywords to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ebranch in 2\u003c/li\u003e\n\u003cli\u003ebranch to n\u003c/li\u003e\n\u003cli\u003eallow a runtime this many branches in this tree (an \u003ca href=\"https://rust-exercises.ferrous-systems.com/latest/book/async-chat/accept_loop\" rel=\"ugc\"\u003eaccept loop\u003c/a\u003e says while accept pass this coroutine for this particular client. If you just do static concurrency, you couldn’t write those things)\u003c/li\u003e\n\u003cli\u003esynchronization (\u003ccode\u003elet a = async work; let b = async work; join a and b;\u003c/code\u003e but not a promise\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI don’t think you should expose promise as a construct. We don’t have a promise for an uninitialized variable like \u003ccode\u003evar x = promise; x resolve foo;\u003c/code\u003e to access x. We just specify stuff such that we can only access a variable once computed. I think we could do the same for concurrency, scheduling things but only using them when guaranteed to be joined. But I’m not a language designer.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat is an OS to you? \u003ca href=\"https://archive.org/details/plan9designintro\" rel=\"ugc\"\u003eIntroduction to Operating System Abstractions using Plan 9\u003c/a\u003e taught me it’s the whole interface to use your machine, including languages. My dream OS would even handle garbage collection and the database. You have a different model.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWe don’t know the answers. I don’t necessarily think we know what an operating system is. Maybe tomorrow someone writes a Lisp machine which is actually good and we spend the next 50 years gluing legacy code into it. Or a glorious world where language-level abstractions correspond to hardware where you can’t break out of your abstractions. It breaks down to the question: What is a computer? We have 2 answers. Mechanically, a computer is linear memory which is executable, a Von Neumann architecture letting you do anything you want. But we can also say it’s a graph of objects which have a specific interface, you can write, compose and send messages. We might be going there, that’s what WASM with interface types is. There’s still linear memory as pokeable bytes, but it’s really a graph of individual objects with isolated heaps. I don’t know whether it’ll be successful or not, but it could be our entire future infrastructure. My gut feeling says we should expose the lowest level hardware denominator, but it’s not really true. Virtual memory is like a poorly done capability system. I’m excited about \u003ca href=\"https://en.wikipedia.org/wiki/Capability_Hardware_Enhanced_RISC_Instructions\" rel=\"ugc\"\u003eCHERI\u003c/a\u003e. I want to channel \u003ca href=\"https://lobste.rs/~carlana\" rel=\"ugc\"\u003e@carlana\u003c/a\u003e that CHERI is not a replacement for Rust (by compiling C++ to CHERI for memory safety), CHERI is a replacement for virtual memory. Instead of slicing your address space into process granularity and suffering like TLB flushes and what not, when you switch processes you could do a faster and simpler system slicing memory into individual objects and passing capabilities to those slices. This doesn’t feel higher-level than what we have today, because it’s just more general virtual memory.\u003c/p\u003e\n\u003cp\u003eThe key idea of a computer might be the interface, what you can program against, where there’s a kernel on the other side, which can change without breaking the interface. I have no idea how it should look, what belongs above and below the kernel etc. I don’t think current systems are the best, but we’re just locked in because of history.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://harelang.org/blog/2023-11-08-100-year-language/\" rel=\"ugc\"\u003eHare wants to be a hundred-year language\u003c/a\u003e, do you think Zig has what it takes?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI don’t believe in the concept of a 100-year language. We will have to change languages in the future. We aren’t even done with Moore’s law. It seems premature to commit to absolute stability. We should be open to change. Perhaps balance and build infrastructure for 20 years and think out how we’ll decommission and replace it with something better. This is why toolability’s such a crucial thing for a language. C++ gets it right. It’s a horribly complicated language, impossible to process automatedly, so it’s impossible to replace. When people invent a better Go, they’ll automatically translate it, it’s designed for it. But C++ will always be there because of some macro with undefined behavior. The smart thing is probably what Rust does, stability without stagnation. I’m glad Hare does have this \u003ca href=\"https://harelang.org/blog/2025-06-11-hare-update/\" rel=\"ugc\"\u003eautomated transformation\u003c/a\u003e for the currently unstable language, though I think it’s more useful when it is stable and you want to upgrade it.\u003c/p\u003e\n\u003cp\u003eFor Zig, I don’t care. I use Zig for one particular purpose, writing TigerBeetle. The key’s that we don’t have dependencies, so upgrading is easy. Normally, upgrading the language is hard because dependencies start using the same version, but gradually want different versions and you have to decide which baby to throw out of the window. I think Zig had the ambition to release 1.0 in 3 years. But that might be Zig’s advantage. We already have a good enough systems programming language: Rust. Zig doesn’t have to chase stability, it could redo async await 5 times until it really gets it right.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWho chose Zig at TigerBeetle?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJoran, our founder, I think. He could have chosen C, Zig, Rust and it would have been fine. I wouldn’t have made it, because I was too enamored with Rust. Previously, Joran was working on Node.js with gigabytes of dependencies and the absolute advantage of Zig at the time was missing a package manager. Unfortunately for TigerBeetle, Zig now has a package manager but our strong culture lets us ignore this and fight the temptation of dependencies.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou said you were enamored in Rust, you fell out of love?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIt’s a brilliant industrial language, already in Windows and Linux! That’s mindbogglingly unbelievable. In 2016 I would have said it’s only successful if it’d enter the kernels but didn’t think it’d happen this fast. But Rust isn’t as focused on low-level programming; it bridges high and low levels. So I wouldn’t have expected HTTP web services and RPC and still don’t think it’s the best possible language for these things. It’s still the best language out of what we have today.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYour blog has a bit about mentorship etc. How did \u003cem\u003eyou\u003c/em\u003e actually learn?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLearning is funny. When finishing university, I thought I’d be a professional programmer! A junior developer with a mentor who could explain how to write production-ready code. For the first 8 years of my career, I searched for that mentor and realized I wouldn’t find them. Mentorship is a bright idea but didn’t work for me. I had to figure everything out from first principles, from books, trying things out. You can just learn programming, it’s not rocket science. I’ve written a lot about what I learned on my blog, which is just learning and thinking from first principles. A lot of it is just “I was thinking of x and tried it out.” People often ask me to mentor them, but it’s not scalable for me.\u003c/p\u003e\n\u003cp\u003eI just try to explain: If you want to be a writer, you write. If you want to be a potter, you make pots. But actively reflect on your code, \u003ca href=\"https://alexalejandre.com/programming/deliberate-practice-for-developers/\" rel=\"ugc\"\u003edeliberate practice\u003c/a\u003e although I don’t like the concept. Solve a problem, feel pain, understand why you’re feeling pain and form a hypotheses for how to avoid pain next time. It’s important to solve toy problems. This really surprised me, because I loved building toys as a young programmer. I’d code a red black tree with Java AWT, compilers or a database. I didn’t think they had any relationship to real things, but when I started working, real projects are the same as toys, just bigger and sometimes worse! Because you can throw away and improve a toy, but you can’t always fix architectural mistakes in production systems. Trust your own reflective brain, not mentors!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat’s on your mind lately?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLLMs. They’re not ground breaking for me yet, but if the trajectory continues everything will be so different in 10 years. My own personal strategy is that I check every 6 months whether I can automate myself away yet. Otherwise, I ignore the whole field because it’s not my own comparative advantage.\u003c/p\u003e\n\u003cp\u003eTerminals suck. Interfaces are important, but terminal interfaces are really bad. Yesterday, I learned a soul-breaking fact. \u003ccode\u003estderr\u003c/code\u003e is human readable and \u003ccode\u003estdout\u003c/code\u003e is structured output, a beautiful system, but if you actually use a terminal, a PTY device, they aren’t actually distinct. The two streams are erased going into the same terminal! We have this beautiful system, but then we put io coreutils on top to turn our file descriptor into adhoc device and adhoc controls. Let’s say I want to display color output from Zig build. Just capturing the output won’t give me colors, which makes sense. So I may not like them, but I can use ANSI escapes for colors and do my job and properly parse and render them like HTML. But you can’t do that without the kernel, asking it to make a pseudo terminal, giving Zig build’s process half and me the other, which is horrible! The power of an interface is having multiple implementations which behave the same, which terminals violate. Escape sequences are the same, I just want colors! (Though there is a \u003ccode\u003eCLICOLOR_FORCE\u003c/code\u003e environmental variable, but it’s pretty horrible.) Out of band signaling and literal signaling like \u003ccode\u003eSIGWINCH\u003c/code\u003e is horrible. Also, I’m a human!\u003c/p\u003e\n\u003cp\u003eI use computers as a human and a stream of bytes as an interface isn’t convenient. I want to love text, but text for me is a grid of characters I can move my cursor around. So I want the concept of an Emacs buffer, elevated from a special thing in 1 editor to a coprimitive of the OS or an IPC thing. I dream of an API letting you implement \u003ca href=\"https://github.com/magit/magit\" rel=\"ugc\"\u003eMagit\u003c/a\u003e as a separate binary which talks to arbitrary clients. Such a rich and structured interface would offer great power, while remaining 100% text. But such things take a lot of time and effort. I’m not angry enough to dedicate 5 years of my life to shaving this particular yak, so I begrudgingly use \u003ca href=\"https://github.com/ghostty-org/ghostty\" rel=\"ugc\"\u003eGhostty\u003c/a\u003e terminal, though terminals should die. There’s a path dependency, they are good enough, so people grow to like them.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIf guys were to start from scratch on TigerBeetle, would it be different or worth doing?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI don’t think so. We are very happy with what we have built. We might tweak our domain model slightly. We have concept of pending transfer, a created but not finalized transfer which might be better modeled as a transfer scheduled in the future. Instead of saying this transfer gets voided in 2 days, you’d submit the original transfer and one scheduled in the future. But because of our stable interface we solve such problems differently. It’s not worth rewriting for that.\u003c/p\u003e\n\u003cp\u003eAutomatic minimization for our simulator would be good. Right now, our simulator doesn’t do minimization. It finds the bug which is 10 GB of logs or it could be a shorter issue, but maybe not. That’s no attempt to smartly minimize this. I think it would be easy to retrofit minimization and if starting from scratch, I would. Full disclosure: I wanted to learn to build such systems but hadn’t worked on big distributed systems so I starting hacking on a toy. I thought a banking application doing transfers was a good distributed system which needs consensus, which is hard to test! So I needed proper randomized testing with minimization, which is easy with Rust’s \u003ca href=\"https://docs.rs/arbitrary/latest/arbitrary/\" rel=\"ugc\"\u003earbitrary\u003c/a\u003e crate. That’s how \u003ca href=\"https://github.com/matklad/arbtest\" rel=\"ugc\"\u003earbtest\u003c/a\u003e was born. Then I found out about TigerBeetle and got on a call to show our simulators to each other. We were working on the same thing! But my toy simulator had working minimization while TigerBeetle doesn’t! In TigerBeetle today, we don’t have bugs so we don’t need a bug minimizer. But of course it took a while to get here. I spent a lot of time debugging with 20 GB log files and needed a minimizer because grepping 20 GB was realy inefficient. But actually, I’d already written a minimizer but not a grep. So I ended up writing my own grep replacement \u003ca href=\"https://github.com/matklad/window\" rel=\"ugc\"\u003ewindow\u003c/a\u003e  and used that to fix the bugs.\u003c/p\u003e\n\u003cp\u003eBut overall, TigerBeetle is a perfect piece of software.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIs anything else perfect?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSQLite!\u003c/p\u003e\n\u003cp\u003eAs far as programming languages go, Zig. It strikes its intended target as close as possible. Rust is great, better than C++ and Java but there’s \u003ccode\u003e.\u003c/code\u003e for method access or \u003ccode\u003e::\u003c/code\u003e for namespaces which aren’t great. There are 5 comment syntaxes… There’s a lot of accidental complexity in Rust while Zig’s really tight. If you removed a single primitive from the language, it’d fall apart.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://fishshell.com/\" rel=\"ugc\"\u003efish\u003c/a\u003e shell has a perfect interface and was a major influence in how I think about building tooling without needing any configuration. I’ve been using it since ~2014, before I started doing Rust.\u003c/p\u003e\n","description_plain":"I am targeting a fortnightly cadence, going forward. @susam and @zdsmith will be next. I spoke with @matklad for a few hours, resulting in this feast! Thank you to him and my proof readers!\r\n\r\n----\r\n\r\n**Hi Matt!**\r\n\r\nMy name is not in fact Matt.\r\n\r\n**Oh.**\r\n\r\nBut I'm lax about my name. Anything unambiguous works! My name is too common where every 2nd guy has it!\r\n\r\n**What's your computing environment like?**\r\n\r\nI worked at least half of my professional career on Rust tooling, so I care. But our tooling is so much worse than it could be that I don't try to optimize it all that much. My journey went from Emacs to IntelliJ (working at JetBrains on [Intellij-Rust](http://github.com/intellij-rust/intellij-rust)), which at the time had unparalled capabilities to actually understand and edit your code as a statically typed language instead of just UTF-8 codepoints. It's been a decade since that time when I was using IntelliJ, but I don't think anyone is actually any closer to what IntelliJ was capable of doing a decade ago.\r\n\r\nTo give a simple example, while experimenting with vibe coding, it wrote stupid code where if a condition doesn't hold we do this, otherwise we do that. Of course, you could just flip the branches to remove negation. My time with IntelliJ gave me the reflex to place my cursor on the `if` and do a code action to flip it. But even such a basic feature doesn't work for TypeScript. You don't even have to understand the language's semantics to a deep level; it's purely a syntax transformation.\r\n\r\nMany programmers dream of working on a farm or living in the woods, but when I retire, I'll just be coding Java in Intellij all day, because that was good and nothing else is really there.\r\n\r\n**I did not see that coming, I love it! What do you think keeps our tooling from getting there?**\r\n\r\nThe most important part's history. What the world looks like today's determined by how it looked a year ago. It's all supercontigent. Nobody really tried to make this work outside of JetBrains. In 2005, Martin Fowler wrote [Post-Intellij](https://martinfowler.com/bliki/PostIntelliJ.html) and said they'd been talking about Smalltalk IDEs forever but finally had something next-level, which let you extract methods etc. The world forked at that point. People in the JetBrains ecosystem (IntelliJ and ReSharper) took it for granted, because it just worked. But no one else was doing it, because it's a non-trivial problem. If you get IntelliJ-envy with C++, you'd think your compiler knows everything and ask it to parse and mark things but actually compilers are quite different. There were few successes outside of JetBrains, who weren't interested in an open protocol until Microsoft came out with LSP. This was obvious, but no one'd cared yet. It wasn't common for a language to have good tooling yet.\r\n\r\nBut we're still behind the quality JetBrains was doing, because the last 20% requires a lot of effort and thoughtful language design. Now, tooling-friendliness was accidental with Java because it's simple. But Go was explicitly designed to be tooling-friendly and has some of the best IDE support. But Rust has many features which make it hard to implement an IDE. A lof of effort goes into fighting the language semantics instead of implementing features. Earlier, before we expected great tooling by default, ecosystems couldn't coordinate the concentrated effort necessary. With LSP and higher expectations, I expect everything to be good in a decade, but maybe we'll abandon that static-type driven approach for LLMs.\r\n\r\n\r\n**What about editors for languages without types?**\r\n\r\nJS with TypeScript, Python, Ruby etc. now have types. If you have a language without ypes, maybe you should think about retrofitting them in. Add them for good tooling support the way TypeScript did instead of Python's vague Platonic reasons. But at the same time, I'm very curious about this different branch of IDEs around image-based programming. I wish a huge fan of Smalltalk or Lisp Machines would write a blog post destroying IntelliJ, explaining how they were doing those things in the 80s! I'm not qualified to talk, but I think you could actually solve problems relying on language dynamics. Smalltalk had this [Refactoring Browser](https://wiki.c2.com/?RefactoringBrowser). If you want to rename a method, you need to update all call sites, which they did at runtime. So you didn't rename the method but said _when you call this method, actually call me and make a list_. So if you run your test suite, it discovers all the call sites dynamically which you update in the image. Obviously it works, but I'm skeptical about scale. It reminds me of REPL debates too. Lispers love their REPLs but it always felt like worse tests to me. Do you manually redo all those checks in the REPL again? REPL seems good for exploring, but not ensuring things remain correct. But why write tests to check if your variables' names are correct when you could have a static type system? I believe doing it statically is strictly better (especially as the code base grows), but I'm not a zealot.\r\n\r\nI find that talking about programming languages is misguided because languages do not really matter. What really matters is the runtime, and dynamic languages usually have pretty impressive runtimes. For example, you could have dynamic code loading: reading programs from disk into a running program and making them part of the running image. That capability is key in plugin-heavy systems like code editors and shells. Languages with static semantics and runtimes struggle here. But you'll want static types eventually which isn't always easy. That's why Java's brilliant. Java has a very dynamic runtime but a boring and standard static type system!\r\n\r\nThen there're questions of iteration speed and compilation time. There's a platonic ideal of a statically typed, static language which compiles fast, but Rust is horribly slow to compile. Zig is slow too, because you still use LLVM. They're working on it, but I'm on ARM...\r\n\r\nIf we were redoing our entire computing infrastructure from zero, would I have space for dynamically typed languages? Maybe something gradually TypeScript where you generally have static types but could match the shape of data and dynamically walk the code. Writing a compiler in Zig, you'd have a ton of code generation using [comptime](https://zig.guide/language-basics/comptime/), but in TypeScript you can specify this is a multiplication expression or a file, they're typed. Then there's one function with objects and keys which maps or iterates through everything conveniently. So, even in this hypothetical Matklad computing universe, I'd still want some dynamicism for cross application scripting with [Janet](https://janet-lang.org) or Lua, so that users can include their own code in your program, e.g. mods for a game. But I would only allow one gradually typed language.\r\n\r\n**I love Janet!**\r\n\r\nIn that hypothetical world where Matklad has infinite time, I definitely want to write a modern take on Emacs using Janet as the core language.\r\n\r\n**Have you seen [Lem](https://lem-project.github.io/)?**\r\n\r\nI looked at it briefly but bounced because it clamors you with Common Lisp. There's this war between Scheme and Common Lisp, but then there's Janet which doesn't care and doesn't bother with hygienic macros. It's just arrays and tables, not even cons cells, which feels like a strict improvement to me. I'm not a fan of syntactic metaprogramming. Lispers also valorize the languages to an excessive degree. Like, every language is Turing-complete and has capabilities for abstraction, it doesn't really matter what language you use. It's just a tool. Janet's more pragmatic in this sense. So knowing nothing about Scheme or Common Lisp, I feel like Janet would be an all around better tool for writing a new Emacs.\r\n\r\nI'm not a fan of extending languages syntactically because it feels like it makes systems harder to understand. It allows for some expressivity but it's bounded. Zig's comptime doesn't operate on syntax but types, which is more natural and powerful. The synctactic approach creates beautiful but inscrutable [systems](https://willcrichton.net/notes/systems-programming/).\r\n\r\nSo for my ideal Emacs, I want like JavaScript with TypeScript syntax and semantics with UTF-8 strings. A reasonably fast and small implementation would be cool too, which is where Janet comes in again. I don't think they do JIT compilation right now, but I've heard they're working on it.\r\n\r\n**Interesting, I love making DSLs. What don't you like about that approach?**\r\n\r\nI think Lisp falls into the same kind of trap as OOP. The big idea is that you have late binding, this very dynamic, extensible, flexible system. The problem's that it helps 10% of your system, but 90% of your code shouldn't be extensible. This is the solution to the [expression problem](https://en.wikipedia.org/wiki/Expression_problem). Do you want to extend a data type in terms of variance or methods? Neither! 90% of the code should be concrete types like hash maps. You don't want the user to extend your hash maps. The problem with OOP is that it puts this extensibility front and center, so all systems become extensible in ways they shouldn't. Extensibility is a big constraint on how you can evolve your system and is a tax on understanding things.\r\n\r\nLisps excel at building new programming languages, because they solved parsing. They give you a balanced parenthesis sequence which you can trivially parse and transform. So if you're working with languages, it's the perfect tool. That's what got me interested in Janet. At TigerBeetle, we support clients for 5-6 languages and I want to build an in-process model of TigerBeetle in the host language. So if you're writing in Python and want to run tests, you don't have to be in the TigerBeetle binary nor embed it, you'd just have a Python module which re-implements the same logic in Python. So I'm thinking of implementing the TigerBeetle state machine in an abstract language and then compile it down to Python, JavaScript, Java etc. Lisp is perfect for this. You start your abstract language with an intermediate syntax tree (IST) implemented as s-expressions, then lower it into syntax trees for Python, Ruby, whatever but also implemented as s-expressions. Then there's a simple function which takes this Python IST and produces a string.\r\n\r\nLisps are really good at manipulating trees, but you don't want to make every problem in your codebase a problem of defining your language. There's a limited amount of languages you can keep in your head and you only want to go that far if the payoff is really great. With OOP, if you're building an extensible code editor like VSCode, making the interface into an object-oriented program is a good idea, it's exactly where you want this open-world extensibility and the vocabulary of OOP really fits. But you don't want that through your entire codebase. It's the same with custom languages. Sometimes you can benefit from a DSL, but don't try to turn every program into one!\r\n\r\n**Could you go more into solving the expression problem?**\r\n\r\nYou can extend a data structure in terms of data variance or operations. OOP lets you add more kinds of data to the same interface, sum types let you cheaply add more operations. But most of the time you want neither, your code should be absolutely closed. Rust's hash map is not extensible, there's no hash map trait because no one needs it. There's also no reason to add a custom hash map operation. This is a pattern of general cognitive biases in programming; we think hard about expressivity, allowing stuff. But extensibility always has costs and good systems design is when you can limit extensibility. Good systems are extensible, but through a specific, narrow crisp interfaces.\r\n\r\n**How do you approach modeling a problem or domain?**\r\n\r\nThe top level question's whether I am modeling a program domain or what my CPU is actually going to do? These are two very different vantage points to approach programming from. On one hand, we have mathematical modeling, where you describe your problem as a mathematical object with some operations and how it is transformed over time. Your goal there, as a programmer, is to capture fuzzy intuition about the world into rigid, executable mathematical specifications. The other vantage point is what the CPU is doing, getting the most of your CPU cores and making every instruction count. You have to think in terms of bytes, CPU cycles, latency numbers etc.\r\n\r\nSo first, determine what regime you're functioning in; because if you don't have performance constraints, you should be thinking about modeling the problem for a human to understand. If you care about performance, you should think about what's efficient to execute and change your problem to map cleanly to hardware. The purpose of computers ultimately is making things fast and you totally should change your problem, what your program is doing, to make it. If modeling things, I'll try to identify some core abstraction, some invariance etc. But there's always interplay. Rust, in particular, is pretty great and lets you do both at the same time, to some extent. \r\n\r\nSecond, think about the program and its evolution over time. Coding is easy. You can just write a program (or even ask a GPU to write it for you) and it's there. Evolving it over time is hard. Can you change it? Are you promising any public interfaces? If I can change it tomorrow, I don't care what I write today because I can always improve it. You could draw on paper what the nouns, verbs, data and fundamental data transformations are, figure out how it'll evolve. But I don't honestly do much upfront modeling. Normally, there's just something obvious to do next, so I'm always doing that.\r\n\r\n**How do you approach writing a blog post?**\r\n\r\nIf I have a good title, I'll just write it all up then and there! If I can't find a good title, it just sits in the drafts forever until I forget about it. If it doesn't get done in one sitting, it won't get finished. So I'll sometimes stay up all night doing it, while still in the [flow](https://en.wikipedia.org/wiki/Flow_(psychology)). This is why I write blog posts, not books: I can finish them before I die of starvation!\r\n\r\n**How do talks go? You can't just wing it based on the title, because you have slides prepared!**\r\n\r\nThe night before the talk! Talks are harder because they're announced, while if I never publish a blog post I was working on, _no one knows_. But it's too easy to commit to talks 6 months out, because only the future Matklad will have to deal with the consequences of my decisions today. Even if he'll hate me now, he's committed and has to push himself! But yeah, I'm not super keen on the talks; I like reading stuff. It's quicker and gets into my brain better. The purpose of conferences aren't really talks, but bringing like minded people to the same room for networking, collaborating, solving a coordination problem. But most talks would be better as a blog post.\r\n\r\n**How did you end up in programming?**\r\n\r\nAt school, I didn't program at all and only did mathematics, but I wanted to do something more tangible. However, in Russia, a software engineering degree is physics, analysis, differential equations, topology etc. so I do have a mathematically inclined brain. I tried a MA to see if I'd like theoretical computer science, but several months in, I realized proving theorems about Turing machines is fun, but what keeps me up at night was hacking on a little visualization of that Turing machine in JavaScript. The tangible part brought me to programming instead of proving theorems.\r\n\r\n**Do you write much JS these days?**\r\n\r\nI have VS Code extensions where I use it and routinely use the web stack for visualizations, GUIs etc. but like 2005-style. But I know flexbox, that's super important! Before that, layouts were a complete nightmare!\r\n\r\n**How do you learn something new?**\r\n\r\nI always try to learn the underlying idea, not the actual thing. I try to just type the API, expecting stuff to be there. If it's not, either the library is missing a feature or I need to fix my mental model. All knowledge is super compressible, so once you understand the general idea, you should be able to derive the rest and not need to learn every detail.\r\n\r\n**You mentioned that Rust is very good at both modeling for humans and the machine, how would you put compare Zig and others?**\r\n\r\nZig is strictly a machine level language. An example for the last question, how do you learn Zig? You learn that it's a DSL for producing machine code. Once you understand that, you'll know why it has inline for. Because inline for is a way to specify a DSL that you want to have a similar but different fragment of assembly to be repeated.\r\n\r\nI'd describe Rust as better than everything else. It's not _great_, there's a lot of stuff that could be better. Zig's pretty close to optimal for its goal of producing machine code. There's little fat to the language.\r\n\r\n**I'd love for you to explain the domain models of literally every technology possible, but that's too much to ask. So, how do computers work? I mean, I read some books, did nand2tetris etc. so I know how they worked 40 years ago, but now that IST is emulating old machines, there's magic everywhere... How do you know what's going on, that Zig can be a DSL to? It seems inscrutable!**\r\n\r\nThat's a good question. To be honest, I also have a vague understanding about what my CPU is actually doing. We're programming against x86 or Arm64 instruction sets, which are just abstractions. In my computer, there's a smaller computer transforming my x86 program into an actual program for the hardware. It's layers all the way down. Useful to keep in mind, Andrew Kelly's definition of what systems programming is: Programming against the underlying platform APIs. So, programming for the browser, you can program in C because it's the systems programming language, compile it into WASM and run WASM in the browser, but are you doing systems programming because it's C? No! You can't do browser systems programming in WASM, because systems APIs aren't exposed to WASM today. Systems programming in the browser is necessarily in JavaScript, because that is the underlying system API, the final level without indirection you can code against.\r\n\r\nSo we can't say what happens in a CPU, by design, because it gives designers flexibility to change things. As I was saying before, the most important thing about a system isn't how you model a domain, but how you upgrade it! It's remarkable how Apple could transition from Power to x86 to Arm, because they thought it through. When you code in Zig, you can't know what happens underneath your assembly, beneath machine code, but you have tight control of the machine code while being target-independent, without inline assembly. There's a fundamental abstraction required to make target-independence possible. It doesn't prioritize particular patterns. For example, there are at least 2 ways to do dynamic dispatch. C++'s style has an object start with an object header with a pointer to the vtable. Rust's obviously superior way uses wide pointers with a pointer to the data and a pointer to the vtable, so you can flexibly combine arbitrary data and vtables, which Go and Swift also do. C++ and Rust hardcode these approaches. Zig provides you with nothing, so you have to write your own abstraction. You could do polymorphism through [FieldParentPtr](https://www.ryanliptak.com/blog/zig-fieldparentptr-for-dumbos/), it doesn't matter! But it's the curse of choice, it's on you as a programmer to build your primitive abstractions, which isn't what you want to do if you're programming in the mathematical domain modeling approach to software engineering. It's important that Zig's a language, not just portable micro assembly, because Zig enables you to abstract over those patterns or machine code. This is the difference of metaprogramming between Lisp and Zig: In Lisp you abstract source code, the text of your program, because a macro expands to the source code. In Zig, you want to abstract over and expand to machine code, thinking about copy-pasted fragments of assembly, not fragments of source code.\r\n\r\n**Circling back to Matklad's user space redux...**\r\n\r\nAlso kernel space! The user space is the easy part. A historical issue defining our computer landscape is that modern kernels try really hard to provide the illusion of a blocking API. You write a file, which takes time then you continue when it's done. This is smoke and mirrors, this isn't how hardware works at all! It's always fire and forget: Write this, here's a region of memory, wake me up when it's over. It's fundamentally asynchronous. The OS provides these thread and process abstractions which make you think the API's blocking. The horrible side effect's that language designers get an out of jail card for async programming, they don't have to think about it! When writing to a file, they don't need to make sure the bytes aren't moved during the operation while running something. No, you just bind to the POSIX API and enjoy this blocking world illusion.\r\n\r\nBut historically, hyperscalers then found the blocking APIs kind of slow, so languages retrofitted async without planning for it, with mediocre results. We don't know how to write asynchronous code, because we allow language designers to design languages which just rely on the OS for that part of the runtime. Coroutines are implemented in the kernel, but should be in languages, so I'd start with the kernel!\r\n\r\n**A friend wanted to know what you think of Zig's async vs. Rust's.**\r\n\r\nThe biggest difference is that Rust async actually exists so you can use it, but Zig's async doesn't really exist yet. But it's absolutely brilliant that Zig makes a sharp distinction between API used to express concurrency and asynchrony and the implementation. Zig says this is the API, how you model async flows, but the actual runtime might be synchronous or multi-threaded. This is good, because there are a lot of questions about how to implement asynchrony, again because we all rely on one suboptimal implementation in the kernel. Then we have a second implementation in the user space and they fight with each other.\r\n\r\nBut another can of worms is how you actually express that something's concurrency. We don't have any answers yet. I am slightly hesitant that Zig goes for a library based approach where creating an asynchronous flow of execution, a future, a coroutine is like a library call, I feel this has to be built into the language. I believe asynchrony is a universal construct like a `for` loop. You don't _have_ to write a language with a `for` loop, you could use `goto` or `while` but we figured out `for` is a pretty universal construct, which wasn't obvious before. Dijkstra wrote his diatribe about how we should do structured programming with this theory which proves how `if` and `for` are enough to code everything without `goto`. It took some time to realize we didn't have to use assembly but could write in high-level languages like C! With concurrency, I feel we're still in this `goto` phase. We try to solve it with library design, futures, promises, channels, nurseries, bundles... I think we need a few keywords like semicolon, where what's before and after can go fully parallel or something. But I'm not a language designer. My observation's that we don't force language designers to answer this question, which is a shame.\r\n\r\nSo I'm really happy Zig distinguishes between implementation and interface, but sad the implementation is just a library, because it's a local optimum. I think it makes sense to come up with 5 keywords to describe it like control flow, to describe everything, but don't ask me what those 5 keywords are.\r\n\r\n**What are those 5 keywords?**\r\n\r\nFundamentally, you want to describe a tree shaped stack. A stack which branches. You need keywords to:\r\n- branch in 2\r\n- branch to n\r\n- allow a runtime this many branches in this tree (an [accept loop](https://rust-exercises.ferrous-systems.com/latest/book/async-chat/accept_loop) says while accept pass this coroutine for this particular client. If you just do static concurrency, you couldn't write those things)\r\n- synchronization (`let a = async work; let b = async work; join a and b;` but not a promise\r\n\r\nI don't think you should expose promise as a construct. We don't have a promise for an uninitialized variable like `var x = promise; x resolve foo;` to access x. We just specify stuff such that we can only access a variable once computed. I think we could do the same for concurrency, scheduling things but only using them when guaranteed to be joined. But I'm not a language designer.\r\n\r\n**What is an OS to you? [Introduction to Operating System Abstractions using Plan 9](https://archive.org/details/plan9designintro) taught me it's the whole interface to use your machine, including languages. My dream OS would even handle garbage collection and the database. You have a different model.**\r\n\r\nWe don't know the answers. I don't necessarily think we know what an operating system is. Maybe tomorrow someone writes a Lisp machine which is actually good and we spend the next 50 years gluing legacy code into it. Or a glorious world where language-level abstractions correspond to hardware where you can't break out of your abstractions. It breaks down to the question: What is a computer? We have 2 answers. Mechanically, a computer is linear memory which is executable, a Von Neumann architecture letting you do anything you want. But we can also say it's a graph of objects which have a specific interface, you can write, compose and send messages. We might be going there, that's what WASM with interface types is. There's still linear memory as pokeable bytes, but it's really a graph of individual objects with isolated heaps. I don't know whether it'll be successful or not, but it could be our entire future infrastructure. My gut feeling says we should expose the lowest level hardware denominator, but it's not really true. Virtual memory is like a poorly done capability system. I'm excited about [CHERI](https://en.wikipedia.org/wiki/Capability_Hardware_Enhanced_RISC_Instructions). I want to channel @carlana that CHERI is not a replacement for Rust (by compiling C++ to CHERI for memory safety), CHERI is a replacement for virtual memory. Instead of slicing your address space into process granularity and suffering like TLB flushes and what not, when you switch processes you could do a faster and simpler system slicing memory into individual objects and passing capabilities to those slices. This doesn't feel higher-level than what we have today, because it's just more general virtual memory.\r\n\r\nThe key idea of a computer might be the interface, what you can program against, where there's a kernel on the other side, which can change without breaking the interface. I have no idea how it should look, what belongs above and below the kernel etc. I don't think current systems are the best, but we're just locked in because of history.\r\n\r\n**[Hare wants to be a hundred-year language](https://harelang.org/blog/2023-11-08-100-year-language/), do you think Zig has what it takes?**\r\n\r\nI don't believe in the concept of a 100-year language. We will have to change languages in the future. We aren't even done with Moore's law. It seems premature to commit to absolute stability. We should be open to change. Perhaps balance and build infrastructure for 20 years and think out how we'll decommission and replace it with something better. This is why toolability's such a crucial thing for a language. C++ gets it right. It's a horribly complicated language, impossible to process automatedly, so it's impossible to replace. When people invent a better Go, they'll automatically translate it, it's designed for it. But C++ will always be there because of some macro with undefined behavior. The smart thing is probably what Rust does, stability without stagnation. I'm glad Hare does have this [automated transformation](https://harelang.org/blog/2025-06-11-hare-update/) for the currently unstable language, though I think it's more useful when it is stable and you want to upgrade it.\r\n\r\nFor Zig, I don't care. I use Zig for one particular purpose, writing TigerBeetle. The key's that we don't have dependencies, so upgrading is easy. Normally, upgrading the language is hard because dependencies start using the same version, but gradually want different versions and you have to decide which baby to throw out of the window. I think Zig had the ambition to release 1.0 in 3 years. But that might be Zig's advantage. We already have a good enough systems programming language: Rust. Zig doesn't have to chase stability, it could redo async await 5 times until it really gets it right. \r\n\r\n**Who chose Zig at TigerBeetle?**\r\n\r\nJoran, our founder, I think. He could have chosen C, Zig, Rust and it would have been fine. I wouldn't have made it, because I was too enamored with Rust. Previously, Joran was working on Node.js with gigabytes of dependencies and the absolute advantage of Zig at the time was missing a package manager. Unfortunately for TigerBeetle, Zig now has a package manager but our strong culture lets us ignore this and fight the temptation of dependencies.\r\n\r\n**You said you were enamored in Rust, you fell out of love?**\r\n\r\nIt's a brilliant industrial language, already in Windows and Linux! That's mindbogglingly unbelievable. In 2016 I would have said it's only successful if it'd enter the kernels but didn't think it'd happen this fast. But Rust isn't as focused on low-level programming; it bridges high and low levels. So I wouldn't have expected HTTP web services and RPC and still don't think it's the best possible language for these things. It's still the best language out of what we have today.\r\n\r\n**Your blog has a bit about mentorship etc. How did _you_ actually learn?**\r\n\r\nLearning is funny. When finishing university, I thought I'd be a professional programmer! A junior developer with a mentor who could explain how to write production-ready code. For the first 8 years of my career, I searched for that mentor and realized I wouldn't find them. Mentorship is a bright idea but didn't work for me. I had to figure everything out from first principles, from books, trying things out. You can just learn programming, it's not rocket science. I've written a lot about what I learned on my blog, which is just learning and thinking from first principles. A lot of it is just \"I was thinking of x and tried it out.\" People often ask me to mentor them, but it's not scalable for me.\r\n\r\nI just try to explain: If you want to be a writer, you write. If you want to be a potter, you make pots. But actively reflect on your code, [deliberate practice](https://alexalejandre.com/programming/deliberate-practice-for-developers/) although I don't like the concept. Solve a problem, feel pain, understand why you're feeling pain and form a hypotheses for how to avoid pain next time. It's important to solve toy problems. This really surprised me, because I loved building toys as a young programmer. I'd code a red black tree with Java AWT, compilers or a database. I didn't think they had any relationship to real things, but when I started working, real projects are the same as toys, just bigger and sometimes worse! Because you can throw away and improve a toy, but you can't always fix architectural mistakes in production systems. Trust your own reflective brain, not mentors!\r\n\r\n**What's on your mind lately?**\r\n\r\nLLMs. They're not ground breaking for me yet, but if the trajectory continues everything will be so different in 10 years. My own personal strategy is that I check every 6 months whether I can automate myself away yet. Otherwise, I ignore the whole field because it's not my own comparative advantage.\r\n\r\nTerminals suck. Interfaces are important, but terminal interfaces are really bad. Yesterday, I learned a soul-breaking fact. `stderr` is human readable and `stdout` is structured output, a beautiful system, but if you actually use a terminal, a PTY device, they aren't actually distinct. The two streams are erased going into the same terminal! We have this beautiful system, but then we put io coreutils on top to turn our file descriptor into adhoc device and adhoc controls. Let's say I want to display color output from Zig build. Just capturing the output won't give me colors, which makes sense. So I may not like them, but I can use ANSI escapes for colors and do my job and properly parse and render them like HTML. But you can't do that without the kernel, asking it to make a pseudo terminal, giving Zig build's process half and me the other, which is horrible! The power of an interface is having multiple implementations which behave the same, which terminals violate. Escape sequences are the same, I just want colors! (Though there is a `CLICOLOR_FORCE` environmental variable, but it's pretty horrible.) Out of band signaling and literal signaling like `SIGWINCH` is horrible. Also, I'm a human!\r\n\r\nI use computers as a human and a stream of bytes as an interface isn't convenient. I want to love text, but text for me is a grid of characters I can move my cursor around. So I want the concept of an Emacs buffer, elevated from a special thing in 1 editor to a coprimitive of the OS or an IPC thing. I dream of an API letting you implement [Magit](https://github.com/magit/magit) as a separate binary which talks to arbitrary clients. Such a rich and structured interface would offer great power, while remaining 100% text. But such things take a lot of time and effort. I'm not angry enough to dedicate 5 years of my life to shaving this particular yak, so I begrudgingly use [Ghostty](https://github.com/ghostty-org/ghostty) terminal, though terminals should die. There's a path dependency, they are good enough, so people grow to like them.\r\n\r\n**If guys were to start from scratch on TigerBeetle, would it be different or worth doing?**\r\n\r\nI don't think so. We are very happy with what we have built. We might tweak our domain model slightly. We have concept of pending transfer, a created but not finalized transfer which might be better modeled as a transfer scheduled in the future. Instead of saying this transfer gets voided in 2 days, you'd submit the original transfer and one scheduled in the future. But because of our stable interface we solve such problems differently. It's not worth rewriting for that.\r\n\r\nAutomatic minimization for our simulator would be good. Right now, our simulator doesn't do minimization. It finds the bug which is 10 GB of logs or it could be a shorter issue, but maybe not. That's no attempt to smartly minimize this. I think it would be easy to retrofit minimization and if starting from scratch, I would. Full disclosure: I wanted to learn to build such systems but hadn't worked on big distributed systems so I starting hacking on a toy. I thought a banking application doing transfers was a good distributed system which needs consensus, which is hard to test! So I needed proper randomized testing with minimization, which is easy with Rust's [arbitrary](https://docs.rs/arbitrary/latest/arbitrary/) crate. That's how [arbtest](https://github.com/matklad/arbtest) was born. Then I found out about TigerBeetle and got on a call to show our simulators to each other. We were working on the same thing! But my toy simulator had working minimization while TigerBeetle doesn't! In TigerBeetle today, we don't have bugs so we don't need a bug minimizer. But of course it took a while to get here. I spent a lot of time debugging with 20 GB log files and needed a minimizer because grepping 20 GB was realy inefficient. But actually, I'd already written a minimizer but not a grep. So I ended up writing my own grep replacement [window](https://github.com/matklad/window)  and used that to fix the bugs.\r\n\r\nBut overall, TigerBeetle is a perfect piece of software.\r\n\r\n**Is anything else perfect?**\r\n\r\nSQLite!\r\n\r\nAs far as programming languages go, Zig. It strikes its intended target as close as possible. Rust is great, better than C++ and Java but there's `.` for method access or `::` for namespaces which aren't great. There are 5 comment syntaxes... There's a lot of accidental complexity in Rust while Zig's really tight. If you removed a single primitive from the language, it'd fall apart.\r\n\r\nThe [fish](https://fishshell.com/) shell has a perfect interface and was a major influence in how I think about building tooling without needing any configuration. I've been using it since ~2014, before I started doing Rust.","submitter_user":"veqq","user_is_author":true,"tags":["interview","person"],"short_id_url":"https://lobste.rs/s/ntruuu","comments_url":"https://lobste.rs/s/ntruuu/lobsters_interview_with_matklad"},{"short_id":"62si4z","created_at":"2025-08-22T07:24:03.000-05:00","title":"I'm too dumb for Zig's new IO interface","url":"https://www.openmymind.net/Im-Too-Dumb-For-Zigs-New-IO-Interface/","score":67,"flags":0,"comment_count":13,"description":"","description_plain":"","submitter_user":"janerik","user_is_author":false,"tags":["zig"],"short_id_url":"https://lobste.rs/s/62si4z","comments_url":"https://lobste.rs/s/62si4z/i_m_too_dumb_for_zig_s_new_io_interface"},{"short_id":"5tcy8c","created_at":"2025-08-22T06:49:52.000-05:00","title":"What about using rel=\"share-url\" to expose sharing intents?","url":"https://shkspr.mobi/blog/2025/08/what-about-using-relshare-url-to-expose-sharing-intents/","score":6,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"edent","user_is_author":true,"tags":["web"],"short_id_url":"https://lobste.rs/s/5tcy8c","comments_url":"https://lobste.rs/s/5tcy8c/what_about_using_rel_share_url_expose"},{"short_id":"sufmir","created_at":"2025-08-22T05:58:28.000-05:00","title":"Emacs is violent passion","url":"https://mihaiolteanu.me/emacs-is-violent-passion","score":12,"flags":1,"comment_count":19,"description":"","description_plain":"","submitter_user":"confusedalex","user_is_author":false,"tags":["emacs","rant"],"short_id_url":"https://lobste.rs/s/sufmir","comments_url":"https://lobste.rs/s/sufmir/emacs_is_violent_passion"},{"short_id":"wk6fvj","created_at":"2025-08-22T05:53:58.000-05:00","title":"An Interactive Guide to SVG Paths","url":"https://www.joshwcomeau.com/svg/interactive-guide-to-paths/","score":2,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"acatton","user_is_author":false,"tags":["visualization"],"short_id_url":"https://lobste.rs/s/wk6fvj","comments_url":"https://lobste.rs/s/wk6fvj/interactive_guide_svg_paths"},{"short_id":"ug4ch4","created_at":"2025-08-22T03:23:26.000-05:00","title":"Arch Linux - News: Recent service outages","url":"https://archlinux.org/news/recent-services-outages/","score":26,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"Foxboron","user_is_author":false,"tags":["linux"],"short_id_url":"https://lobste.rs/s/ug4ch4","comments_url":"https://lobste.rs/s/ug4ch4/arch_linux_news_recent_service_outages"},{"short_id":"tkydi6","created_at":"2025-08-22T01:22:44.000-05:00","title":"The Baby Paradox in Haskell","url":"https://blog.jle.im/entry/the-baby-paradox-in-haskell.html","score":22,"flags":0,"comment_count":2,"description":"","description_plain":"","submitter_user":"abhin4v","user_is_author":false,"tags":["formalmethods","haskell"],"short_id_url":"https://lobste.rs/s/tkydi6","comments_url":"https://lobste.rs/s/tkydi6/baby_paradox_haskell"}]