[{"short_id":"stness","created_at":"2025-07-26T16:04:12.000-05:00","title":"Test results for AMD Zen 5","url":"https://www.agner.org/forum/viewtopic.php?t=287\u0026start=11","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"fanf","user_is_author":false,"tags":["hardware","performance"],"short_id_url":"https://lobste.rs/s/stness","comments_url":"https://lobste.rs/s/stness/test_results_for_amd_zen_5"},{"short_id":"gugsqu","created_at":"2025-07-26T12:30:02.000-05:00","title":"Reversing the C64 Bubble Bobble RNG","url":"http://geon.github.io/programming/2025/07/24/bubble-bobble-c64-rng-emulator","score":2,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"classichasclass","user_is_author":false,"tags":["retrocomputing","reversing"],"short_id_url":"https://lobste.rs/s/gugsqu","comments_url":"https://lobste.rs/s/gugsqu/reversing_c64_bubble_bobble_rng"},{"short_id":"jfbzwa","created_at":"2025-07-26T11:45:50.000-05:00","title":"Optimi-Zi(n)g Sudoku-Solving","url":"https://log.pfad.fr/2025/optimi-zig-sudoku-solving/","score":7,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"oliverpool","user_is_author":true,"tags":["performance","zig"],"short_id_url":"https://lobste.rs/s/jfbzwa","comments_url":"https://lobste.rs/s/jfbzwa/optimi_zi_n_g_sudoku_solving"},{"short_id":"78kvoj","created_at":"2025-07-26T09:56:13.000-05:00","title":"clj-coll: Clojure collections and sequences in Common Lisp","url":"https://github.com/dtenny/clj-coll","score":5,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"veqq","user_is_author":false,"tags":["lisp"],"short_id_url":"https://lobste.rs/s/78kvoj","comments_url":"https://lobste.rs/s/78kvoj/clj_coll_clojure_collections_sequences"},{"short_id":"8cwich","created_at":"2025-07-26T09:36:45.000-05:00","title":"Perfecting anti-aliasing on signed distance functions","url":"https://blog.pkh.me/p/44-perfecting-anti-aliasing-on-signed-distance-functions.html","score":13,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"ubitux","user_is_author":true,"tags":["graphics"],"short_id_url":"https://lobste.rs/s/8cwich","comments_url":"https://lobste.rs/s/8cwich/perfecting_anti_aliasing_on_signed"},{"short_id":"sba8mw","created_at":"2025-07-26T09:11:15.000-05:00","title":"emacs-arei Async IDE for Guile","url":"https://git.sr.ht/~abcdw/emacs-arei","score":4,"flags":0,"comment_count":0,"description":"\u003cp\u003eHere’s a video showing it off: \u003ca href=\"https://www.youtube.com/watch?v=gQpwf4jgpGo\" rel=\"ugc\"\u003ehttps://www.youtube.com/watch?v=gQpwf4jgpGo\u003c/a\u003e\u003c/p\u003e\n","description_plain":"Here's a video showing it off: https://www.youtube.com/watch?v=gQpwf4jgpGo","submitter_user":"veqq","user_is_author":false,"tags":["emacs"],"short_id_url":"https://lobste.rs/s/sba8mw","comments_url":"https://lobste.rs/s/sba8mw/emacs_arei_async_ide_for_guile"},{"short_id":"byakmv","created_at":"2025-07-26T07:04:54.000-05:00","title":"From Async/Await to Virtual Threads","url":"https://lucumr.pocoo.org/2025/7/26/virtual-threads/","score":19,"flags":0,"comment_count":11,"description":"","description_plain":"","submitter_user":"ngrilly","user_is_author":false,"tags":["python"],"short_id_url":"https://lobste.rs/s/byakmv","comments_url":"https://lobste.rs/s/byakmv/from_async_await_virtual_threads"},{"short_id":"y1qs6b","created_at":"2025-07-26T06:56:04.000-05:00","title":"Hand Drawn CGI: Animating the Terrahawks Title Sequence","url":"https://www.youtube.com/watch?v=HI7oEiaR8PU","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"vlnn","user_is_author":false,"tags":["art","design","video"],"short_id_url":"https://lobste.rs/s/y1qs6b","comments_url":"https://lobste.rs/s/y1qs6b/hand_drawn_cgi_animating_terrahawks"},{"short_id":"mf5mup","created_at":"2025-07-26T06:12:27.000-05:00","title":"Arm desktop: x86 emulation","url":"https://marcin.juszkiewicz.com.pl/2025/07/22/arm-desktop-emulation/","score":8,"flags":0,"comment_count":2,"description":"","description_plain":"","submitter_user":"raymii","user_is_author":false,"tags":["linux"],"short_id_url":"https://lobste.rs/s/mf5mup","comments_url":"https://lobste.rs/s/mf5mup/arm_desktop_x86_emulation"},{"short_id":"6yqrbm","created_at":"2025-07-26T06:00:03.000-05:00","title":"Heredocs Can Make Your Bash Scripts Self-Documenting","url":"https://holdtherobot.com/blog/heredocs-can-make-your-bash-scripts-self-documenting/","score":21,"flags":0,"comment_count":6,"description":"","description_plain":"","submitter_user":"raymii","user_is_author":false,"tags":["linux"],"short_id_url":"https://lobste.rs/s/6yqrbm","comments_url":"https://lobste.rs/s/6yqrbm/heredocs_can_make_your_bash_scripts_self"},{"short_id":"x3obdr","created_at":"2025-07-26T05:40:30.000-05:00","title":"Most of your projects are stupid. Please make some actual games","url":"https://www.youtube.com/watch?v=Ca53JTohdN4","score":4,"flags":3,"comment_count":6,"description":"","description_plain":"","submitter_user":"gingerBill","user_is_author":false,"tags":["games","programming","video"],"short_id_url":"https://lobste.rs/s/x3obdr","comments_url":"https://lobste.rs/s/x3obdr/most_your_projects_are_stupid_please_make"},{"short_id":"zditcp","created_at":"2025-07-26T04:01:51.000-05:00","title":"It's time for modern CSS to kill the SPA","url":"https://www.jonoalderson.com/conjecture/its-time-for-modern-css-to-kill-the-spa/","score":31,"flags":0,"comment_count":15,"description":"","description_plain":"","submitter_user":"eduard","user_is_author":false,"tags":["css","web"],"short_id_url":"https://lobste.rs/s/zditcp","comments_url":"https://lobste.rs/s/zditcp/it_s_time_for_modern_css_kill_spa"},{"short_id":"jmttl2","created_at":"2025-07-25T23:38:35.000-05:00","title":"Can LLMs Do Accounting?","url":"https://accounting.penrose.com/","score":11,"flags":4,"comment_count":3,"description":"","description_plain":"","submitter_user":"ohrv","user_is_author":false,"tags":["vibecoding"],"short_id_url":"https://lobste.rs/s/jmttl2","comments_url":"https://lobste.rs/s/jmttl2/can_llms_do_accounting"},{"short_id":"8kxhxe","created_at":"2025-07-25T23:03:58.000-05:00","title":"OpenPGP for application developers","url":"https://openpgp.dev/book/index.html","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"sebastiancarlos","user_is_author":false,"tags":["cryptography","privacy","security"],"short_id_url":"https://lobste.rs/s/8kxhxe","comments_url":"https://lobste.rs/s/8kxhxe/openpgp_for_application_developers"},{"short_id":"oosbf5","created_at":"2025-07-25T22:35:00.000-05:00","title":"Split Flap","url":"https://fx.hot.page/split-flap","score":18,"flags":0,"comment_count":2,"description":"","description_plain":"","submitter_user":"veqq","user_is_author":false,"tags":["design","web"],"short_id_url":"https://lobste.rs/s/oosbf5","comments_url":"https://lobste.rs/s/oosbf5/split_flap"},{"short_id":"7lshyx","created_at":"2025-07-25T21:19:17.000-05:00","title":"The Sparse Frontier: Sparse Attention Trade-offs in Transformer LLMs","url":"https://arxiv.org/abs/2504.17768","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"friendlysock","user_is_author":false,"tags":["ai","performance"],"short_id_url":"https://lobste.rs/s/7lshyx","comments_url":"https://lobste.rs/s/7lshyx/sparse_frontier_sparse_attention_trade"},{"short_id":"dfket6","created_at":"2025-07-25T17:56:42.000-05:00","title":"GNOME Calendar: A New Era of Accessibility Achieved in 90 Days","url":"https://tesk.page/2025/07/25/gnome-calendar-a-new-era-of-accessibility-achieved-in-90-days/","score":36,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"calvin","user_is_author":false,"tags":["a11y"],"short_id_url":"https://lobste.rs/s/dfket6","comments_url":"https://lobste.rs/s/dfket6/gnome_calendar_new_era_accessibility"},{"short_id":"hol26j","created_at":"2025-07-25T16:44:52.000-05:00","title":"HTTP/1.1 Must Die","url":"https://http1mustdie.com/","score":5,"flags":10,"comment_count":4,"description":"","description_plain":"","submitter_user":"skeptrune","user_is_author":false,"tags":["networking","security"],"short_id_url":"https://lobste.rs/s/hol26j","comments_url":"https://lobste.rs/s/hol26j/http_1_1_must_die"},{"short_id":"terwiu","created_at":"2025-07-25T16:38:09.000-05:00","title":"Lobsters Interview with Technomancy","url":"","score":126,"flags":0,"comment_count":8,"description":"\u003cp\u003eI am resurrecting \u003ca href=\"https://lobste.rs/t/interview\" rel=\"ugc\"\u003eLobsters interviews\u003c/a\u003e. Although the interview becoming the next interviewer is a really cool conceit, it didn’t pan out for longevity.\u003c/p\u003e\n\u003cp\u003eThis is the result of one and a half hours talking to \u003ca href=\"https://lobste.rs/~technomancy\" rel=\"ugc\"\u003etechnomancy\u003c/a\u003e. (\u003ca href=\"https://lobste.rs/~icefox\" rel=\"ugc\"\u003eIcefox\u003c/a\u003e and \u003ca href=\"https://lobste.rs/~hwayne\" rel=\"ugc\"\u003ehwayne\u003c/a\u003e are next.)\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003ePast interviews started off with introducing yourself, what do you do for work etc. But you’re not so interested in your work-work.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI started programming as a kid, but fell off the wagon for a while. In college, I got back into it, and around graduation, around 2004, got really into Ruby, at its inflection point. I didn’t exactly get tired of it, but my eye caught something shinier with Clojure and functional programming, which was really in around 2008-9. Like, everyone saw Moore’s law tapering off and thought of functional programming as the solution, the way forward. Now, I’m still doing that professionally but I got disillusioned with…\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou once mentioned it wasn’t meant for hobby projects, everything added’s for corporate use\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYeah, I guess to take a step even further back, I got really interested in the free software movement, kind of idealistic in this idea that you could make the world a better place with software! And open\nsource, because I felt like that was the same thing. The idea was by picking the right\nlicense you can write software that makes the world better, which doesn’t actually make any\nsense because like, what is the software doing? Without more analysis, people think they’re like being altruistic, developing open source and it ends up just being free labor for companies to exploit. So I got disillusioned with the JVM in terms of that. Like, if I’m going to get paid for it, it’s fine.\u003c/p\u003e\n\u003cp\u003eBut it’s really good at solving problems companies have, not humans. So I wanted to change how I was going to spend my free time. From there, I got really into Lua, playing around, making games with my kids, using love2D, for 3-4 years. But then I found this compiler Fennel that applied what I learned in Clojure to Lua. I eventually took over the project and been running it since since then. That’s where most of my headspace is right now.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWas what took you away from Ruby similar to what pulled you from Clojure?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNo, with Lua, I wanted to deliberately step back from the corporate world, which didn’t play into leaving Ruby before. But there are some similarities. I got into both when they were hitting their inflection points. You really \u003ca href=\"https://www.youtube.com/watch?v=jTurIBwz0mY\" rel=\"ugc\"\u003ehad to be there\u003c/a\u003e in 2004 with Ruby or 2008 with Clojure. No one would do it because they thought it was good for their career, but because you just really wanted to learn more and expand your horizons. It was like the reason I came didn’t apply anymore, this is mature, I’ve learned a lot from this, but I don’t feel like I’m learning anymore.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou mentioned the Moore’s loss stopping, slowing down. Maybe 5 or 8years after, I personally noticed it, which pushed me in the other direction of \u003cem\u003ewait, all these functional things like map, we’re wasting all these cycles. Maybe we shouldn’t be doing that.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIt’s an interesting tension, right? The zeitgeist was like, if Moore’s law’s slowing down\nit wasn’t that computer’s wouldn’t be more capable, but where would the capability come from? Going wide, adding more cores, scaling out instead of up, right? Until that point, in the the 90s and early 2000s, it was like, boom, boom, boom,\nour clock speeds were just going higher and higher. That’s what stopped.\u003c/p\u003e\n\u003cp\u003eNow, we were doing largely server side programs, so each server was going to have more cores and you’d throw in more\nservers. Erlang got a big boost in popularity. Relatively, for the niche nerds. But we thought \u003cem\u003ethis is the future\u003c/em\u003e. If you make it easier to spread out across multiple processes, you’re not going to not hit this problem. You’re not going\nto run into a wall. That resonated a lot with people and kicked off interest in algorithms that are easy to paralyze, which you get for free with immutable data. So functional programming\nbecame a lot more appealing, but as you mentioned, there’s also overhead.\nIf you can override a value in place, that’s faster than than making a\na functional update. There’s a place where that overhead won’t make sense, especially in the context of a single core, running on a more constrained hardware, maybe on mobile or on your laptop, you’re not going to want to just\nthrow more cores at it in the same way.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSo it actually fits with the human vs. business related software.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYeah. You you want to pay more attention to efficiency. If you’re if you’re a startup with all this investor money,\nand the community in the late 2000s had all this investor money sloshing around, you can solve your problem by throwing\nmore cores at it. I think ironically, the wave of interest in functional\nprogramming didn’t end up… Maybe I’m extrapolating here, but even imperative languages, you’re going to run in a\nsimilar way. You’re going to run a bunch of processes behind a load balancer and the point of\nsynchronization is going to be the database anyway. So using a\nfunctional language isn’t necessarily going to make it easier for you to go wide on that.\nIf you’re tied to a request response cycle, then your load balancer is going to do\nthe job for you. And everything’s web based, so you’re almost always tied to a request\nresponse cycle.\u003c/p\u003e\n\u003cp\u003eThere are exceptions. If you want to keep one socket open for an extended period of time, which Erlang handles more gracefully, that is really hard to do with a load balancer. But when you’re dealing with everything going over HTTP, it’s not really the silver bullet we expected.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat’s your workspace and computing environment like? We’ve talked about this on \u003ca href=\"https://lobste.rs/chat\" rel=\"ugc\"\u003eIRC\u003c/a\u003e, about decks and keyboards.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMy main machine is what I call a \u003ca href=\"https://blog.mattgauger.com/2022/08/01/the-51nb-x210/\" rel=\"ugc\"\u003eThinkPad fanfic\u003c/a\u003e, takes a chassis of a ThinkPad from like 2009. This hacker collective\nin Shenzhen redesigned the motherboard with a more modern CPU and architecture, which fits right into that.\nThe screen’s a little dim, but everything else is great, the replaceable battery, old school ThinkPad keyboard.\u003c/p\u003e\n\u003cp\u003eBut the majority of the time I’m using the keyboard I designed myself \u003ca href=\"https://atreus.technomancy.us/\" rel=\"ugc\"\u003ethe Atreus\u003c/a\u003e with 42 in the original, 44 keys now, with each side angled to match where your hands are. But really portable because I,\nI love going out all the time, at least a couple times a week to coffee shops or when weather’s nicer, a park or something. I got the original Ergo Docs and I loved it. At home, it felt so good, but then pulling it out with all the wires at the coffee shops…\u003c/p\u003e\n\u003cp\u003eIn my office, I have an older ThinkPad with two portrait display monitors and a big old Kensington track ball, almost a billiard ball size. I like that a lot. But I prefer keyboard shortcuts. I use Emacs. And then there’re surfing keys in the browser extension I use to highlight links so I can visit the links with the keyboard. That’s pretty nice.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDo you have your Emacs config online somewhere?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYeah, \u003ca href=\"https://git.sr.ht/~technomancy/dotfiles\" rel=\"ugc\"\u003eall my dot files\u003c/a\u003e are together. Emacs and everything else. Yeah. But\u003c/p\u003e\n\u003cp\u003eI use Emacs as my window manager using \u003ca href=\"https://github.com/emacs-exwm/exwm\" rel=\"ugc\"\u003eexWM\u003c/a\u003e so every program running in Xorg is shown as if it was an Emacs buffer. So your regular Emacs screen splits instead of having text files inside of them. There’s Firefox, your terminal, whatever else.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDid Emacs come before closure or vice versa?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI started with Emacs in in university. I had just learned Dvorak and was like, now Vim or Emacs? In Vim, HKJL are all lined up for QWERTY and… forget it. So Emacs and Elisp.\u003c/p\u003e\n\u003cp\u003eWhen I started thinking about functional languages,\na lot of people were talking about Haskell and Erlang, but \u003cem\u003eI liked this Lisp thing\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDid you have any favorite courses or such? Like in some corners,\npeople love to obsess over SICP.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMy CS program wasn’t really great. I learned more from all the hacking I did to get Linux working on a laptop in 2003 than in classes. But recently I’ve been working through this book called Elements of Computing Systems, \u003ca href=\"https://www.nand2tetris.org/\" rel=\"ugc\"\u003enand2tetris\u003c/a\u003e, with my kids, in upper high school. I was trying to stay ahead of them, but it’s summer. There’s no way I can do that. But I like how every step is built on the previous step; you can’t use anything until you’ve derived it from first principles. And how far can that approach get you? It turns out pretty far!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDid you discover Lua games through programming with your kids or making games for, with them? When you first had kids, did you think oh I love programming and need to share it?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYeah. I think it’s normal to want to share what you’re interested in, with the kids and especially if they show interest and get on board. And games are just such a great way to learn, in general. It’s easy to get people and kids’ attention with games. And they’re curious \u003cstrong\u003ehow did they do that? Let’s take a look.\u003c/strong\u003e So we first started in \u003ca href=\"https://scratch.mit.edu/\" rel=\"ugc\"\u003eScratch\u003c/a\u003e, a drag and drop programming environment which is great for younger kids.\nYou don’t have to know how to type but it still lets you do step by step algorithms etc. And more importantly, if it doesn’t work the way expected, it teaches you how to debug that and how to break the problem apart and try to find e.g. where you didn’t quite cover all the bases or whatever.\u003c/p\u003e\n\u003cp\u003eOne of the coolest things about scratch is that when you publish something, anyone else can view source, how was it made, and then more importantly remix, like make a copy you can edit yourself and change, to, you know, make the characters move faster or see what happens when the shots are fired at a different angle. Experimenting is amazing when you’re trying to explore the world of how software works. I wish everything would work like that. It’s really empowering.\u003c/p\u003e\n\u003cp\u003eOne of my more recent projects is \u003ca href=\"https://fedibot.club/\" rel=\"ugc\"\u003efedibot.club\u003c/a\u003e where you can you can create these scripts that get tied into social media bots, to run either on a schedule or in response to replies and your script and do whatever.\nAnd this is really, really fun, just as kind of a toy to mess around with social media, but also great fit for\nLua because Lua makes it really easy to sandbox code and limit what you have access to,\nto make sure one person can’t write a script that will take the whole system down.\u003c/p\u003e\n\u003cp\u003eThen on top of that, I was able to add this same remix ability. So when you see one of these bots, maybe they’ll\nhave a link in their bio to the source. You go to their source code, log in and boom, you test it, change it, do something a little different!  I really admired Scratch and its model of view source. View source is so important for learning how to program, how a technique is done. You shouldn’t have to go search on GitHub then clone it, it should be right there, on your fingertips. Being able to read it isn’t really enough because there’re limits to how reading code without executing it.\u003c/p\u003e\n\u003cp\u003e(Later insert, today on IRC, he said:)\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUsing emacs is praxis because it gives people a view into how computing should be; view-source on every command, immediately rewrite things to work the way you want.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI feel we don’t understand this very well from a scientific perspective. Why is this\ntrue? For most things, you can just read a book and understand it. But reading a piece of code,\ninteracting with it, running, modifying it, those are so different! In terms of how you experience them and how it affects your understanding of the problem.\u003c/p\u003e\n\u003cp\u003eThere’s a really great paper on this called \u003ca href=\"https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1\" rel=\"ugc\"\u003eProgramming as Theory Building\u003c/a\u003e. It doesn’t even try to explain why, which is kind of funny. But it goes and talks about the implications of when you understanding. When you have a piece of code, what you really have, what’s really valuable is not the code, but the the knowledge in heads of the people developing it. That’s what you’re building. The code is almost a side effect of that. Once you have the theory about how the system works, the code itself is not that big of a deal. A lot people don’t understand that about working on a team and building programs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you actually approach modeling? Like, you have a problem. What do you do with it?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eSo with Fennel, I’m doing language design. And one most important skills for language design is just having enough imagination to try to think of all the ways how five years from now, we could be looking back on this, wishing if only we had known better and not done this. If you have an idea, what are the ways you’ll potentially regret it? It’s really hard and I think it can only come from experience.\u003c/p\u003e\n\u003cp\u003eEveryone’s really leaning into language server protocol nowadays, right? You have this kind of\nstandardized tooling, which enables certain analysis on on your project, when you made a mistake immediately instead of having to wait.\nI was a skeptic. but I’ve been won over. But it’s very difficult to do this safely. In Clojure, if you want to run the language server on a program or a file, you don’t want to compile the program because in Clojure compiling it runs it, which isn’t uncommon in dynamic languages. Obviously, the problem’s that you don’t know if you trust the code. And how do you know if you\nshould trust the code? By opening it up in your editor and reading it! But opening it up runs it? A chicken and egg problem. A lot of language servers just don’t care and run it anyway, which is really bad. I thought Clojure would too, because it’s so dynamic, but they built out a completely separate static analysis tool in the language server that does the job of the compiler, redundantly, safely, because it won’t to try to expand the macros. That’s great, the right choice with Clojure.\u003c/p\u003e\n\u003cp\u003eBut it sucks to not expand your macros. Sometimes the macro will introduce a new local variable and you… don’t see where it comes from, it looks like an error. So what can we learn from this experience? How can we run macros in a safe way? Well, why should a macro be able to write to disk, to open a network connection? That doesn’t make any sense. No one writes macros with legitimate reasons to open a network connection.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI totally do. I love to use macros to prepare the environments, download data and compile with those.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYeah, there are legitimate use cases to read from disc, but to write to disk, to send… Even if you do allow writes, never outside the project directory! But it’s too late for Clojure, hundreds of thousands have been written. But Fennel didn’t have a macro system yet. Okay, so macros are like functions; they take and produce ASTs. There’s no reason to be able to do output anything else. So we made our macro system work that way, so the Fennel language server doesn’t have the problem Clojure’s has, even though there’s a a tiny amount of comparative effort in this system. It’s smaller, with less resources, but capable of more because we learned from the situation.\u003c/p\u003e\n\u003cp\u003eThe commitment to backwards compatibility is hard. Sometimes you have to stick with these decisions you don’t like. And how can you avoid that, really learn from your own mistakes or learn from someone else’s mistakes? I like defaulting to saying no until you’ve really got the chance to think it all the way through. We can do what we’re confident now and extend later, but you can’t go the other way and sometimes people are too fast.\u003c/p\u003e\n\u003cp\u003eOutside of language design, the most general design principle a really thoughtful coworker had one trick: “Take it apart!” Like, this thing is causing you trouble, but it’s really two things. Think about how to untangle them and reason about them separately. It sounds like such generic advice, but it’s a really good lens to approach problems with.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIs there a special Clojure word for that?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eRich calls it “decomplecting.” He has a talk \u003ca href=\"https://www.youtube.com/watch?v=LKtk3HCgTa8\" rel=\"ugc\"\u003eSimple Made Easy\u003c/a\u003e but it wasn’t until I saw it in action through my coworker’s work that I truly appreciate what it means. Taking it apart’s the one trick for 90% of design problems.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you choose what problem to actually work on? Out of so many problems, so much information, fun things…\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLet me just take a step back. We’ve had the rise in the past 10,\n15 years of hosted languages, right? Clojure lives on the JVM. It’s not Java.\nIt uses the Java virtual machine, it compiles to Java bytecode, uses Java libraries.\nYou piggyback on this existing ecosystem, get a bunch of stuff for free. Clojure was one of, but not the first one to do it. I think \u003ca href=\"https://en.wikipedia.org/wiki/Adobe_ColdFusion\" rel=\"ugc\"\u003eColdFusion\u003c/a\u003e was the first I heard of. But with Clojure, I could see how compelling that that approach was. And today you have\nElixir, TypeScript, \u003ca href=\"https://gleam.run/\" rel=\"ugc\"\u003eGleam\u003c/a\u003e, \u003ca href=\"https://reasonml.github.io/\" rel=\"ugc\"\u003eReason\u003c/a\u003e and F-sharp. It’s really hard to build a language, to build a runtime, to build a library ecosystem, profilers, debuggers… If you can narrow down the work in front of you, without inventing the wheel everywhere, it’s amazing what you can accomplish. I love that about Fennel!\u003c/p\u003e\n\u003cp\u003eBut usually, when you have a hosted language, you have the VM completely in the other language, then the compiler converts from hosted into host language, then the runtime… In Clojure, when you define a function, it’s not just a Java method, it depends, extends this, uses some Clojure interface for callables… Data structures come with the host… And for Clojure, that’s the right choice for what it’s trying to accomplish.\u003c/p\u003e\n\u003cp\u003eBut Fennel just has the compiler. When you compile a Fennel function, you get a Lua function, nothing more, nothing less. Sharing runtime semantics exactly with your host language really reduces the scope of what you have to do. If it’s not a transformation you can do compile-time, we just say sorry. “What if Fennel had immutable data structures?” That’s never going to happen; it’s just a compiler. But we can point you to so and so library which provides them at run time.\u003c/p\u003e\n\u003cp\u003eNow, I have a conceptual space of features. For example, pattern matching, one of my favorites, what does it actually mean? I think it’s 2 orthogonal features: destructuring, pulling your data apart declaratively and binding local variables to it. That’s one axis. But destructuring can’t decide which path to take. So you have conditionals, and when you put them together you have pattern matching.\u003c/p\u003e\n\u003cp\u003e(Later insert: Peter van Roy’s \u003ca href=\"https://webperso.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng.pdf\" rel=\"ugc\"\u003eparadigm diagram\u003c/a\u003e is interesting. What others are there, exploring these concept spaces?)\u003c/p\u003e\n\u003cp\u003eSo if some new feature is made up of things already there, you’re not adding much burden to learning, being effective in it, even to the implementation. But if you add pattern matching to a language without destructuring, there’s a lot more to chew on. But if you already have destructuring, adding this little thing lets it make decisions for you, cool! So what’s the conceptual footprint of so and so feature? What space does it take up? If destructuring and conditionals are already allocated in the learner’s mind, pattern matching is free! Fennel’s list comprehensions are similar: If you already have loops and data structures, you’re just combining them. A loop can give you a sequential or associative data structure. We first added the sequential DS, which you use all the time. Then we wondered about adding one for key value DS as well, the operation’s not as common, so it’s not worth spending limited space in our conceptual tool box.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow did you first discover Fennel? Were you already like facing issues due to Lua’s design, looking for\nalternatives?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn my home directory, I have the \u003cstrong\u003egripe file\u003c/strong\u003e. A friend in IRC gave me the idea. You just collect all the problems, complaints you have. How could the programs I use on a regular basis be better? Sometimes you see something can added or improved and you can delete this line from the gripe file. I love it. For example, SSH wouldn’t let you specify a directory for your config files. But a few years later, I went back and saw they had! So I deleted it from the gripe file, which is a really cool feeling. I recommend you keep a gripes file.\u003c/p\u003e\n\u003cp\u003eFor Lua, if you typo the name of a variable, you can it’s local, but it ends up being a global and set or read it by accident. This makes sense, if you really want your scripts to be short and accessible, but I don’t think it’s the right choice because you can only catch it on runtime. You can use the LSP, linters but… Shouldn’t that just be in the language? So that goes in my gripe file. There are statements, not just expressions, another gripe! Lack of destructuring? Lack of pattern matching? Sure, Lua’s a small language, they had to draw the line somewhere, but it bugs me.\u003c/p\u003e\n\u003cp\u003eI began to look for alternatives and thought you could fix most of them with a Lisp! So I looked for Lisps on the Lua runtime, foud a few Schemes, an early, impressive Clojurescript prototype, but it wasn’t self hosted, depending on JVM stuff (to work on one runtime, requiring another 100 times bigger doesn’t feel great). I found a few one offs, but many like \u003ca href=\"https://urn-lang.com/\" rel=\"ugc\"\u003eUrn\u003c/a\u003e weren’t just syntactic transformations but included full standard libraries, which is cool, but I wanted something tiny, just a compiler.\u003c/p\u003e\n\u003cp\u003eSo I found \u003ca href=\"https://fennel-lang.org/\" rel=\"ugc\"\u003eFenne\u003c/a\u003el, a project Calvin Rose spent like a week on, then put to the side to work on another language from scratch, with his own virtual machine and everything. I think he was just more interested in how build a VM, how to solve tricky performance problems, whereas Lua’s already existed, but I wanted to explore the space around the language. So, Fennel was like a thousand lines of code and the core I wanted was visible. Excited, I started sending patches and asking him to clarify how it worked. I think he was really surprised that I was interested, really helpful and receptive! But he was more interested in this other language, DST at the time, renamed \u003ca href=\"https://janet-lang.org/\" rel=\"ugc\"\u003eJanet\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow’d that “handover” go? Some guy falls in love with some weekend side project and now people write games in it! How do you react to that?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI think he saw it as a warm up. He had some ideas and wanted to sketch them out, starting with an easier problem, just this compiler; now he’s working on what he really wants to do with a bytecode engine, I love that for him. But it’s like playing on hard mode, doing it all from scratch. But we don’t have as much flexibility in Fennel, to e.g. add immutable data structures, but we’re making the most of our niche.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you see the basic requirements and expectations of tooling changing? The hosted language helps with some of that already, but e.g. you made \u003ca href=\"https://leiningen.org/\" rel=\"ugc\"\u003eLeinigen\u003c/a\u003e, a build system for Clojure, while now Janet has JPM just built in. Most new languages appear with these kinds of things already, otherwise, people won’t touch them.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThere’re  different different categories of tooling, with runtime stuff like a profiler, in Fennel and Clojure you can use the profiles meant for Lua and Java. They work fine, though maybe you’ll see problems with source mapping? So another big win for hosted languages. But then you have things like LSP, where we have to do it ourselves. But we used a cheat code by making macros sandbox and we made that work a lot easier for us where you can just use the compiler instead of duplicating it like Clojure’s. But you’re hinting at this idea of libraries, the whole ecosystem. Fennel itself doesn’t have a solution for pulling in libraries\nand dependencies. Before, when working in Clojure that was one of the first things I did, because going into the JVM,\nyou see these deep dependency trees and the dependencies are even binary artifacts, right? But in other languages, you can just drop the source in and it’s less important to have a dependency manager that can\npull the versions you need. In Fennel, it’s viable to just drop the repositories you want and be done. But there are a few places that doesn’t work very well, like when you have libraries which depend on C code, where your make file has to invoke their make file and… But the Fennel programs I write rarely have more than a dozen (even transitive) dependencies and the majority are just one file! It just hasn’t felt like enough to build a whole manager around! But C code is also complicated, not uniform, so you can’t do a one size fits all solution. Now, someone is working on \u003ca href=\"https://andreyor.st/posts/2025-01-10-depsfnl-a-new-dependency-manager-for-fennel-projects/\" rel=\"ugc\"\u003edeps.fnl\u003c/a\u003e but I haven’t tried it myself.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI’m curious about pedagogy. You came to Lua to make things with your kids. You’re doing nand2tetris now with them. Fennel, Lua, games echo that writing basic in the 80s so many people did. But now with this with LLMs, we’re “pulling up the ladder”. How do I phrase this?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYeah, I love Fennel as a place to start learning because it’s so simple. You can learn the whole thing in a few days with a programming background. But as a fresh learner, it’s also a better place to start with fewer concepts, it fits in your head, so I love that. I don’t know what to say about AI though.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou mentioned the Fediverse before.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI mentioned picking projects with human impact and that’s the perfect example, digital independence, breaking the silos, giving people agency over their data etc. a way to allow people to take control of their own destiny with how they communicate. It’s inspiring seeing projects like Mastadon, but then \u003ca href=\"https://gotosocial.org/\" rel=\"ugc\"\u003eGoToSocial\u003c/a\u003e, \u003ca href=\"https://pleroma.social/\" rel=\"ugc\"\u003ePleroma\u003c/a\u003e, \u003ca href=\"https://akkoma.social/\" rel=\"ugc\"\u003eAkkoma\u003c/a\u003e, the ecosystem is really taking off. The Free Software Foundation, GNU project have these ideals but miss the opportunity to make impacts, too focused on licensing… While megacorps are treating their users quite badly, while using software on free licenses, which don’t make much of a difference. But the Fediverse shows another way. You really can build software which impacts people in a direct way! I’ve been working with GoToSocial to improve their documentation, test new features, but mostly I’m just a user. I’m really impressed with how easy it is to run and operate. It takes like 15 minutes to set up your own server and it just runs. I did Debian packaging for it too, so you can just do \u003ccode\u003eapt\u003c/code\u003e if you add \u003ca href=\"https://apt.technomancy.us/\" rel=\"ugc\"\u003emy repo\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTalking about empowering users, it’s really easy to take for granted the way package managers put this wealth of incredible software at your fingertips, just one command and boom! But my packaging won’t be upstreamed in Debian any time soon; I break a ton of rules because of versioning etc. It’s a very non-compliant package, but better than nothing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhy do you think ActivityPub got adoption where XMPP didn’t?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJust being in the right place at the right time? Mastodon was the poster child for ActivityPub\nand plain as day, you could see new signup spikes to Mastodon instances every time e.g.\nTwitter did something stupid. Just being there and not screwing up while others kept dropping the ball so hard, helps.\nEven before Musk, so many bad decisions, whether or not we’re kicking the Nazis off or whatever, almost comical. And they were just ready to take on these dissatisfied users.\u003c/p\u003e\n\u003cp\u003eWith XMPP, you had \u003ca href=\"https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish\" rel=\"ugc\"\u003eembrace, extend, extinguish\u003c/a\u003e situation where, Google went in with a big investment on XMPP, Facebook let you connect with XMPP… Then one day, \u003cem\u003eoh, we’re not doing that anymore\u003c/em\u003e. So suddenly you couldn’t talk to your friends, the whole reason you were there. I think we were a little naive to think Google showing up and investing was a good thing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI strongly empathize with your packaging woes. I tried to help a project with it but failed, burned out.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI helped with the packaging of Fennel too. It was like night and day because we have one\ndependency and one or two files, a man page and an executable. But as soon as you start pulling in these complex dependencies, multiple Go or C libraries, you have to be an expert in Debian packaging to\nto pull that off. Even with Fennel, we stubbed our toe and it took like six months of back and forth.\u003c/p\u003e\n","description_plain":"I am resurrecting [Lobsters interviews](https://lobste.rs/t/interview). Although the interview becoming the next interviewer is a really cool conceit, it didn't pan out for longevity.\r\n\r\nThis is the result of one and a half hours talking to [technomancy](https://lobste.rs/~technomancy). ([Icefox](https://lobste.rs/~icefox) and [hwayne](https://lobste.rs/~hwayne) are next.)\r\n\r\n----\r\n\r\n**Past interviews started off with introducing yourself, what do you do for work etc. But you're not so interested in your work-work.**\r\n\r\nI started programming as a kid, but fell off the wagon for a while. In college, I got back into it, and around graduation, around 2004, got really into Ruby, at its inflection point. I didn't exactly get tired of it, but my eye caught something shinier with Clojure and functional programming, which was really in around 2008-9. Like, everyone saw Moore's law tapering off and thought of functional programming as the solution, the way forward. Now, I'm still doing that professionally but I got disillusioned with...\r\n\r\n**You once mentioned it wasn't meant for hobby projects, everything added's for corporate use**\r\n\r\nYeah, I guess to take a step even further back, I got really interested in the free software movement, kind of idealistic in this idea that you could make the world a better place with software! And open\r\nsource, because I felt like that was the same thing. The idea was by picking the right\r\nlicense you can write software that makes the world better, which doesn't actually make any\r\nsense because like, what is the software doing? Without more analysis, people think they're like being altruistic, developing open source and it ends up just being free labor for companies to exploit. So I got disillusioned with the JVM in terms of that. Like, if I'm going to get paid for it, it's fine.\r\n\r\nBut it's really good at solving problems companies have, not humans. So I wanted to change how I was going to spend my free time. From there, I got really into Lua, playing around, making games with my kids, using love2D, for 3-4 years. But then I found this compiler Fennel that applied what I learned in Clojure to Lua. I eventually took over the project and been running it since since then. That's where most of my headspace is right now.\r\n\r\n**Was what took you away from Ruby similar to what pulled you from Clojure?**\r\n\r\nNo, with Lua, I wanted to deliberately step back from the corporate world, which didn't play into leaving Ruby before. But there are some similarities. I got into both when they were hitting their inflection points. You really [had to be there](https://www.youtube.com/watch?v=jTurIBwz0mY) in 2004 with Ruby or 2008 with Clojure. No one would do it because they thought it was good for their career, but because you just really wanted to learn more and expand your horizons. It was like the reason I came didn't apply anymore, this is mature, I've learned a lot from this, but I don't feel like I'm learning anymore.\r\n\r\n**You mentioned the Moore's loss stopping, slowing down. Maybe 5 or 8years after, I personally noticed it, which pushed me in the other direction of _wait, all these functional things like map, we're wasting all these cycles. Maybe we shouldn't be doing that._** \r\n\r\nIt's an interesting tension, right? The zeitgeist was like, if Moore's law's slowing down \r\nit wasn't that computer's wouldn't be more capable, but where would the capability come from? Going wide, adding more cores, scaling out instead of up, right? Until that point, in the the 90s and early 2000s, it was like, boom, boom, boom, \r\nour clock speeds were just going higher and higher. That's what stopped.\r\n\r\nNow, we were doing largely server side programs, so each server was going to have more cores and you'd throw in more\r\nservers. Erlang got a big boost in popularity. Relatively, for the niche nerds. But we thought _this is the future_. If you make it easier to spread out across multiple processes, you're not going to not hit this problem. You're not going\r\nto run into a wall. That resonated a lot with people and kicked off interest in algorithms that are easy to paralyze, which you get for free with immutable data. So functional programming\r\nbecame a lot more appealing, but as you mentioned, there's also overhead.\r\nIf you can override a value in place, that's faster than than making a\r\na functional update. There's a place where that overhead won't make sense, especially in the context of a single core, running on a more constrained hardware, maybe on mobile or on your laptop, you're not going to want to just\r\nthrow more cores at it in the same way. \r\n\r\n**So it actually fits with the human vs. business related software.**\r\n\r\nYeah. You you want to pay more attention to efficiency. If you're if you're a startup with all this investor money,\r\nand the community in the late 2000s had all this investor money sloshing around, you can solve your problem by throwing\r\nmore cores at it. I think ironically, the wave of interest in functional\r\nprogramming didn't end up... Maybe I'm extrapolating here, but even imperative languages, you're going to run in a\r\nsimilar way. You're going to run a bunch of processes behind a load balancer and the point of\r\nsynchronization is going to be the database anyway. So using a\r\nfunctional language isn't necessarily going to make it easier for you to go wide on that.\r\nIf you're tied to a request response cycle, then your load balancer is going to do\r\nthe job for you. And everything's web based, so you're almost always tied to a request\r\nresponse cycle.\r\n\r\nThere are exceptions. If you want to keep one socket open for an extended period of time, which Erlang handles more gracefully, that is really hard to do with a load balancer. But when you're dealing with everything going over HTTP, it's not really the silver bullet we expected.\r\n\r\n**What's your workspace and computing environment like? We've talked about this on [IRC](https://lobste.rs/chat), about decks and keyboards.**\r\n\r\nMy main machine is what I call a [ThinkPad fanfic](https://blog.mattgauger.com/2022/08/01/the-51nb-x210/), takes a chassis of a ThinkPad from like 2009. This hacker collective\r\nin Shenzhen redesigned the motherboard with a more modern CPU and architecture, which fits right into that. \r\nThe screen's a little dim, but everything else is great, the replaceable battery, old school ThinkPad keyboard.\r\n\r\nBut the majority of the time I'm using the keyboard I designed myself [the Atreus](https://atreus.technomancy.us/) with 42 in the original, 44 keys now, with each side angled to match where your hands are. But really portable because I,\r\nI love going out all the time, at least a couple times a week to coffee shops or when weather's nicer, a park or something. I got the original Ergo Docs and I loved it. At home, it felt so good, but then pulling it out with all the wires at the coffee shops...\r\n\r\nIn my office, I have an older ThinkPad with two portrait display monitors and a big old Kensington track ball, almost a billiard ball size. I like that a lot. But I prefer keyboard shortcuts. I use Emacs. And then there're surfing keys in the browser extension I use to highlight links so I can visit the links with the keyboard. That's pretty nice.\r\n\r\n**Do you have your Emacs config online somewhere?**\r\n\r\nYeah, [all my dot files](https://git.sr.ht/~technomancy/dotfiles) are together. Emacs and everything else. Yeah. But \r\n\r\n\r\nI use Emacs as my window manager using [exWM](https://github.com/emacs-exwm/exwm) so every program running in Xorg is shown as if it was an Emacs buffer. So your regular Emacs screen splits instead of having text files inside of them. There's Firefox, your terminal, whatever else.\r\n\r\n**Did Emacs come before closure or vice versa?**\r\n\r\nI started with Emacs in in university. I had just learned Dvorak and was like, now Vim or Emacs? In Vim, HKJL are all lined up for QWERTY and... forget it. So Emacs and Elisp.\r\n\r\nWhen I started thinking about functional languages,\r\na lot of people were talking about Haskell and Erlang, but _I liked this Lisp thing_.\r\n\r\n**Did you have any favorite courses or such? Like in some corners,\r\npeople love to obsess over SICP.**\r\n\r\nMy CS program wasn't really great. I learned more from all the hacking I did to get Linux working on a laptop in 2003 than in classes. But recently I've been working through this book called Elements of Computing Systems, [nand2tetris](https://www.nand2tetris.org/), with my kids, in upper high school. I was trying to stay ahead of them, but it's summer. There's no way I can do that. But I like how every step is built on the previous step; you can't use anything until you've derived it from first principles. And how far can that approach get you? It turns out pretty far!\r\n\r\n\r\n**Did you discover Lua games through programming with your kids or making games for, with them? When you first had kids, did you think oh I love programming and need to share it?**\r\n\r\nYeah. I think it's normal to want to share what you're interested in, with the kids and especially if they show interest and get on board. And games are just such a great way to learn, in general. It's easy to get people and kids' attention with games. And they're curious __how did they do that? Let's take a look.__ So we first started in [Scratch](https://scratch.mit.edu/), a drag and drop programming environment which is great for younger kids.\r\nYou don't have to know how to type but it still lets you do step by step algorithms etc. And more importantly, if it doesn't work the way expected, it teaches you how to debug that and how to break the problem apart and try to find e.g. where you didn't quite cover all the bases or whatever.\r\n\r\nOne of the coolest things about scratch is that when you publish something, anyone else can view source, how was it made, and then more importantly remix, like make a copy you can edit yourself and change, to, you know, make the characters move faster or see what happens when the shots are fired at a different angle. Experimenting is amazing when you're trying to explore the world of how software works. I wish everything would work like that. It's really empowering.\r\n\r\n\r\nOne of my more recent projects is [fedibot.club](https://fedibot.club/) where you can you can create these scripts that get tied into social media bots, to run either on a schedule or in response to replies and your script and do whatever.\r\nAnd this is really, really fun, just as kind of a toy to mess around with social media, but also great fit for\r\nLua because Lua makes it really easy to sandbox code and limit what you have access to,\r\nto make sure one person can't write a script that will take the whole system down.\r\n\r\nThen on top of that, I was able to add this same remix ability. So when you see one of these bots, maybe they'll\r\nhave a link in their bio to the source. You go to their source code, log in and boom, you test it, change it, do something a little different!  I really admired Scratch and its model of view source. View source is so important for learning how to program, how a technique is done. You shouldn't have to go search on GitHub then clone it, it should be right there, on your fingertips. Being able to read it isn't really enough because there're limits to how reading code without executing it.\r\n\r\n(Later insert, today on IRC, he said:)\r\n\r\n\u003e Using emacs is praxis because it gives people a view into how computing should be; view-source on every command, immediately rewrite things to work the way you want.\r\n\r\n\r\nI feel we don't understand this very well from a scientific perspective. Why is this\r\ntrue? For most things, you can just read a book and understand it. But reading a piece of code,\r\ninteracting with it, running, modifying it, those are so different! In terms of how you experience them and how it affects your understanding of the problem.\r\n\r\nThere's a really great paper on this called [Programming as Theory Building](https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1). It doesn't even try to explain why, which is kind of funny. But it goes and talks about the implications of when you understanding. When you have a piece of code, what you really have, what's really valuable is not the code, but the the knowledge in heads of the people developing it. That's what you're building. The code is almost a side effect of that. Once you have the theory about how the system works, the code itself is not that big of a deal. A lot people don't understand that about working on a team and building programs. \r\n\r\n**How do you actually approach modeling? Like, you have a problem. What do you do with it?**\r\n\r\nSo with Fennel, I'm doing language design. And one most important skills for language design is just having enough imagination to try to think of all the ways how five years from now, we could be looking back on this, wishing if only we had known better and not done this. If you have an idea, what are the ways you'll potentially regret it? It's really hard and I think it can only come from experience.\r\n\r\nEveryone's really leaning into language server protocol nowadays, right? You have this kind of\r\nstandardized tooling, which enables certain analysis on on your project, when you made a mistake immediately instead of having to wait. \r\nI was a skeptic. but I've been won over. But it's very difficult to do this safely. In Clojure, if you want to run the language server on a program or a file, you don't want to compile the program because in Clojure compiling it runs it, which isn't uncommon in dynamic languages. Obviously, the problem's that you don't know if you trust the code. And how do you know if you\r\nshould trust the code? By opening it up in your editor and reading it! But opening it up runs it? A chicken and egg problem. A lot of language servers just don't care and run it anyway, which is really bad. I thought Clojure would too, because it's so dynamic, but they built out a completely separate static analysis tool in the language server that does the job of the compiler, redundantly, safely, because it won't to try to expand the macros. That's great, the right choice with Clojure.\r\n\r\nBut it sucks to not expand your macros. Sometimes the macro will introduce a new local variable and you... don't see where it comes from, it looks like an error. So what can we learn from this experience? How can we run macros in a safe way? Well, why should a macro be able to write to disk, to open a network connection? That doesn't make any sense. No one writes macros with legitimate reasons to open a network connection.\r\n\r\n**I totally do. I love to use macros to prepare the environments, download data and compile with those.**\r\n\r\nYeah, there are legitimate use cases to read from disc, but to write to disk, to send... Even if you do allow writes, never outside the project directory! But it's too late for Clojure, hundreds of thousands have been written. But Fennel didn't have a macro system yet. Okay, so macros are like functions; they take and produce ASTs. There's no reason to be able to do output anything else. So we made our macro system work that way, so the Fennel language server doesn't have the problem Clojure's has, even though there's a a tiny amount of comparative effort in this system. It's smaller, with less resources, but capable of more because we learned from the situation.\r\n\r\nThe commitment to backwards compatibility is hard. Sometimes you have to stick with these decisions you don't like. And how can you avoid that, really learn from your own mistakes or learn from someone else's mistakes? I like defaulting to saying no until you've really got the chance to think it all the way through. We can do what we're confident now and extend later, but you can't go the other way and sometimes people are too fast.\r\n\r\nOutside of language design, the most general design principle a really thoughtful coworker had one trick: \"Take it apart!\" Like, this thing is causing you trouble, but it's really two things. Think about how to untangle them and reason about them separately. It sounds like such generic advice, but it's a really good lens to approach problems with.\r\n\r\n**Is there a special Clojure word for that?**\r\n\r\nRich calls it \"decomplecting.\" He has a talk [Simple Made Easy](https://www.youtube.com/watch?v=LKtk3HCgTa8) but it wasn't until I saw it in action through my coworker's work that I truly appreciate what it means. Taking it apart's the one trick for 90% of design problems.\r\n\r\n**How do you choose what problem to actually work on? Out of so many problems, so much information, fun things...**\r\n\r\nLet me just take a step back. We've had the rise in the past 10,\r\n15 years of hosted languages, right? Clojure lives on the JVM. It's not Java.\r\nIt uses the Java virtual machine, it compiles to Java bytecode, uses Java libraries.\r\nYou piggyback on this existing ecosystem, get a bunch of stuff for free. Clojure was one of, but not the first one to do it. I think [ColdFusion](https://en.wikipedia.org/wiki/Adobe_ColdFusion) was the first I heard of. But with Clojure, I could see how compelling that that approach was. And today you have\r\nElixir, TypeScript, [Gleam](https://gleam.run/), [Reason](https://reasonml.github.io/) and F-sharp. It's really hard to build a language, to build a runtime, to build a library ecosystem, profilers, debuggers... If you can narrow down the work in front of you, without inventing the wheel everywhere, it's amazing what you can accomplish. I love that about Fennel!\r\n\r\nBut usually, when you have a hosted language, you have the VM completely in the other language, then the compiler converts from hosted into host language, then the runtime... In Clojure, when you define a function, it's not just a Java method, it depends, extends this, uses some Clojure interface for callables... Data structures come with the host... And for Clojure, that's the right choice for what it's trying to accomplish.\r\n\r\nBut Fennel just has the compiler. When you compile a Fennel function, you get a Lua function, nothing more, nothing less. Sharing runtime semantics exactly with your host language really reduces the scope of what you have to do. If it's not a transformation you can do compile-time, we just say sorry. \"What if Fennel had immutable data structures?\" That's never going to happen; it's just a compiler. But we can point you to so and so library which provides them at run time.\r\n\r\nNow, I have a conceptual space of features. For example, pattern matching, one of my favorites, what does it actually mean? I think it's 2 orthogonal features: destructuring, pulling your data apart declaratively and binding local variables to it. That's one axis. But destructuring can't decide which path to take. So you have conditionals, and when you put them together you have pattern matching.\r\n\r\n\r\n(Later insert: Peter van Roy's [paradigm diagram](https://webperso.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng.pdf) is interesting. What others are there, exploring these concept spaces?)\r\n\r\nSo if some new feature is made up of things already there, you're not adding much burden to learning, being effective in it, even to the implementation. But if you add pattern matching to a language without destructuring, there's a lot more to chew on. But if you already have destructuring, adding this little thing lets it make decisions for you, cool! So what's the conceptual footprint of so and so feature? What space does it take up? If destructuring and conditionals are already allocated in the learner's mind, pattern matching is free! Fennel's list comprehensions are similar: If you already have loops and data structures, you're just combining them. A loop can give you a sequential or associative data structure. We first added the sequential DS, which you use all the time. Then we wondered about adding one for key value DS as well, the operation's not as common, so it's not worth spending limited space in our conceptual tool box.\r\n\r\n\r\n**How did you first discover Fennel? Were you already like facing issues due to Lua's design, looking for\r\nalternatives?**\r\n\r\nIn my home directory, I have the **gripe file**. A friend in IRC gave me the idea. You just collect all the problems, complaints you have. How could the programs I use on a regular basis be better? Sometimes you see something can added or improved and you can delete this line from the gripe file. I love it. For example, SSH wouldn't let you specify a directory for your config files. But a few years later, I went back and saw they had! So I deleted it from the gripe file, which is a really cool feeling. I recommend you keep a gripes file. \r\n\r\nFor Lua, if you typo the name of a variable, you can it's local, but it ends up being a global and set or read it by accident. This makes sense, if you really want your scripts to be short and accessible, but I don't think it's the right choice because you can only catch it on runtime. You can use the LSP, linters but... Shouldn't that just be in the language? So that goes in my gripe file. There are statements, not just expressions, another gripe! Lack of destructuring? Lack of pattern matching? Sure, Lua's a small language, they had to draw the line somewhere, but it bugs me. \r\n\r\nI began to look for alternatives and thought you could fix most of them with a Lisp! So I looked for Lisps on the Lua runtime, foud a few Schemes, an early, impressive Clojurescript prototype, but it wasn't self hosted, depending on JVM stuff (to work on one runtime, requiring another 100 times bigger doesn't feel great). I found a few one offs, but many like [Urn](https://urn-lang.com/) weren't just syntactic transformations but included full standard libraries, which is cool, but I wanted something tiny, just a compiler.\r\n\r\nSo I found [Fenne](https://fennel-lang.org/)l, a project Calvin Rose spent like a week on, then put to the side to work on another language from scratch, with his own virtual machine and everything. I think he was just more interested in how build a VM, how to solve tricky performance problems, whereas Lua's already existed, but I wanted to explore the space around the language. So, Fennel was like a thousand lines of code and the core I wanted was visible. Excited, I started sending patches and asking him to clarify how it worked. I think he was really surprised that I was interested, really helpful and receptive! But he was more interested in this other language, DST at the time, renamed [Janet](https://janet-lang.org/).\r\n\r\n**How'd that \"handover\" go? Some guy falls in love with some weekend side project and now people write games in it! How do you react to that?**\r\n\r\nI think he saw it as a warm up. He had some ideas and wanted to sketch them out, starting with an easier problem, just this compiler; now he's working on what he really wants to do with a bytecode engine, I love that for him. But it's like playing on hard mode, doing it all from scratch. But we don't have as much flexibility in Fennel, to e.g. add immutable data structures, but we're making the most of our niche.\r\n\r\n\r\n**How do you see the basic requirements and expectations of tooling changing? The hosted language helps with some of that already, but e.g. you made [Leinigen](https://leiningen.org/), a build system for Clojure, while now Janet has JPM just built in. Most new languages appear with these kinds of things already, otherwise, people won't touch them.**\r\n\r\n\r\nThere're  different different categories of tooling, with runtime stuff like a profiler, in Fennel and Clojure you can use the profiles meant for Lua and Java. They work fine, though maybe you'll see problems with source mapping? So another big win for hosted languages. But then you have things like LSP, where we have to do it ourselves. But we used a cheat code by making macros sandbox and we made that work a lot easier for us where you can just use the compiler instead of duplicating it like Clojure's. But you're hinting at this idea of libraries, the whole ecosystem. Fennel itself doesn't have a solution for pulling in libraries\r\nand dependencies. Before, when working in Clojure that was one of the first things I did, because going into the JVM,\r\nyou see these deep dependency trees and the dependencies are even binary artifacts, right? But in other languages, you can just drop the source in and it's less important to have a dependency manager that can\r\npull the versions you need. In Fennel, it's viable to just drop the repositories you want and be done. But there are a few places that doesn't work very well, like when you have libraries which depend on C code, where your make file has to invoke their make file and... But the Fennel programs I write rarely have more than a dozen (even transitive) dependencies and the majority are just one file! It just hasn't felt like enough to build a whole manager around! But C code is also complicated, not uniform, so you can't do a one size fits all solution. Now, someone is working on [deps.fnl](https://andreyor.st/posts/2025-01-10-depsfnl-a-new-dependency-manager-for-fennel-projects/) but I haven't tried it myself.\r\n\r\n**I'm curious about pedagogy. You came to Lua to make things with your kids. You're doing nand2tetris now with them. Fennel, Lua, games echo that writing basic in the 80s so many people did. But now with this with LLMs, we're \"pulling up the ladder\". How do I phrase this?**\r\n\r\nYeah, I love Fennel as a place to start learning because it's so simple. You can learn the whole thing in a few days with a programming background. But as a fresh learner, it's also a better place to start with fewer concepts, it fits in your head, so I love that. I don't know what to say about AI though.\r\n\r\n**You mentioned the Fediverse before.**\r\n\r\nI mentioned picking projects with human impact and that's the perfect example, digital independence, breaking the silos, giving people agency over their data etc. a way to allow people to take control of their own destiny with how they communicate. It's inspiring seeing projects like Mastadon, but then [GoToSocial](https://gotosocial.org/), [Pleroma](https://pleroma.social/), [Akkoma](https://akkoma.social/), the ecosystem is really taking off. The Free Software Foundation, GNU project have these ideals but miss the opportunity to make impacts, too focused on licensing... While megacorps are treating their users quite badly, while using software on free licenses, which don't make much of a difference. But the Fediverse shows another way. You really can build software which impacts people in a direct way! I've been working with GoToSocial to improve their documentation, test new features, but mostly I'm just a user. I'm really impressed with how easy it is to run and operate. It takes like 15 minutes to set up your own server and it just runs. I did Debian packaging for it too, so you can just do `apt` if you add [my repo](https://apt.technomancy.us/).\r\n\r\nTalking about empowering users, it's really easy to take for granted the way package managers put this wealth of incredible software at your fingertips, just one command and boom! But my packaging won't be upstreamed in Debian any time soon; I break a ton of rules because of versioning etc. It's a very non-compliant package, but better than nothing.\r\n\r\n**Why do you think ActivityPub got adoption where XMPP didn't?**\r\n\r\nJust being in the right place at the right time? Mastodon was the poster child for ActivityPub\r\nand plain as day, you could see new signup spikes to Mastodon instances every time e.g.\r\nTwitter did something stupid. Just being there and not screwing up while others kept dropping the ball so hard, helps.\r\nEven before Musk, so many bad decisions, whether or not we're kicking the Nazis off or whatever, almost comical. And they were just ready to take on these dissatisfied users.\r\n\r\nWith XMPP, you had [embrace, extend, extinguish](https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish) situation where, Google went in with a big investment on XMPP, Facebook let you connect with XMPP... Then one day, _oh, we're not doing that anymore_. So suddenly you couldn't talk to your friends, the whole reason you were there. I think we were a little naive to think Google showing up and investing was a good thing.\r\n\r\n**I strongly empathize with your packaging woes. I tried to help a project with it but failed, burned out.**\r\n\r\nI helped with the packaging of Fennel too. It was like night and day because we have one\r\ndependency and one or two files, a man page and an executable. But as soon as you start pulling in these complex dependencies, multiple Go or C libraries, you have to be an expert in Debian packaging to\r\nto pull that off. Even with Fennel, we stubbed our toe and it took like six months of back and forth.","submitter_user":"veqq","user_is_author":true,"tags":["interview","person"],"short_id_url":"https://lobste.rs/s/terwiu","comments_url":"https://lobste.rs/s/terwiu/lobsters_interview_with_technomancy"},{"short_id":"6qe3ml","created_at":"2025-07-25T16:02:31.000-05:00","title":"Nullable but not null","url":"https://efe.me/posts/nullable-but-not-null/","score":7,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"tsg","user_is_author":false,"tags":["databases"],"short_id_url":"https://lobste.rs/s/6qe3ml","comments_url":"https://lobste.rs/s/6qe3ml/nullable_not_null"},{"short_id":"3uemyk","created_at":"2025-07-25T15:55:55.000-05:00","title":"Rust running on every major GPU platform","url":"https://rust-gpu.github.io/blog/2025/07/25/rust-on-every-gpu/","score":25,"flags":0,"comment_count":2,"description":"","description_plain":"","submitter_user":"moony","user_is_author":false,"tags":["graphics","rust"],"short_id_url":"https://lobste.rs/s/3uemyk","comments_url":"https://lobste.rs/s/3uemyk/rust_running_on_every_major_gpu_platform"},{"short_id":"dxhuqb","created_at":"2025-07-25T14:53:06.000-05:00","title":"Bringing a Decade Old Bicycle Navigator Back to Life with Open Source Software (and DOOM)","url":"https://raymii.org/s/blog/Bringing_a_Decade_Old_Bicycle_Navigator_Back_to_Life_with_Open_Source_Software_and_DOOM.html","score":19,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"raymii","user_is_author":true,"tags":["hardware","reversing"],"short_id_url":"https://lobste.rs/s/dxhuqb","comments_url":"https://lobste.rs/s/dxhuqb/bringing_decade_old_bicycle_navigator"},{"short_id":"oy0cov","created_at":"2025-07-25T14:04:00.000-05:00","title":"Efficient Computer's Electron E1 CPU - claims 100x more efficient than ARM","url":"https://morethanmoore.substack.com/p/efficient-computers-electron-e1-cpu","score":28,"flags":0,"comment_count":15,"description":"","description_plain":"","submitter_user":"mpweiher","user_is_author":false,"tags":["hardware"],"short_id_url":"https://lobste.rs/s/oy0cov","comments_url":"https://lobste.rs/s/oy0cov/efficient_computer_s_electron_e1_cpu"},{"short_id":"ljvdv9","created_at":"2025-07-25T13:27:18.000-05:00","title":"Monotonic and Wall Clock Time in the Go time package","url":"https://victoriametrics.com/blog/go-time-monotonic-wall-clock/","score":13,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"ohrv","user_is_author":false,"tags":["go"],"short_id_url":"https://lobste.rs/s/ljvdv9","comments_url":"https://lobste.rs/s/ljvdv9/monotonic_wall_clock_time_go_time_package"},{"short_id":"ubtloo","created_at":"2025-07-25T12:30:50.000-05:00","title":"Implementing VisiCalc","url":"https://rmf.vc/public/Essays/ImplementingVisicalc.pdf","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"quzyx","user_is_author":false,"tags":["historical","pdf"],"short_id_url":"https://lobste.rs/s/ubtloo","comments_url":"https://lobste.rs/s/ubtloo/implementing_visicalc"}]