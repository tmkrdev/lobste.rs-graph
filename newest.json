[{"short_id":"1dwwse","created_at":"2025-09-13T01:15:45.000-05:00","title":"Delphi 13 Florence released","url":"https://blogs.embarcadero.com/announcing-the-availability-of-rad-studio-13-florence/","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"raymii","user_is_author":false,"tags":["programming","release"],"short_id_url":"https://lobste.rs/s/1dwwse","comments_url":"https://lobste.rs/s/1dwwse/delphi_13_florence_released"},{"short_id":"iuvpa7","created_at":"2025-09-13T00:42:10.000-05:00","title":"Adding FRM parser utility to MariaDB","url":"https://hp77-creator.github.io","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"hp77","user_is_author":true,"tags":["databases"],"short_id_url":"https://lobste.rs/s/iuvpa7","comments_url":"https://lobste.rs/s/iuvpa7/adding_frm_parser_utility_mariadb"},{"short_id":"hh07fn","created_at":"2025-09-12T22:04:03.000-05:00","title":"Basics of Equality Saturation","url":"https://egglog-python.readthedocs.io/latest/tutorials/tut_1_basics.html","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"saulshanabrook","user_is_author":true,"tags":["compilers","plt","python"],"short_id_url":"https://lobste.rs/s/hh07fn","comments_url":"https://lobste.rs/s/hh07fn/basics_equality_saturation"},{"short_id":"4xb9m9","created_at":"2025-09-12T21:06:11.000-05:00","title":"I Vibe Coded an R Package and it ... actually works?!?","url":"https://jcarroll.com.au/2025/09/13/i-vibe-coded-an-r-package/","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"jonocarroll","user_is_author":true,"tags":["programming","vibecoding"],"short_id_url":"https://lobste.rs/s/4xb9m9","comments_url":"https://lobste.rs/s/4xb9m9/i_vibe_coded_r_package_it_actually_works"},{"short_id":"ifdi6q","created_at":"2025-09-12T18:01:42.000-05:00","title":"Tips for installing Windows 98 in QEMU/UTM","url":"https://sporks.space/2025/08/28/tips-for-installing-windows-98-in-qemu-utm/","score":5,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"calvin","user_is_author":true,"tags":["ios","retrocomputing","windows"],"short_id_url":"https://lobste.rs/s/ifdi6q","comments_url":"https://lobste.rs/s/ifdi6q/tips_for_installing_windows_98_qemu_utm"},{"short_id":"cbppr8","created_at":"2025-09-12T17:41:41.000-05:00","title":"Looking back at Steve Jobs's NeXT, Inc — the most successful failure ever","url":"https://appleinsider.com/articles/25/09/12/looking-back-at-steve-jobss-next-inc----the-most-successful-failure-ever","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"clerno","user_is_author":false,"tags":["mac"],"short_id_url":"https://lobste.rs/s/cbppr8","comments_url":"https://lobste.rs/s/cbppr8/looking_back_at_steve_jobs_s_next_inc_most"},{"short_id":"mlbsfi","created_at":"2025-09-12T17:33:38.000-05:00","title":"UTF-8 is a Brilliant Design","url":"https://iamvishnu.com/posts/utf8-is-brilliant-design","score":12,"flags":0,"comment_count":9,"description":"","description_plain":"","submitter_user":"clerno","user_is_author":false,"tags":["programming"],"short_id_url":"https://lobste.rs/s/mlbsfi","comments_url":"https://lobste.rs/s/mlbsfi/utf_8_is_brilliant_design"},{"short_id":"pwkci6","created_at":"2025-09-12T15:59:25.000-05:00","title":"meow: Yet another modal editing on Emacs","url":"https://github.com/meow-edit/meow","score":7,"flags":0,"comment_count":1,"description":"","description_plain":"","submitter_user":"GrayGnome","user_is_author":false,"tags":["emacs"],"short_id_url":"https://lobste.rs/s/pwkci6","comments_url":"https://lobste.rs/s/pwkci6/meow_yet_another_modal_editing_on_emacs"},{"short_id":"lklsdx","created_at":"2025-09-12T14:46:56.000-05:00","title":"ZFS snapshots aren't as immutable as I thought, due to snapshot metadata","url":"https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSSnapshotsNotFullyImmutable","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"dryya","user_is_author":false,"tags":["linux"],"short_id_url":"https://lobste.rs/s/lklsdx","comments_url":"https://lobste.rs/s/lklsdx/zfs_snapshots_aren_t_as_immutable_as_i"},{"short_id":"jeequi","created_at":"2025-09-12T14:15:15.000-05:00","title":"DWS OS, a Plan 9 Inspired Web “OS”","url":"https://dws.rip","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"iv","user_is_author":false,"tags":["osdev"],"short_id_url":"https://lobste.rs/s/jeequi","comments_url":"https://lobste.rs/s/jeequi/dws_os_plan_9_inspired_web_os"},{"short_id":"j4zqc7","created_at":"2025-09-12T14:10:28.000-05:00","title":"Grimoire CSS - flexible utility class tool","url":"https://grimoirecss.com/","score":5,"flags":0,"comment_count":6,"description":"","description_plain":"","submitter_user":"raffomania","user_is_author":false,"tags":["css","design"],"short_id_url":"https://lobste.rs/s/j4zqc7","comments_url":"https://lobste.rs/s/j4zqc7/grimoire_css_flexible_utility_class_tool"},{"short_id":"glkaup","created_at":"2025-09-12T13:58:29.000-05:00","title":"Why (special agent) Johnny (still) Can't Encrypt (2011)","url":"https://www.mattblaze.org/blog/p25","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"fcbsd","user_is_author":false,"tags":["cryptography","security"],"short_id_url":"https://lobste.rs/s/glkaup","comments_url":"https://lobste.rs/s/glkaup/why_special_agent_johnny_still_can_t"},{"short_id":"aisi4g","created_at":"2025-09-12T13:42:55.000-05:00","title":"Normal-order Syntax-Rules","url":"https://www.youtube.com/watch?v=MZBklDFpSAE","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"veqq","user_is_author":false,"tags":["lisp","video"],"short_id_url":"https://lobste.rs/s/aisi4g","comments_url":"https://lobste.rs/s/aisi4g/normal_order_syntax_rules"},{"short_id":"t3wns0","created_at":"2025-09-12T12:55:54.000-05:00","title":"What Happens After I'm Gone? The Future of the Online Me","url":"https://btxx.org/posts/planning-ahead/","score":15,"flags":0,"comment_count":4,"description":"","description_plain":"","submitter_user":"bt","user_is_author":true,"tags":["philosophy","web"],"short_id_url":"https://lobste.rs/s/t3wns0","comments_url":"https://lobste.rs/s/t3wns0/what_happens_after_i_m_gone_future_online"},{"short_id":"l29jeg","created_at":"2025-09-12T12:31:46.000-05:00","title":"Advanced Scheme:  Some Naughty Bits","url":"https://people.csail.mit.edu//jhbrown/scheme/","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"veqq","user_is_author":false,"tags":["lisp"],"short_id_url":"https://lobste.rs/s/l29jeg","comments_url":"https://lobste.rs/s/l29jeg/advanced_scheme_some_naughty_bits"},{"short_id":"5p6h8u","created_at":"2025-09-12T11:37:00.000-05:00","title":"From 19k to 4.2M events/sec: story of a SQLite query optimisation","url":"https://mnt.io/articles/from-19k-to-4-2m-events-per-sec-story-of-a-sqlite-query-optimisation/","score":12,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"sknebel","user_is_author":false,"tags":["databases","performance"],"short_id_url":"https://lobste.rs/s/5p6h8u","comments_url":"https://lobste.rs/s/5p6h8u/from_19k_4_2m_events_sec_story_sqlite_query"},{"short_id":"ox0igt","created_at":"2025-09-12T11:35:07.000-05:00","title":"Early Bytes of Creativity – Forgotten Mainframe Games, Part I (2023)","url":"https://zeitgame.net/archives/9902","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"kidon","user_is_author":false,"tags":["games","historical"],"short_id_url":"https://lobste.rs/s/ox0igt","comments_url":"https://lobste.rs/s/ox0igt/early_bytes_creativity_forgotten"},{"short_id":"fb75eb","created_at":"2025-09-12T11:12:28.000-05:00","title":"open-edison: An MCP Gateway to block Simon Willison's Lethal Trifecta","url":"https://github.com/Edison-Watch/open-edison","score":3,"flags":2,"comment_count":0,"description":"","description_plain":"","submitter_user":"76SlashDolphin","user_is_author":true,"tags":["ai","security"],"short_id_url":"https://lobste.rs/s/fb75eb","comments_url":"https://lobste.rs/s/fb75eb/open_edison_mcp_gateway_block_simon"},{"short_id":"agb3ht","created_at":"2025-09-12T11:07:31.000-05:00","title":"GraalVM's secret LLVM backend","url":"https://www.praj.in/posts/2020/graalvms-secret-llvm-backend/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"aarroyoc","user_is_author":false,"tags":["compilers"],"short_id_url":"https://lobste.rs/s/agb3ht","comments_url":"https://lobste.rs/s/agb3ht/graalvm_s_secret_llvm_backend"},{"short_id":"2ookth","created_at":"2025-09-12T10:54:15.000-05:00","title":"Center for the Alignment of AI Alignment Centers","url":"https://alignmentalignment.ai","score":16,"flags":0,"comment_count":2,"description":"","description_plain":"","submitter_user":"WilhelmVonWeiner","user_is_author":false,"tags":["ai","satire"],"short_id_url":"https://lobste.rs/s/2ookth","comments_url":"https://lobste.rs/s/2ookth/center_for_alignment_ai_alignment"},{"short_id":"bzzwb7","created_at":"2025-09-12T10:35:19.000-05:00","title":"Phishing campaign targeting crates.io users","url":"https://blog.rust-lang.org/2025/09/12/crates-io-phishing-campaign/","score":17,"flags":0,"comment_count":3,"description":"","description_plain":"","submitter_user":"jmillikin","user_is_author":false,"tags":["rust","security"],"short_id_url":"https://lobste.rs/s/bzzwb7","comments_url":"https://lobste.rs/s/bzzwb7/phishing_campaign_targeting_crates_io"},{"short_id":"kltoas","created_at":"2025-09-12T10:14:05.000-05:00","title":"Lobsters Interview with Susam","url":"","score":60,"flags":0,"comment_count":2,"description":"\u003cp\u003e\u003cstrong\u003eHi \u003ca href=\"https://lobste.rs/~susam\" rel=\"ugc\"\u003e@susam\u003c/a\u003e, I primarily know you as a Lisper, what other things do you use?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYes, I use Lisp extensively for my personal projects, and much of what\nI do in my leisure is built on it.  I ran a \u003ca href=\"https://github.com/susam/mathb\" rel=\"ugc\"\u003emathematics pastebin\u003c/a\u003e\nfor close to thirteen years.  It was quite popular on some IRC\nchannels.  The pastebin was written in Common Lisp.  My \u003ca href=\"https://susam.net/\" rel=\"ugc\"\u003epersonal\nwebsite\u003c/a\u003e and blog are generated using a tiny static site generator\nwritten in Common Lisp.  Over the years I have built several other\npersonal tools in it as well.\u003c/p\u003e\n\u003cp\u003eI am an active Emacs Lisp programmer too.  Many of my software tools\nare in fact Emacs Lisp functions that I invoke with convenient key\nsequences.  They help me automate repetitive tasks as well as improve\nmy text editing and task management experience.\u003c/p\u003e\n\u003cp\u003eI use plenty of other tools as well.  In my early adulthood, I spent\nmany years working with C, C++, Java, and PHP.  My first substantial\nopen source contribution was to the Apache Nutch project which was in\nJava, and one of my early original open source projects was Uncap, a C\nprogram to remap keys on Windows.\u003c/p\u003e\n\u003cp\u003eThese days I use a lot of Python, along with some Go and Rust, but\nLisp remains important to my personal work.  I also enjoy writing\nsmall standalone tools directly in HTML and JavaScript, often with all\nthe code in a single file in a readable, unminified form.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow did you first discover computing, then end up with Lisp, Emacs and mathematics?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI got introduced to computers through the Logo programming\nlanguage as a kid.  Using simple arithmetic, geometry, logic, and code\nto manipulate a two-dimensional world had a lasting effect on me.\u003c/p\u003e\n\u003cp\u003eI still vividly remember how I ended up with Lisp.  It was at an\nairport during a long layover in 2007.  I wanted to use the time to\nlearn something, so I booted my laptop running Debian GNU/Linux 4.0\n(Etch) and then started \u003ca href=\"https://www.gnu.org/software/clisp/\" rel=\"ugc\"\u003eGNU CLISP\u003c/a\u003e 2.41.  In those days, Wi-Fi\nin airports was uncommon.  Smartphones and mobile data were also\nuncommon.  So it was fortunate that I had CLISP already installed on\nmy system and my laptop was ready for learning Common Lisp.  I had it\ninstalled because I had wanted to learn Common Lisp for some time.  I\nwas especially attracted by its simplicity, by the fact that the\nentire language can be built up from a very small set of special\nforms.  I use \u003ca href=\"https://www.sbcl.org/\" rel=\"ugc\"\u003eSBCL\u003c/a\u003e these days, by the way.\u003c/p\u003e\n\u003cp\u003eI discovered Emacs through Common Lisp.  Several sources recommended\nusing the \u003ca href=\"https://slime.common-lisp.dev/\" rel=\"ugc\"\u003eSuperior Lisp Interaction Mode for Emacs (SLIME)\u003c/a\u003e\nfor Common Lisp programming, so that’s where I began.  For many years\nI continued to use Vim as my primary editor, while relying on Emacs\nand SLIME for Lisp development.  Over time, as I learnt more about\nEmacs itself, I grew fond of Emacs Lisp and eventually made Emacs my\nprimary editor and computing environment.\u003c/p\u003e\n\u003cp\u003eI have loved mathematics since my childhood days.  What has always\nfascinated me is how we can prove deep and complex facts using first\nprinciples and clear logical steps.  That feeling of certainty and\nrigour is unlike anything else.\u003c/p\u003e\n\u003cp\u003eOver the years, my love for the subject has been rekindled many times.\nAs a specific example, let me share how I got into number theory.  One\nday I decided to learn the RSA cryptosystem.  As I was working through\nthe \u003ca href=\"https://people.csail.mit.edu/rivest/Rsapaper.pdf\" rel=\"ugc\"\u003eRSA paper\u003c/a\u003e, I stumbled upon the Euler totient function\nφ(n) which gives the number of positive integers not exceeding n that\nare relatively prime to n.  The paper first states that φ(p) = p - 1\nfor prime numbers p.  That was obvious since p has no factors other\nthan 1 and itself, so every integer from 1 up to p - 1 must be\nrelatively prime to it.  But then it presents φ(pq) = φ(p) · φ(q) =\n(p - 1)(q - 1) for primes p and q.  That was not immediately obvious\nto me back then.  After a few minutes of thinking, I managed to prove\nit from scratch.  By the inclusion-exclusion principle, we count how\nmany integers from 1 up to pq are not divisible by p or q.  There are\npq integers in total.  Among them, there are q integers divisible by\np, and p integers divisible by q.  So we need to subtract p + q from\npq.  But since one integer (pq itself) is counted in both groups, we\nadd 1 back.  Therefore φ(pq) = pq - (p + q) + 1 = (p - 1)(q - 1).\nNext I could also obtain the general formula for φ(n) for an arbitrary\npositive integer n using the same idea.  There are several other\nproofs too, but that is how I derived the general formula for φ(n)\nwhen I first encountered it.  And just like that, I had begun to learn\nnumber theory!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou’ve said you prefer computing for fun.  What is fun to you?  Do you have an\nidea of what makes something fun or not?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFor me, fun in computing began when I first learnt IBM/LCSI PC Logo when I was nine years old.  I had very limited access to computers back\nthen, perhaps only about two hours per \u003cem\u003emonth\u003c/em\u003e in the computer\nlaboratory at my primary school.  Most of my Logo programming happened\nwith pen and paper at home.  I would “test” my programs by tracing the\nresults on graph paper.  Eventually I would get about thirty minutes\nof actual computer time in the lab to run them for real.\u003c/p\u003e\n\u003cp\u003eSo back then, most of my computing happened without an actual\ncomputer.  But even with that limited access to computers, a whole new\nworld opened up for me: one that showed me the joy of computing, and\nmore importantly, the joy of sharing my little programs with my\nfriends and teachers.  One particular Logo program I still remember\nvery well drew a house with animated dashed lines, where the dashes\nmoved around the outline of the house.  Everyone around me loved it,\ncopied it, and tweaked it to change the colours, alter the details,\nand add their own little touches.\u003c/p\u003e\n\u003cp\u003eFor me, fun in computing comes from such exploration and sharing.  I\nenjoy asking “what happens if” and then seeing where it leads me.  My\nEmacs package \u003ca href=\"https://elpa.nongnu.org/nongnu/devil.html\" rel=\"ugc\"\u003edevil-mode\u003c/a\u003e comes from such exploration.  It came\nfrom asking, “What happens if we avoid using the \u003ccode\u003eCtrl\u003c/code\u003e and \u003ccode\u003eMeta\u003c/code\u003e\nmodifier keys and use the comma key (\u003ccode\u003e,\u003c/code\u003e) or another suitable key as a\nleader key instead?  And can we still have a non-modal editing\nexperience?”\u003c/p\u003e\n\u003cp\u003eSometimes computing for fun may mean crafting a minimal esoteric\ndrawing language, making a small game, or building a tool that solves\nan interesting problem elegantly.  It is a bonus if the exploration\nresults in something working well enough that I can share with others\non the World Wide Web and others find it fun too.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you choose what to investigate?  Which most interest you, with what commonalities?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFor me, it has always been one exploration leading to another.\u003c/p\u003e\n\u003cp\u003eFor example, I originally built \u003ca href=\"https://github.com/susam/mathb\" rel=\"ugc\"\u003eMathB\u003c/a\u003e for my friends and myself\nwho were going through a phase in our lives when we used to challenge\neach other with mathematical puzzles.  This tool became a nice way to\nshare solutions with each other.  Its use spread from my friends to\ntheir friends and colleagues, then to schools and universities, and\neventually to IRC channels.\u003c/p\u003e\n\u003cp\u003eSimilarly, I built \u003ca href=\"https://github.com/susam/texme\" rel=\"ugc\"\u003eTeXMe\u003c/a\u003e when I was learning neural networks and\ntaking a lot of notes on the subject.  I was not ready to share the\nnotes online, but I did want to share them with my friends and\ncolleagues who were also learning the same topic.  Normally I would\nwrite my notes in LaTeX, compile them to PDF, and share the PDF, but\nin this case, I wondered, what if I took some of the code from MathB\nand created a tool that would let me write plain Markdown (\u003ca href=\"https://github.github.com/gfm/\" rel=\"ugc\"\u003eGFM\u003c/a\u003e) +\nLaTeX (\u003ca href=\"https://www.mathjax.org/\" rel=\"ugc\"\u003eMathJax\u003c/a\u003e) in a \u003ccode\u003e.html\u003c/code\u003e file and have the tool render the\nfile as soon as it was opened in a web browser?  That resulted in\nTeXMe, which has surprisingly become one of my most popular projects,\nreceiving millions of hits in some months according to the CDN\nstatistics.\u003c/p\u003e\n\u003cp\u003eAnother example is \u003ca href=\"https://susam.github.io/muboard/\" rel=\"ugc\"\u003eMuboard\u003c/a\u003e, which is a bit like an interactive\nmathematics chalkboard.  I built this when I was hosting an \u003ca href=\"https://susam.net/journey-to-prime-number-theorem.html\" rel=\"ugc\"\u003eanalytic\nnumber theory book club\u003c/a\u003e and I needed a way to type LaTeX\nsnippets live on screen and see them immediately rendered.  That made\nme wonder: what if I took TeXMe, made it interactive, and gave it a\nchalkboard look-and-feel?  That led to Muboard.\u003c/p\u003e\n\u003cp\u003eSo we can see that sharing mathematical notes and snippets has been a\nrecurring theme in several of my projects.  But that is only a small\nfraction of my interests.  I have a wide variety of interests in\ncomputing.  I also engage in random explorations, like writing IRC\nclients (\u003ca href=\"https://github.com/susam/nimb\" rel=\"ugc\"\u003eNIMB\u003c/a\u003e, \u003ca href=\"https://github.com/susam/tzero\" rel=\"ugc\"\u003eTzero\u003c/a\u003e), ray tracing (\u003ca href=\"https://github.com/susam/pov25\" rel=\"ugc\"\u003ePOV-Ray\u003c/a\u003e,\n\u003ca href=\"https://github.com/spxy/java-ray-tracing\" rel=\"ugc\"\u003eJava\u003c/a\u003e), writing Emacs guides (\u003ca href=\"https://github.com/susam/emacs4cl\" rel=\"ugc\"\u003eEmacs4CL\u003c/a\u003e, \u003ca href=\"https://github.com/susam/emfy\" rel=\"ugc\"\u003eEmfy\u003c/a\u003e),\ndeveloping small single-HTML-file games (\u003ca href=\"https://susam.net/invaders.html\" rel=\"ugc\"\u003eAndromeda\nInvaders\u003c/a\u003e, \u003ca href=\"https://susam.net/myrgb.html\" rel=\"ugc\"\u003eGuess My RGB\u003c/a\u003e), purely recreational\nprogramming (\u003ca href=\"https://susam.net/fxyt.html\" rel=\"ugc\"\u003eFXYT\u003c/a\u003e, \u003ca href=\"https://github.com/susam/may4\" rel=\"ugc\"\u003emay4.fs\u003c/a\u003e, \u003ca href=\"https://susam.net/self-printing-machine-code.html\" rel=\"ugc\"\u003eself-printing machine\ncode\u003c/a\u003e, \u003ca href=\"https://susam.net/primegrid.html\" rel=\"ugc\"\u003eprime number grid explorer\u003c/a\u003e), and so on.  The\nlist goes on.  When it comes to hobby computing, I don’t think I can\npick just one domain and say it interests me the most.  I have a lot\nof interests.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat is computing, to you?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eComputing, to me, covers a wide range of activities: programming a\ncomputer, using a computer, understanding how it works, even building\none.  For example, I once built a tiny 16-bit CPU along with a small\nmain memory that could hold only eight 16-bit instructions, using VHDL\nand a Xilinx CPLD kit.  The design was based on the Mano CPU\nintroduced in the book Computer System Architecture (3rd ed.) by\nM. Morris Mano.  It was incredibly fun to enter instructions into the\nmain memory, one at a time, by pushing DIP switches up and down and then\nwatch the CPU I had built myself execute an entire program.  For\nsomeone like me, who usually works with software at higher levels of\nabstraction, that was a thrilling experience!\u003c/p\u003e\n\u003cp\u003eBeyond such experiments, computing also includes more practical and\nconcrete activities, such as installing and using my favourite Linux\ndistribution (Debian), writing software tools in languages like Common\nLisp, Emacs Lisp, Python, and the shell command language, or\ncustomising my Emacs environment to automate repetitive tasks.\u003c/p\u003e\n\u003cp\u003eTo me, computing also includes the abstract stuff like spending time\nwith abstract algebra and number theory and getting a deeper\nunderstanding of the results pertaining to groups, rings, and fields,\nas well as numerous number-theoretic results.  Browsing the On-Line\nEncyclopedia of Integer Sequences (OEIS), writing small programs to\nexplore interesting sequences, or just thinking about them is\ncomputing too.  I think many of the interesting results in computer\nscience have deep mathematical foundations.  I believe much of\ncomputer science is really discrete mathematics in action.\u003c/p\u003e\n\u003cp\u003eAnd if we dive all the way down from the CPU to the level of\ntransistors, we encounter continuous mathematics as well, with\nnon-linear voltage-current relationships and analogue behaviour that\nmake digital computing possible.  It is fascinating how, as a\nrelatively new species on this planet, we have managed to take sand\nand find a way to to use continuous voltages and currents in\nelectronic circuits built with silicon, and convert them into\nthe discrete operations of digital logic.\nWe have machines that can simulate themselves!\u003c/p\u003e\n\u003cp\u003eTo me, all of this is fun.  To study and learn about these things, to\nthink about them, to understand them better, and to accomplish useful\nor amusing results with this knowledge is all part of the fun.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you view programming vs. domains?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI focus more on the domain than the tool.  Most of the time it is a\nproblem that catches my attention, and then I explore it to understand\nthe domain and arrive at a solution.  The problem itself usually\npoints me to one of the tools I already know.\u003c/p\u003e\n\u003cp\u003eFor example, if it is about working with text files, I might write an\nEmacs Lisp function.  If it involves checking large sets of numbers\nrapidly for patterns, I might choose C++ or Rust.  But if I want to\nshare interactive visualisations of those patterns with others, I\nmight rewrite the solution in HTML and JavaScript, possibly with the\nuse of the Canvas API, so that I can share the work as a\nself-contained file that others can execute easily within their web\nbrowsers.  When I do that, I prefer to keep the HTML neat and\nreadable, rather than bundled or minified, so that people who like to\n‘View Source’ can copy, edit, and customise the code themselves, and\nimmediately see their changes take effect.\u003c/p\u003e\n\u003cp\u003eLet me share a specific example.  While working on a game, I first\nused \u003ccode\u003eCanvasRenderingContext2D.fillText()\u003c/code\u003e to display text on the\ngame.  However, dissatisfied with the text rendering quality, I began\nlooking for IBM PC OEM fonts and similar retro fonts online.  After\ndownloading a few font packs, I wrote a little Python script to\nconvert them to bitmaps (arrays of integers), and then used the\nbitmaps to draw text on the canvas using JavaScript, one cell at a\ntime, to get pixel-perfect results!  These tiny Python and JavaScript\ntools were good enough that I felt comfortable sharing them together\nas a tiny toolkit called \u003ca href=\"https://susam.github.io/pcface/src/demo.html\" rel=\"ugc\"\u003ePCFace\u003c/a\u003e.  This toolkit offers JavaScript\nbitmap arrays and tiny JavaScript rendering functions, so that someone\nelse who wants to display text on their game canvas using PC fonts and\nnothing but plain HTML and JavaScript can do so without having to\nsolve the problem from scratch!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHas the rate of your making new emacs functions has\ndiminished over time (as if everything’s covered) or do the widening\ndomains lead to more?  I’m curious how applicable old functionality\nis for new problems and how that impacts the APIs!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMy rate of making new Emacs functions has definitely decreased.  There\nare two reasons.  One is that over the years my computing environment\nhas converged into a comfortable, stable setup I am very happy with.\nThe other is that at this stage of life I simply cannot afford the\ntime to endlessly tinker with Emacs as I did in my younger days.\u003c/p\u003e\n\u003cp\u003eMore generally, when it comes to APIs, I find that well-designed\nfunctionality tends to remain useful even when new problems appear.\nIn Emacs, for example, many of my older functions continue to serve me\nwell because they were written in a composable way.  New problems can\noften be solved with small wrappers or combinations of existing\nfunctions.  I think APIs that consist of functions that are simple,\northogonal, and flexible age well.  If each function in an API does\none thing and does it well (the Unix philosophy), it will have\nlong-lasting utility.\u003c/p\u003e\n\u003cp\u003eOf course, new domains and problems do require new functions and\nextensions to an API, but I think it is very important to not give in\nto the temptation of enhancing the existing functions by making them\nmore complicated with optional parameters, keyword arguments, nested\nbranches, and so on.  Personally, I have found that it is much better\nto implement new functions that are small, orthogonal, and flexible,\neach doing one thing and doing it well.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat design methods or tips do you have, to increase composability?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFor me, good design starts with good vocabulary.  Clear vocabulary\nmakes abstract notions concrete and gives collaborators a shared\nlanguage to work with.  For example, while working on a network events\ndatabase many years ago, we collected data minute by minute from\nnetwork devices.  We decided to call each minute of data from a single\ndevice a “nugget”.  So if we had 15 minutes of data from 10 devices,\nthat meant 150 nuggets.\u003c/p\u003e\n\u003cp\u003eWhy “nugget”?  Because it was shorter and more convenient than\nrepeatedly saying “a minute of data from one device”.  Why not\nsomething less fancy like “chunk”?  Because we reserved “chunk” for\nsubdivisions within a nugget.  Perhaps there were better choices, but\n“nugget” was the term we settled on, and it quickly became shared\nterminology between the collaborators.  Good terminology naturally\ncarries over into code.  With this vocabulary in place, function names\nlike \u003ccode\u003ecollect_nugget()\u003c/code\u003e, \u003ccode\u003eopen_nugget()\u003c/code\u003e, \u003ccode\u003eparse_chunk()\u003c/code\u003e,\n\u003ccode\u003eindex_chunk()\u003c/code\u003e, \u003ccode\u003eskip_chunk()\u003c/code\u003e, etc. immediately become meaningful to\neveryone involved.\u003c/p\u003e\n\u003cp\u003eThinking about the vocabulary also ensures that we are thinking about\nthe data, concepts, and notions we are working with in a deliberate\nmanner, and that kind of thinking also helps when we design the\narchitecture of software.\u003c/p\u003e\n\u003cp\u003eToo often I see collaborators on software projects jump straight into\nwriting functions that take some input and produce some desired\neffect, with variable names and function names decided on the fly.  To\nme, this feels backwards.  I prefer the opposite approach.  Define the\nterms first, and let the code follow from them.\u003c/p\u003e\n\u003cp\u003eI also prefer developing software in a layered manner, where complex\nfunctionality is built from simpler, well-named building blocks.  It\nis especially important to avoid \u003cem\u003elayer violations\u003c/em\u003e, where one complex\nfunction invokes another complex function.  That creates tight\ncoupling between two complex functions.  If one function changes in\nthe future, we have to reason carefully about how it affects the\nother.  Since both are already complex, the cognitive burden is high.\nA better approach, I think, is to identify the common functionality\nthey share and factor that out into smaller, simpler functions.\u003c/p\u003e\n\u003cp\u003eTo summarise, I like to develop software with a clear vocabulary,\nconsistent use of that vocabulary, a layered design where complex\nfunctions are built from simpler ones, and by avoiding layer\nviolations.  I am sure none of this is new to the Lobsters community.\nSome of these ideas also occur in \u003ca href=\"https://en.wikipedia.org/wiki/Domain-driven_design\" rel=\"ugc\"\u003edomain-driven design\u003c/a\u003e (DDD).\nDDD defines the term \u003cem\u003eubiquitous language\u003c/em\u003e to mean, “A language\nstructured around the domain model and used by all team members within\na bounded context to connect all the activities of the team with the\nsoftware.”  If I could call this approach of software development\nsomething, I would simply call it “vocabulary-driven development”\n(VDD), though of course DDD is the more comprehensive concept.\u003c/p\u003e\n\u003cp\u003eLike I said, none of this is likely new to the Lobsters community.  In\nparticular, I suspect Forth programmers would find it too obvious.  In\nForth, it is very difficult to begin with a long, poorly thought-out\nmonolithic word and then break it down into smaller ones later.  The\nstack effects quickly become too hard to track mentally with that\napproach.  The only viable way to develop software in Forth is to\nstart with a small set of words that represent the important notions\nof the problem domain, test them immediately, and then compose\nhigher-level words from the lower-level ones.  Forth naturally\nencourages a layered style of development, where the programmer thinks\ncarefully about the domain, invents vocabulary, and expresses complex\nideas in terms of simpler ones, almost in a mathematical fashion.  In\nmy experience, this kind of deliberate design produces software that\nremains easy to understand and reason about even years after it was\nwritten.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNot enhancing existing functions but adding new small ones seems\nquite lovely, but how do you come back to such a codebase later with\nmany tiny functions?  At points, I’ve advocated for very large\nfunctions, particularly traumatized by Java-esque 1000 functions in\n1000 files approaches.  When you had time, would you often\nrearchitecture the conceptual space of all of those functions?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe famous quote from Alan J. Perlis comes to mind:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eIt is better to have 100 functions operate on one data structure\nthan 10 functions on 10 data structures.\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePersonally, I enjoy working with a codebase that has thousands of\nfunctions, provided most of them are small, well-scoped, and do one\nthing well.  That said, I am not dogmatically opposed to large\nfunctions.  It is always a matter of taste and judgement.  Sometimes\none large, cohesive function is clearer than a pile of tiny ones.\u003c/p\u003e\n\u003cp\u003eFor example, when I worked on parser generators, I often found that\nlexers and finite state machines benefited from a single top-level\nfunction containing the full tokenisation logic or the full state\ntransition logic in one place.  That function could call smaller\nhelpers for specific tasks, but we still need the overall\n\u003ccode\u003eswitch\u003c/code\u003e-\u003ccode\u003ecase\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse\u003c/code\u003e or \u003ccode\u003econd\u003c/code\u003e ladder somewhere.  I think\ntrying to split that ladder into smaller functions would only make the\ncode harder to follow.\u003c/p\u003e\n\u003cp\u003eSo while I lean towards small, composable functions, the real goal is\nto strike a balance that keeps code maintainable in the long run.\nEach function should be as small as it can reasonably be, and no\nsmaller.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLike you, I program as a tool to explore domains. Which do you know the most about?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFor me too, the appeal of computer programming lies especially in how it\nlets me explore different domains.  There are two kinds of domains in\nwhich I think I have gained good expertise.  The first comes from\nyears of developing software for businesses, which has included\nsolving problems such as network events parsing, indexing and\nquerying, packet decoding, developing parser generators, database\nsession management, and TLS certificate lifecycle management.  The\nsecond comes from areas I pursue purely out of curiosity or for hobby\ncomputing.  This is the kind I am going to focus on in our\nconversation.\u003c/p\u003e\n\u003cp\u003eAlthough computing and software are serious business today, for me, as\nfor many others, computing is also a hobby.\u003c/p\u003e\n\u003cp\u003ePersonal hobby projects often lead me down various rabbit holes, and I\nend up learning new domains along the way.  For example, although I am\nnot a web developer, I learnt to build small, interactive single-page\ntools in plain HTML, CSS, and JavaScript simply because I needed them\nfor my hobby projects over and over again.  An early example is\n\u003ca href=\"https://susam.net/quickqwerty.html\" rel=\"ugc\"\u003eQuickQWERTY\u003c/a\u003e, which I built to teach myself and my friends\ntouch-typing on QWERTY keyboards.  Another example is \u003ca href=\"https://susam.net/cfrs.html\" rel=\"ugc\"\u003eCFRS[]\u003c/a\u003e,\nwhich I created because I wanted to make a total (non-Turing complete)\ndrawing language that has turtle graphics like Logo but is absolutely\nminimal like P′′.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eYou use double spaces after periods which\nI’d only experienced from people who learned touch typing on\ntypewriters, unexpected!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYes, I do separate sentences by double spaces.  It is interesting that\nyou noticed this.\u003c/p\u003e\n\u003cp\u003eI once briefly learnt touch typing on typewriters as a kid, but those\nlessons did not stick with me.  It was much later, when I used a Java\napplet-based touch typing tutor that I found online about two decades\nago, that the lessons really stayed with me.  Surprisingly, that\napplication taught me to type with a single space between sentences.\nBy the way, I disliked installing Java plugins into the web browser,\nso I wrote \u003ca href=\"https://susam.net/quickqwerty.html\" rel=\"ugc\"\u003eQuickQWERTY\u003c/a\u003e as a similar touch typing tutor in plain HTML and JavaScript\nfor myself and my friends.\u003c/p\u003e\n\u003cp\u003eI learnt to use double spaces between sentences first with Vim and\nthen later again with Emacs.  For example, in Vim, the \u003ccode\u003ejoinspaces\u003c/code\u003e\noption is on by default, so when we join sentences with the normal\nmode command \u003ccode\u003eJ\u003c/code\u003e, or format paragraphs with \u003ccode\u003egqap\u003c/code\u003e, Vim inserts two\nspaces after full stops.  We need to disable that behaviour with \u003ccode\u003e:set nojoinspaces\u003c/code\u003e if we want single spacing.\u003c/p\u003e\n\u003cp\u003eIt is similar in Emacs.  In Emacs, the \u003ccode\u003edelete-indentation\u003c/code\u003e command\n(\u003ccode\u003eM-^\u003c/code\u003e) and the \u003ccode\u003efill-paragraph\u003c/code\u003e command (\u003ccode\u003eM-q\u003c/code\u003e) both insert two\nspaces between sentences by default.  Single spacing can be enabled\nwith \u003ccode\u003e(setq sentence-end-double-space nil)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIncidentally, I spent a good portion of the README for my Emacs\nquick-start DIY kit named \u003ca href=\"https://github.com/susam/emfy\" rel=\"ugc\"\u003eEmfy\u003c/a\u003e discussing sentence spacing\nconventions under the section \u003ca href=\"https://github.com/susam/emfy#single-space-for-sentence-spacing\" rel=\"ugc\"\u003eSingle Space for Sentence\nSpacing\u003c/a\u003e.  There I explain how to configure Emacs to\nuse single spaces, although I use double spaces myself.  That’s\nbecause many new Emacs users prefer single spacing.\u003c/p\u003e\n\u003cp\u003eThe defaults in Vim and Emacs made me adopt double spacing.  The\ndouble spacing convention is also widespread across open source\nsoftware.  If we look at the Vim help pages, Emacs built-in\ndocumentation, or the Unix and Linux man pages, double spacing is the\nnorm.  Even inline comments in traditional open source projects often\nuse it.  For example, see Vim’s \u003ca href=\"https://github.com/vim/vim/blob/v9.1.1752/runtime/doc/usr_01.txt\" rel=\"ugc\"\u003e:h usr_01.txt\u003c/a\u003e, Emacs’s\n\u003ca href=\"https://cgit.git.savannah.gnu.org/cgit/emacs.git/tree/doc/emacs/emacs.texi?h=emacs-30.2#n1556\" rel=\"ugc\"\u003e(info “(emacs) Intro”)\u003c/a\u003e, or the comments in the \u003ca href=\"https://gcc.gnu.org/git/?p=gcc.git;f=gcc/cfg.cc;hb=releases/gcc-15.2.0\" rel=\"ugc\"\u003eGCC\nsource code\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow do you approach learning a new domain?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhen I take on a new domain, there is of course a lot of reading\ninvolved from articles, books, and documentation.  But as I read, I\nconstantly try to test what I learn.  Whenever I see a claim, I ask\nmyself, “If this were wrong, how could I demonstrate it?”  Then I\ndesign a little experiment, perhaps write a snippet of code, or run a\ncommand, or work through a concrete example, with the goal of checking\nthe claim in practice.\u003c/p\u003e\n\u003cp\u003eNow I am not genuinely hoping to prove a claim wrong.  It is just a\nway to engage with the material.  To illustrate, let me share an\nextremely simple and generic example without going into any particular\ndomain.  Suppose I learn that Boolean operations in Python\nshort-circuit.  I might write out several experimental snippets like\nthe following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef t(): print('t'); return True\ndef f(): print('f'); return False\nf() or t() or f()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd then confirm that the results do indeed confirm short-circuit\nevaluation (\u003ccode\u003ef\u003c/code\u003e followed by \u003ccode\u003et\u003c/code\u003e in this case).\u003c/p\u003e\n\u003cp\u003eAt this point, one could say, “Well, you just confirmed what the\ndocumentation already told you.”  And that’s true.  But for me, the\nvalue lies in trying to test it for myself.  Even if the claim holds,\nthe act of checking forces me to see the idea in action.  That not\nonly reinforces the concept but also helps me build a much deeper\nintuition for it.\u003c/p\u003e\n\u003cp\u003eSometimes these experiments also expose gaps in my own understanding.\nSuppose I didn’t properly know what “short-circuit” means.  Then the\nresults might contradict my expectations.  That contradiction would\npush me to correct my misconception, and that’s where the real\nlearning happens.\u003c/p\u003e\n\u003cp\u003eOccasionally, this process even uncovers subtleties I didn’t expect.\nFor example, while learning socket programming, I discovered that a\nclient can successfully receive data using \u003ccode\u003erecv()\u003c/code\u003e even after calling\n\u003ccode\u003eshutdown()\u003c/code\u003e, contrary to what I had first inferred from the\nspecifications.  See my Stack Overflow post “\u003ca href=\"https://stackoverflow.com/q/39698037/303363\" rel=\"ugc\"\u003eWhy can recv() in the\nclient program receive messages sent to the client after the client\nhas invoked shutdown(sockfd, SHUT_RD)?\u003c/a\u003e” for more details if\nyou are curious.\u003c/p\u003e\n\u003cp\u003eNow this method cannot always be applied, especially if it is very\nexpensive or unwieldy to do so.  For example, if I am learning\nsomething in the finance domain, it is not always possible to perform\nan actual transaction.  One can sometimes use simulation software,\nmock environments, or sandbox systems to explore ideas safely.  Still,\nit is worth noting that this method has its limitations.\u003c/p\u003e\n\u003cp\u003eIn mathematics, though, I find this method highly effective.  When I\nstudy a new branch of mathematics, I try to come up with examples and\ncounterexamples to test what I am learning.  Often, failing to find a\ncounterexample helps me appreciate more deeply why a claim holds and\nwhy no counterexamples exist.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDo you have trouble not getting distracted with so much on your plate? I’m curious how you balance the time commitments of everything!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIndeed, it is very easy to get distracted.  One thing that has helped\nover the years is the increase in responsibilities in other areas of\nmy life.  These days I also spend some of my free time studying\nmathematics textbooks.  With growing responsibilities and the time I\ndevote to mathematics, I now get at most a few hours each week for\nhobby computing.  This automatically narrows down my options.  I can\nexplore perhaps one or at most two ideas in a month, and that\nconstraint makes me very deliberate about choosing my pursuits.\u003c/p\u003e\n\u003cp\u003eMany of the explorations do not evolve into something solid that I can\nshare.  They remain as little experimental code snippets or notes\narchived in a private repository.  But once in a while, an exploration\ngrows into something concrete and feels worth sharing on the Web.\nThat becomes a short-term hobby project.  I might work on it over a\nweekend if it is small, or for a few weeks if it is more complex.\nWhen that happens, the goal of sharing the project helps me focus.\u003c/p\u003e\n\u003cp\u003eI try not to worry too much about making time.  After all, this is\njust a hobby.  Other areas of my life have higher priority.  I also\nwant to devote a good portion of my free time to learning more\nmathematics, which is another hobby I am passionate about.  Whatever\nlittle spare time remains after attending to the higher-priority\naspects of my life goes into my computing projects, usually a couple\nof hours a week, most of it on weekends.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow does blogging mix in?  What’s the development like of a single piece of curiosity through wrestling with the domain, learning and sharing it etc.?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMaintaining my personal website is another aspect of computing that I\nfind very enjoyable.  My website began as a loose collection of pages\non a LAN site during my university days.  Since then I have been\nadding pages to it to write about various topics that I find\ninteresting.  It acquired its blog shape and form much later when\nblogging became fashionable.\u003c/p\u003e\n\u003cp\u003eI usually write a new blog post when I feel like there is some piece\nof knowledge or some exploration that I want to archive in a\npersistent format.  Now what the development of a post looks like\ndepends very much on the post.  So let me share two opposite examples\nto describe what the development of a single piece looks like.\u003c/p\u003e\n\u003cp\u003eOne of my most frequently visited posts is \u003ca href=\"https://susam.net/lisp-in-vim.html\" rel=\"ugc\"\u003eLisp in Vim\u003c/a\u003e.\nIt started when I was hosting a Common Lisp programming club for\nbeginners.  Although I have always used Emacs and SLIME for Common\nLisp programming myself, many in the club used Vim, so I decided to\nwrite a short guide on setting up something SLIME-like there.  As a\nformer long-time Vim user myself, I wanted to make the Lisp journey\neasier for Vim users too.  I thought it would be a 30-minute exercise\nwhere I write up a README that explains how to install \u003ca href=\"https://github.com/kovisoft/slimv\" rel=\"ugc\"\u003eSlimv\u003c/a\u003e and\nhow to set it up in Vim.  But then I discovered a newer plugin called\n\u003ca href=\"https://github.com/vlime/vlime\" rel=\"ugc\"\u003eVlime\u003c/a\u003e that also offered SLIME-like features in Vim!  That detail\nsent me down a very deep rabbit hole.  Now I needed to know how the\ntwo packages were different, what their strengths and weaknesses were,\nhow routine operations were performed in both, and so on.  What was\nmeant to be a short note turned into a nearly 10,000-word article.  As\nI was comparing the two SLIME-like packages for Vim, I also found a\nfew bugs in Slimv and contributed fixes for them (\u003ca href=\"https://github.com/kovisoft/slimv/pull/87\" rel=\"ugc\"\u003e#87\u003c/a\u003e, \u003ca href=\"https://github.com/kovisoft/slimv/pull/88\" rel=\"ugc\"\u003e#88\u003c/a\u003e,\n\u003ca href=\"https://github.com/kovisoft/slimv/pull/89\" rel=\"ugc\"\u003e#89\u003c/a\u003e, \u003ca href=\"https://github.com/kovisoft/slimv/pull/90\" rel=\"ugc\"\u003e#90\u003c/a\u003e).  Writing this blog post turned into a month-long\nproject!\u003c/p\u003e\n\u003cp\u003eAt the opposite extreme is a post like \u003ca href=\"https://susam.net/elliptical-python-programming.html\" rel=\"ugc\"\u003eElliptical Python\nProgramming\u003c/a\u003e.  I stumbled upon Python \u003ca href=\"https://docs.python.org/3/library/constants.html#Ellipsis\" rel=\"ugc\"\u003eEllipsis\u003c/a\u003e while\nreviewing someone’s code.  It immediately caught my attention.  I\nwondered if, combined with some standard obfuscation techniques, one\ncould write arbitrary Python programs that looked almost like Morse\ncode.  A few minutes of experimentation showed that a genuinely Morse\ncode-like appearance was not possible, but something close could be\nachieved.  So I wrote what I hope is a humorous post demonstrating\nthat arbitrary Python programs can be written using a very restricted\nset of symbols, one of which is the ellipsis.  It took me less than an\nhour to write this post.  The final result doesn’t look quite like\nMorse code as I had imagined, but it is quite amusing nevertheless!\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat draws you to post and read online forums?  How do you balance\nor allot time for reading technical articles, blogs etc.?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe exchange of ideas!  Just as I\nenjoy sharing my own computing-related thoughts, ideas, and projects,\nI also find joy in reading what others have to share.\u003c/p\u003e\n\u003cp\u003eOther areas of my life take precedence over\nhobby projects.  Similarly, I treat the hobby projects as higher\npriority than reading technical forums.\u003c/p\u003e\n\u003cp\u003eAfter I’ve given time to the higher-priority parts of my life and to\nmy own technical explorations, I use whatever spare time remains to\nread articles, follow technical discussions, and occasionally add\ncomments.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhen you decided to stop with MathB due to moderation burdens, I\noffered to take over/help and you mentioned\nothers had too.  Did anyone end up forking it, to your knowledge?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI first thought of shutting down the \u003ca href=\"https://github.com/susam/mathb\" rel=\"ugc\"\u003eMathB\u003c/a\u003e-based pastebin website\nin November 2019.  The website had been running for seven years at\nthat time.  When I announced my thoughts to the IRC communities that\nwould be affected, I received a lot of support and encouragement.  A\nfew members even volunteered to help me out with moderation.  That\nsupport and encouragement kept me going for another six years.\nHowever, the volunteers eventually became busy with their own lives\nand moved on.  After all, moderating user content for an open pastebin\nthat anyone in the world can post to is a thankless and tiring\nactivity.  So most of the moderation activity fell back on me.\nFinally, in February 2025, I realised that I no longer want to spend\ntime on this kind of work.\u003c/p\u003e\n\u003cp\u003eI developed MathB with a lot of passion for myself and my friends.  I\nhad no idea at the time that this little project would keep a corner\nof my mind occupied even during weekends and holidays.  There was\nalways a nagging worry.  What if someone posted content that triggered\ncompliance concerns and my server was taken offline while I was away?\nI no longer wanted that kind of burden in my life.  So I finally\ndecided to shut it down.  I’ve written more about this in \u003ca href=\"https://susam.net/mathbin-is-shutting-down.html\" rel=\"ugc\"\u003eMathB.in Is\nShutting Down\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo my knowledge, no one has forked it, but others have developed\nalternatives.  Further, the \u003ca href=\"https://wiki.archiveteam.org/\" rel=\"ugc\"\u003eArchive Team\u003c/a\u003e has\n\u003ca href=\"https://web.archive.org/web/*/https://mathb.in/\" rel=\"ugc\"\u003earchived\u003c/a\u003e all posts from the now-defunct MathB-based\nwebsite.  A member of the Archive Team reached out to me over IRC and\nwe worked together for about a week to get everything successfully\narchived.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhat’re your favorite math textbooks?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI have several favourite mathematics books, but let me share three I\nremember especially fondly.\u003c/p\u003e\n\u003cp\u003eThe first is \u003cem\u003eAdvanced Engineering Mathematics\u003c/em\u003e by Erwin Kreyszig.  I\ndon’t often see this book recommended online, but for me it played a\nmajor role in broadening my horizons.  I think I studied the 8th\nedition back in the early 2000s.  It is a hefty book with over a\nthousand pages, and I remember reading it cover to cover, solving\nevery exercise problem along the way.  It gave me a solid foundation\nin routine areas like differential equations, linear algebra, vector\ncalculus, and complex analysis.  It also introduced me to Fourier\ntransforms and Laplace transforms, which I found fascinating.\u003c/p\u003e\n\u003cp\u003eOf course, the Fourier transform has a wide range of applications in\nsignal processing, communications, spectroscopy, and more.  But I want\nto focus on the fun and playful part.  In the early 2000s, I was also\nlearning to play the piano as a hobby.  I used to record my amateur\nmusic compositions with \u003ca href=\"https://github.com/audacity/audacity\" rel=\"ugc\"\u003eAudacity\u003c/a\u003e by connecting my digital piano to\nmy laptop with a line-in cable.  It was great fun to plot the spectrum\nof my music on Audacity, apply high-pass and low-pass filters, and\nobserve how the Fourier transform of the audio changed and then hear\nthe effect on the music.  That kind of hands-on tinkering made Fourier\nanalysis intuitive for me, and I highly recommend it to anyone who\nenjoys both music and mathematics.\u003c/p\u003e\n\u003cp\u003eThe second book is \u003cem\u003eIntroduction to Analytic Number Theory\u003c/em\u003e by Tom M.\nApostol.  As a child I was intrigued by the prime number theorem but\nlacked the mathematical maturity to understand its proof.  Years\nlater, as an adult, I finally taught myself the proof from Apostol’s\nbook.  It was a fantastic journey that began with simple concepts like\nthe Möbius function and Dirichlet products and ended with quite clever\ncontour integrals that proved the theorem.  The complex analysis I had\nlearnt from Kreyszig turned out to be crucial for understanding those\nintegrals.  Along the way I gained a deeper understanding of the\nRiemann zeta function ζ(s).  The book discusses zero-free regions\nwhere ζ(s) does not vanish, which I found especially fascinating.\nResults like ζ(-1) = -1/12, which once seemed mysterious, became\nobvious after studying this book.\u003c/p\u003e\n\u003cp\u003eThe third is \u003cem\u003eGalois Theory\u003c/em\u003e by Ian Stewart.  It introduced me to\nfield extensions, field homomorphisms, and solubility by radicals.  I\nhad long known that not all quintic equations are soluble by radicals,\nbut I didn’t know why.  Stewart’s book taught me exactly why.  In\nparticular, it demonstrated that the polynomial t⁵ - 6t + 3 over the\nfield of rational numbers is not soluble by radicals.  This particular\nresult, although fascinating, is just a small part of a much larger\nbody of work, which is even more remarkable.  To arrive at this\nresult, the book takes us through a wonderful journey that includes\nthe theory of polynomial rings, algebraic and transcendental field\nextensions, impossibility proofs for ruler-and-compass constructions,\nthe Galois correspondence, and much more.\u003c/p\u003e\n\u003cp\u003eOne of the most rewarding aspects of reading books like these is how\nthey open doors to new knowledge, including things I didn’t even know\nthat I didn’t know.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHow does the newer math jell with or inform past or present\ncomputing, compared to much older stuff?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eI don’t always think explicitly about how mathematics informs\ncomputing, past or present.  Often the textbooks I pick feel very\nchallenging to me, so much so that all my energy goes into simply\nmastering the material.  It is arduous but enjoyable.  I do it purely\nfor the fun of learning without worrying about applications.\u003c/p\u003e\n\u003cp\u003eOf course, a good portion of pure mathematics probably has no\nreal-world applications.  As G. H. Hardy famously wrote in \u003cem\u003eA\nMathematician’s Apology\u003c/em\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eI have never done anything ‘useful’.  No discovery of mine has made,\nor is likely to make, directly or indirectly, for good or ill, the\nleast difference to the amenity of the world.\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBut there is no denying that some of it does find applications.  Were\nHardy alive today, he might be disappointed that number theory, his\nfavourite field of “useless” mathematics, is now a crucial part of\nmodern cryptography.  Electronic commerce wouldn’t likely exist\nwithout it.\u003c/p\u003e\n\u003cp\u003eSimilarly, it is amusing how something as abstract as abstract algebra\nfinds very concrete applications in coding theory.  Concepts such as\npolynomial rings, finite fields, and cosets of subspaces in vector\nspaces over finite fields play a crucial role in error-correcting\ncodes, without which modern data transmission and storage would not be\npossible.\u003c/p\u003e\n\u003cp\u003eOn a more personal note, some simpler areas of mathematics have been\ndirectly useful in my own work.  While solving problems for\nbusinesses, information entropy, combinatorics, and probability theory\nwere crucial when I worked on gesture-based authentication about one\nand a half decades ago.\u003c/p\u003e\n\u003cp\u003eSimilarly, when I was developing Bloom filter-based indexing and\nquerying for a network events database, again, probability theory was\ncrucial in determining the parameters of the Bloom filters (such as\nthe number of hash functions, bits per filter, and elements per\nfilter) to ensure that the false positive rate remained below a\ncertain threshold.  Subsequent testing with randomly sampled network\nevents confirmed that the observed false positive rate matched the\ntheoretical estimate quite well.  It was very satisfying to see\nprobability theory and the real world agreeing so closely.\u003c/p\u003e\n\u003cp\u003eBeyond these specific examples, studying mathematics also influences\nthe way I think about problems.  Embarking on journeys like analytic\nnumber theory or Galois theory is humbling.  There are times when I\nstruggle to understand a small paragraph of the book, and it takes me\nseveral hours (or even days) to work out the arguments in detail with\npen and paper (lots of it) before I really grok them.  That experience\nof grappling with dense reasoning teaches humility and also makes me\nsceptical of complex, hand-wavy logic in day-to-day programming.\u003c/p\u003e\n\u003cp\u003eSeveral times I have seen code that bundles too many decisions into\none block of logic, where it is not obvious whether it would behave\ncorrectly in all circumstances.  Explanations may sometimes be offered\nabout why it works for reasonable inputs, but the reasoning is often\nnot watertight.  The experience of working through mathematical\nproofs, writing my own, making mistakes, and then correcting them has\ntaught me that if the reasoning for correctness is not clear and\nrigorous, something could be wrong.  In my experience, once such code\nsees real-world usage, a bug is nearly always found.\u003c/p\u003e\n\u003cp\u003eThat’s why I usually insist either on simplifying the logic or on\ndemonstrating correctness in a clear, rigorous way.  Sometimes this\nmeans doing a case-by-case analysis for different types of inputs or\nconditions, and showing that the code behaves correctly in each case.\nThere is also a bit of an art to reducing what seem like numerous or\neven infinitely many cases to a small, manageable set of cases by\nspotting structure, such as symmetries, invariants, or natural\npartitions of the input space.  Alternatively, one can look for a\nsimpler argument that covers all cases.  These are techniques we\nemploy routinely in mathematics, and I think that kind of thinking and\nreasoning is quite valuable in software development too.\u003c/p\u003e\n","description_plain":"**Hi @susam, I primarily know you as a Lisper, what other things do you use?**\r\n\r\nYes, I use Lisp extensively for my personal projects, and much of what\r\nI do in my leisure is built on it.  I ran a [mathematics pastebin][]\r\nfor close to thirteen years.  It was quite popular on some IRC\r\nchannels.  The pastebin was written in Common Lisp.  My [personal\r\nwebsite][] and blog are generated using a tiny static site generator\r\nwritten in Common Lisp.  Over the years I have built several other\r\npersonal tools in it as well.\r\n\r\nI am an active Emacs Lisp programmer too.  Many of my software tools\r\nare in fact Emacs Lisp functions that I invoke with convenient key\r\nsequences.  They help me automate repetitive tasks as well as improve\r\nmy text editing and task management experience.\r\n\r\nI use plenty of other tools as well.  In my early adulthood, I spent\r\nmany years working with C, C++, Java, and PHP.  My first substantial\r\nopen source contribution was to the Apache Nutch project which was in\r\nJava, and one of my early original open source projects was Uncap, a C\r\nprogram to remap keys on Windows.\r\n\r\nThese days I use a lot of Python, along with some Go and Rust, but\r\nLisp remains important to my personal work.  I also enjoy writing\r\nsmall standalone tools directly in HTML and JavaScript, often with all\r\nthe code in a single file in a readable, unminified form.\r\n\r\n[mathematics pastebin]: https://github.com/susam/mathb\r\n[personal website]: https://susam.net/\r\n\r\n\r\n\r\n\r\n**How did you first discover computing, then end up with Lisp, Emacs and mathematics?**\r\n\r\nI got introduced to computers through the Logo programming\r\nlanguage as a kid.  Using simple arithmetic, geometry, logic, and code\r\nto manipulate a two-dimensional world had a lasting effect on me.\r\n\r\nI still vividly remember how I ended up with Lisp.  It was at an\r\nairport during a long layover in 2007.  I wanted to use the time to\r\nlearn something, so I booted my laptop running Debian GNU/Linux 4.0\r\n(Etch) and then started [GNU CLISP][CLISP] 2.41.  In those days, Wi-Fi\r\nin airports was uncommon.  Smartphones and mobile data were also\r\nuncommon.  So it was fortunate that I had CLISP already installed on\r\nmy system and my laptop was ready for learning Common Lisp.  I had it\r\ninstalled because I had wanted to learn Common Lisp for some time.  I\r\nwas especially attracted by its simplicity, by the fact that the\r\nentire language can be built up from a very small set of special\r\nforms.  I use [SBCL][] these days, by the way.\r\n\r\nI discovered Emacs through Common Lisp.  Several sources recommended\r\nusing the [Superior Lisp Interaction Mode for Emacs (SLIME)][SLIME]\r\nfor Common Lisp programming, so that's where I began.  For many years\r\nI continued to use Vim as my primary editor, while relying on Emacs\r\nand SLIME for Lisp development.  Over time, as I learnt more about\r\nEmacs itself, I grew fond of Emacs Lisp and eventually made Emacs my\r\nprimary editor and computing environment.\r\n\r\nI have loved mathematics since my childhood days.  What has always\r\nfascinated me is how we can prove deep and complex facts using first\r\nprinciples and clear logical steps.  That feeling of certainty and\r\nrigour is unlike anything else.\r\n\r\nOver the years, my love for the subject has been rekindled many times.\r\nAs a specific example, let me share how I got into number theory.  One\r\nday I decided to learn the RSA cryptosystem.  As I was working through\r\nthe [RSA paper][rsa-paper], I stumbled upon the Euler totient function\r\nφ(n) which gives the number of positive integers not exceeding n that\r\nare relatively prime to n.  The paper first states that φ(p) = p - 1\r\nfor prime numbers p.  That was obvious since p has no factors other\r\nthan 1 and itself, so every integer from 1 up to p - 1 must be\r\nrelatively prime to it.  But then it presents φ(pq) = φ(p) · φ(q) =\r\n(p - 1)(q - 1) for primes p and q.  That was not immediately obvious\r\nto me back then.  After a few minutes of thinking, I managed to prove\r\nit from scratch.  By the inclusion-exclusion principle, we count how\r\nmany integers from 1 up to pq are not divisible by p or q.  There are\r\npq integers in total.  Among them, there are q integers divisible by\r\np, and p integers divisible by q.  So we need to subtract p + q from\r\npq.  But since one integer (pq itself) is counted in both groups, we\r\nadd 1 back.  Therefore φ(pq) = pq - (p + q) + 1 = (p - 1)(q - 1).\r\nNext I could also obtain the general formula for φ(n) for an arbitrary\r\npositive integer n using the same idea.  There are several other\r\nproofs too, but that is how I derived the general formula for φ(n)\r\nwhen I first encountered it.  And just like that, I had begun to learn\r\nnumber theory!\r\n\r\n[CLISP]: https://www.gnu.org/software/clisp/\r\n[SBCL]: https://www.sbcl.org/\r\n[SLIME]: https://slime.common-lisp.dev/\r\n[rsa-paper]: https://people.csail.mit.edu/rivest/Rsapaper.pdf\r\n\r\n\r\n\r\n\r\n**You've said you prefer computing for fun.  What is fun to you?  Do you have an\r\nidea of what makes something fun or not?**\r\n\r\nFor me, fun in computing began when I first learnt IBM/LCSI PC Logo when I was nine years old.  I had very limited access to computers back\r\nthen, perhaps only about two hours per *month* in the computer\r\nlaboratory at my primary school.  Most of my Logo programming happened\r\nwith pen and paper at home.  I would \"test\" my programs by tracing the\r\nresults on graph paper.  Eventually I would get about thirty minutes\r\nof actual computer time in the lab to run them for real.\r\n\r\nSo back then, most of my computing happened without an actual\r\ncomputer.  But even with that limited access to computers, a whole new\r\nworld opened up for me: one that showed me the joy of computing, and\r\nmore importantly, the joy of sharing my little programs with my\r\nfriends and teachers.  One particular Logo program I still remember\r\nvery well drew a house with animated dashed lines, where the dashes\r\nmoved around the outline of the house.  Everyone around me loved it,\r\ncopied it, and tweaked it to change the colours, alter the details,\r\nand add their own little touches.\r\n\r\nFor me, fun in computing comes from such exploration and sharing.  I\r\nenjoy asking \"what happens if\" and then seeing where it leads me.  My\r\nEmacs package [devil-mode][] comes from such exploration.  It came\r\nfrom asking, \"What happens if we avoid using the `Ctrl` and `Meta`\r\nmodifier keys and use the comma key (`,`) or another suitable key as a\r\nleader key instead?  And can we still have a non-modal editing\r\nexperience?\"\r\n\r\nSometimes computing for fun may mean crafting a minimal esoteric\r\ndrawing language, making a small game, or building a tool that solves\r\nan interesting problem elegantly.  It is a bonus if the exploration\r\nresults in something working well enough that I can share with others\r\non the World Wide Web and others find it fun too.\r\n\r\n[devil-mode]: https://elpa.nongnu.org/nongnu/devil.html\r\n\r\n**How do you choose what to investigate?  Which most interest you, with what commonalities?**\r\n\r\nFor me, it has always been one exploration leading to another.\r\n\r\nFor example, I originally built [MathB][] for my friends and myself\r\nwho were going through a phase in our lives when we used to challenge\r\neach other with mathematical puzzles.  This tool became a nice way to\r\nshare solutions with each other.  Its use spread from my friends to\r\ntheir friends and colleagues, then to schools and universities, and\r\neventually to IRC channels.\r\n\r\nSimilarly, I built [TeXMe][] when I was learning neural networks and\r\ntaking a lot of notes on the subject.  I was not ready to share the\r\nnotes online, but I did want to share them with my friends and\r\ncolleagues who were also learning the same topic.  Normally I would\r\nwrite my notes in LaTeX, compile them to PDF, and share the PDF, but\r\nin this case, I wondered, what if I took some of the code from MathB\r\nand created a tool that would let me write plain Markdown ([GFM][]) +\r\nLaTeX ([MathJax][]) in a `.html` file and have the tool render the\r\nfile as soon as it was opened in a web browser?  That resulted in\r\nTeXMe, which has surprisingly become one of my most popular projects,\r\nreceiving millions of hits in some months according to the CDN\r\nstatistics.\r\n\r\nAnother example is [Muboard][], which is a bit like an interactive\r\nmathematics chalkboard.  I built this when I was hosting an [analytic\r\nnumber theory book club][antbc] and I needed a way to type LaTeX\r\nsnippets live on screen and see them immediately rendered.  That made\r\nme wonder: what if I took TeXMe, made it interactive, and gave it a\r\nchalkboard look-and-feel?  That led to Muboard.\r\n\r\nSo we can see that sharing mathematical notes and snippets has been a\r\nrecurring theme in several of my projects.  But that is only a small\r\nfraction of my interests.  I have a wide variety of interests in\r\ncomputing.  I also engage in random explorations, like writing IRC\r\nclients ([NIMB][], [Tzero][]), ray tracing ([POV-Ray][povray],\r\n[Java][javaray]), writing Emacs guides ([Emacs4CL][], [Emfy][]),\r\ndeveloping small single-HTML-file games ([Andromeda\r\nInvaders][invaders], [Guess My RGB][myrgb]), purely recreational\r\nprogramming ([FXYT][], [may4.fs][], [self-printing machine\r\ncode][spmc], [prime number grid explorer][primegrid]), and so on.  The\r\nlist goes on.  When it comes to hobby computing, I don't think I can\r\npick just one domain and say it interests me the most.  I have a lot\r\nof interests.\r\n\r\n[GFM]: https://github.github.com/gfm/\r\n[MathJax]: https://www.mathjax.org/\r\n[MathB]: https://github.com/susam/mathb\r\n[TeXMe]: https://github.com/susam/texme\r\n[Muboard]: https://susam.github.io/muboard/\r\n[antbc]: https://susam.net/journey-to-prime-number-theorem.html\r\n[NIMB]: https://github.com/susam/nimb\r\n[Tzero]: https://github.com/susam/tzero\r\n[BFC]: https://github.com/susam/bfc\r\n[cfrs]: https://susam.net/cfrs.html\r\n[FXYT]: https://susam.net/fxyt.html\r\n[povray]: https://github.com/susam/pov25\r\n[javaray]: https://github.com/spxy/java-ray-tracing\r\n[Emacs4CL]: https://github.com/susam/emacs4cl\r\n[Emfy]: https://github.com/susam/emfy\r\n[invaders]: https://susam.net/invaders.html\r\n[myrgb]: https://susam.net/myrgb.html\r\n[may4.fs]: https://github.com/susam/may4\r\n[spmc]: https://susam.net/self-printing-machine-code.html\r\n[primegrid]: https://susam.net/primegrid.html\r\n\r\n**What is computing, to you?**\r\n\r\nComputing, to me, covers a wide range of activities: programming a\r\ncomputer, using a computer, understanding how it works, even building\r\none.  For example, I once built a tiny 16-bit CPU along with a small\r\nmain memory that could hold only eight 16-bit instructions, using VHDL\r\nand a Xilinx CPLD kit.  The design was based on the Mano CPU\r\nintroduced in the book Computer System Architecture (3rd ed.) by\r\nM. Morris Mano.  It was incredibly fun to enter instructions into the\r\nmain memory, one at a time, by pushing DIP switches up and down and then\r\nwatch the CPU I had built myself execute an entire program.  For\r\nsomeone like me, who usually works with software at higher levels of\r\nabstraction, that was a thrilling experience!\r\n\r\nBeyond such experiments, computing also includes more practical and\r\nconcrete activities, such as installing and using my favourite Linux\r\ndistribution (Debian), writing software tools in languages like Common\r\nLisp, Emacs Lisp, Python, and the shell command language, or\r\ncustomising my Emacs environment to automate repetitive tasks.\r\n\r\nTo me, computing also includes the abstract stuff like spending time\r\nwith abstract algebra and number theory and getting a deeper\r\nunderstanding of the results pertaining to groups, rings, and fields,\r\nas well as numerous number-theoretic results.  Browsing the On-Line\r\nEncyclopedia of Integer Sequences (OEIS), writing small programs to\r\nexplore interesting sequences, or just thinking about them is\r\ncomputing too.  I think many of the interesting results in computer\r\nscience have deep mathematical foundations.  I believe much of\r\ncomputer science is really discrete mathematics in action.\r\n\r\nAnd if we dive all the way down from the CPU to the level of\r\ntransistors, we encounter continuous mathematics as well, with\r\nnon-linear voltage-current relationships and analogue behaviour that\r\nmake digital computing possible.  It is fascinating how, as a\r\nrelatively new species on this planet, we have managed to take sand\r\nand find a way to to use continuous voltages and currents in\r\n   electronic circuits built with silicon, and convert them into \r\nthe discrete operations of digital logic.\r\nWe have machines that can simulate themselves!\r\n\r\nTo me, all of this is fun.  To study and learn about these things, to\r\nthink about them, to understand them better, and to accomplish useful\r\nor amusing results with this knowledge is all part of the fun.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**How do you view programming vs. domains?**\r\n\r\nI focus more on the domain than the tool.  Most of the time it is a\r\nproblem that catches my attention, and then I explore it to understand\r\nthe domain and arrive at a solution.  The problem itself usually\r\npoints me to one of the tools I already know.\r\n\r\nFor example, if it is about working with text files, I might write an\r\nEmacs Lisp function.  If it involves checking large sets of numbers\r\nrapidly for patterns, I might choose C++ or Rust.  But if I want to\r\nshare interactive visualisations of those patterns with others, I\r\nmight rewrite the solution in HTML and JavaScript, possibly with the\r\nuse of the Canvas API, so that I can share the work as a\r\nself-contained file that others can execute easily within their web\r\nbrowsers.  When I do that, I prefer to keep the HTML neat and\r\nreadable, rather than bundled or minified, so that people who like to\r\n'View Source' can copy, edit, and customise the code themselves, and\r\nimmediately see their changes take effect.\r\n\r\nLet me share a specific example.  While working on a game, I first\r\nused `CanvasRenderingContext2D.fillText()` to display text on the\r\ngame.  However, dissatisfied with the text rendering quality, I began\r\nlooking for IBM PC OEM fonts and similar retro fonts online.  After\r\ndownloading a few font packs, I wrote a little Python script to\r\nconvert them to bitmaps (arrays of integers), and then used the\r\nbitmaps to draw text on the canvas using JavaScript, one cell at a\r\ntime, to get pixel-perfect results!  These tiny Python and JavaScript\r\ntools were good enough that I felt comfortable sharing them together\r\nas a tiny toolkit called [PCFace][].  This toolkit offers JavaScript\r\nbitmap arrays and tiny JavaScript rendering functions, so that someone\r\nelse who wants to display text on their game canvas using PC fonts and\r\nnothing but plain HTML and JavaScript can do so without having to\r\nsolve the problem from scratch!\r\n\r\n[PCFace]: https://susam.github.io/pcface/src/demo.html\r\n\r\n\r\n\r\n**Has the rate of your making new emacs functions has\r\n diminished over time (as if everything's covered) or do the widening\r\n domains lead to more?  I'm curious how applicable old functionality\r\n is for new problems and how that impacts the APIs!**\r\n\r\nMy rate of making new Emacs functions has definitely decreased.  There\r\nare two reasons.  One is that over the years my computing environment\r\nhas converged into a comfortable, stable setup I am very happy with.\r\nThe other is that at this stage of life I simply cannot afford the\r\ntime to endlessly tinker with Emacs as I did in my younger days.\r\n\r\nMore generally, when it comes to APIs, I find that well-designed\r\nfunctionality tends to remain useful even when new problems appear.\r\nIn Emacs, for example, many of my older functions continue to serve me\r\nwell because they were written in a composable way.  New problems can\r\noften be solved with small wrappers or combinations of existing\r\nfunctions.  I think APIs that consist of functions that are simple,\r\northogonal, and flexible age well.  If each function in an API does\r\none thing and does it well (the Unix philosophy), it will have\r\nlong-lasting utility.\r\n\r\nOf course, new domains and problems do require new functions and\r\nextensions to an API, but I think it is very important to not give in\r\nto the temptation of enhancing the existing functions by making them\r\nmore complicated with optional parameters, keyword arguments, nested\r\nbranches, and so on.  Personally, I have found that it is much better\r\nto implement new functions that are small, orthogonal, and flexible,\r\neach doing one thing and doing it well.\r\n\r\n\r\n**What design methods or tips do you have, to increase composability?**\r\n\r\nFor me, good design starts with good vocabulary.  Clear vocabulary\r\nmakes abstract notions concrete and gives collaborators a shared\r\nlanguage to work with.  For example, while working on a network events\r\ndatabase many years ago, we collected data minute by minute from\r\nnetwork devices.  We decided to call each minute of data from a single\r\ndevice a \"nugget\".  So if we had 15 minutes of data from 10 devices,\r\nthat meant 150 nuggets.\r\n\r\nWhy \"nugget\"?  Because it was shorter and more convenient than\r\nrepeatedly saying \"a minute of data from one device\".  Why not\r\nsomething less fancy like \"chunk\"?  Because we reserved \"chunk\" for\r\nsubdivisions within a nugget.  Perhaps there were better choices, but\r\n\"nugget\" was the term we settled on, and it quickly became shared\r\nterminology between the collaborators.  Good terminology naturally\r\ncarries over into code.  With this vocabulary in place, function names\r\nlike `collect_nugget()`, `open_nugget()`, `parse_chunk()`,\r\n`index_chunk()`, `skip_chunk()`, etc. immediately become meaningful to\r\neveryone involved.\r\n\r\nThinking about the vocabulary also ensures that we are thinking about\r\nthe data, concepts, and notions we are working with in a deliberate\r\nmanner, and that kind of thinking also helps when we design the\r\narchitecture of software.\r\n\r\nToo often I see collaborators on software projects jump straight into\r\nwriting functions that take some input and produce some desired\r\neffect, with variable names and function names decided on the fly.  To\r\nme, this feels backwards.  I prefer the opposite approach.  Define the\r\nterms first, and let the code follow from them.\r\n\r\nI also prefer developing software in a layered manner, where complex\r\nfunctionality is built from simpler, well-named building blocks.  It\r\nis especially important to avoid *layer violations*, where one complex\r\nfunction invokes another complex function.  That creates tight\r\ncoupling between two complex functions.  If one function changes in\r\nthe future, we have to reason carefully about how it affects the\r\nother.  Since both are already complex, the cognitive burden is high.\r\nA better approach, I think, is to identify the common functionality\r\nthey share and factor that out into smaller, simpler functions.\r\n\r\nTo summarise, I like to develop software with a clear vocabulary,\r\nconsistent use of that vocabulary, a layered design where complex\r\nfunctions are built from simpler ones, and by avoiding layer\r\nviolations.  I am sure none of this is new to the Lobsters community.\r\nSome of these ideas also occur in [domain-driven design][ddd] (DDD).\r\nDDD defines the term *ubiquitous language* to mean, \"A language\r\nstructured around the domain model and used by all team members within\r\na bounded context to connect all the activities of the team with the\r\nsoftware.\"  If I could call this approach of software development\r\nsomething, I would simply call it \"vocabulary-driven development\"\r\n(VDD), though of course DDD is the more comprehensive concept.\r\n\r\nLike I said, none of this is likely new to the Lobsters community.  In\r\nparticular, I suspect Forth programmers would find it too obvious.  In\r\nForth, it is very difficult to begin with a long, poorly thought-out\r\nmonolithic word and then break it down into smaller ones later.  The\r\nstack effects quickly become too hard to track mentally with that\r\napproach.  The only viable way to develop software in Forth is to\r\nstart with a small set of words that represent the important notions\r\nof the problem domain, test them immediately, and then compose\r\nhigher-level words from the lower-level ones.  Forth naturally\r\nencourages a layered style of development, where the programmer thinks\r\ncarefully about the domain, invents vocabulary, and expresses complex\r\nideas in terms of simpler ones, almost in a mathematical fashion.  In\r\nmy experience, this kind of deliberate design produces software that\r\nremains easy to understand and reason about even years after it was\r\nwritten.\r\n\r\n[ddd]: https://en.wikipedia.org/wiki/Domain-driven_design\r\n\r\n\r\n\r\n\r\n**Not enhancing existing functions but adding new small ones seems\r\n quite lovely, but how do you come back to such a codebase later with\r\n many tiny functions?  At points, I've advocated for very large\r\n functions, particularly traumatized by Java-esque 1000 functions in\r\n 1000 files approaches.  When you had time, would you often\r\n rearchitecture the conceptual space of all of those functions?**\r\n\r\nThe famous quote from Alan J. Perlis comes to mind:\r\n\r\n\u003e *It is better to have 100 functions operate on one data structure\r\nthan 10 functions on 10 data structures.*\r\n\r\nPersonally, I enjoy working with a codebase that has thousands of\r\nfunctions, provided most of them are small, well-scoped, and do one\r\nthing well.  That said, I am not dogmatically opposed to large\r\nfunctions.  It is always a matter of taste and judgement.  Sometimes\r\none large, cohesive function is clearer than a pile of tiny ones.\r\n\r\nFor example, when I worked on parser generators, I often found that\r\nlexers and finite state machines benefited from a single top-level\r\nfunction containing the full tokenisation logic or the full state\r\ntransition logic in one place.  That function could call smaller\r\nhelpers for specific tasks, but we still need the overall\r\n`switch`-`case` or `if`-`else` or `cond` ladder somewhere.  I think\r\ntrying to split that ladder into smaller functions would only make the\r\ncode harder to follow.\r\n\r\nSo while I lean towards small, composable functions, the real goal is\r\nto strike a balance that keeps code maintainable in the long run.\r\nEach function should be as small as it can reasonably be, and no\r\nsmaller.\r\n\r\n\r\n\r\n**Like you, I program as a tool to explore domains. Which do you know the most about?**\r\n\r\nFor me too, the appeal of computer programming lies especially in how it\r\nlets me explore different domains.  There are two kinds of domains in\r\nwhich I think I have gained good expertise.  The first comes from\r\nyears of developing software for businesses, which has included\r\nsolving problems such as network events parsing, indexing and\r\nquerying, packet decoding, developing parser generators, database\r\nsession management, and TLS certificate lifecycle management.  The\r\nsecond comes from areas I pursue purely out of curiosity or for hobby\r\ncomputing.  This is the kind I am going to focus on in our\r\nconversation.\r\n\r\nAlthough computing and software are serious business today, for me, as\r\nfor many others, computing is also a hobby.\r\n\r\nPersonal hobby projects often lead me down various rabbit holes, and I\r\nend up learning new domains along the way.  For example, although I am\r\nnot a web developer, I learnt to build small, interactive single-page\r\ntools in plain HTML, CSS, and JavaScript simply because I needed them\r\nfor my hobby projects over and over again.  An early example is\r\n[QuickQWERTY][], which I built to teach myself and my friends\r\ntouch-typing on QWERTY keyboards.  Another example is [CFRS[]][cfrs],\r\nwhich I created because I wanted to make a total (non-Turing complete)\r\ndrawing language that has turtle graphics like Logo but is absolutely\r\nminimal like P′′.\r\n\r\n[QuickQWERTY]: https://susam.net/quickqwerty.html\r\n[cfrs]: https://susam.net/cfrs.html\r\n\r\n\r\n**You use double spaces after periods which\r\n I'd only experienced from people who learned touch typing on\r\n typewriters, unexpected!**\r\n\r\nYes, I do separate sentences by double spaces.  It is interesting that\r\nyou noticed this.\r\n\r\nI once briefly learnt touch typing on typewriters as a kid, but those\r\nlessons did not stick with me.  It was much later, when I used a Java\r\napplet-based touch typing tutor that I found online about two decades\r\nago, that the lessons really stayed with me.  Surprisingly, that\r\napplication taught me to type with a single space between sentences.\r\nBy the way, I disliked installing Java plugins into the web browser,\r\nso I wrote [QuickQWERTY][] as a similar touch typing tutor in plain HTML and JavaScript\r\nfor myself and my friends.\r\n\r\nI learnt to use double spaces between sentences first with Vim and\r\nthen later again with Emacs.  For example, in Vim, the `joinspaces`\r\noption is on by default, so when we join sentences with the normal\r\nmode command `J`, or format paragraphs with `gqap`, Vim inserts two\r\nspaces after full stops.  We need to disable that behaviour with `:set\r\nnojoinspaces` if we want single spacing.\r\n\r\nIt is similar in Emacs.  In Emacs, the `delete-indentation` command\r\n(`M-^`) and the `fill-paragraph` command (`M-q`) both insert two\r\nspaces between sentences by default.  Single spacing can be enabled\r\nwith `(setq sentence-end-double-space nil)`.\r\n\r\nIncidentally, I spent a good portion of the README for my Emacs\r\nquick-start DIY kit named [Emfy][] discussing sentence spacing\r\nconventions under the section [Single Space for Sentence\r\nSpacing][sentence-spacing].  There I explain how to configure Emacs to\r\nuse single spaces, although I use double spaces myself.  That's\r\nbecause many new Emacs users prefer single spacing.\r\n\r\nThe defaults in Vim and Emacs made me adopt double spacing.  The\r\ndouble spacing convention is also widespread across open source\r\nsoftware.  If we look at the Vim help pages, Emacs built-in\r\ndocumentation, or the Unix and Linux man pages, double spacing is the\r\nnorm.  Even inline comments in traditional open source projects often\r\nuse it.  For example, see Vim's [:h usr_01.txt][vim-usr-01], Emacs's\r\n[(info \"(emacs) Intro\")][emacs-intro], or the comments in the [GCC\r\nsource code][gcc-src].\r\n\r\n[Emfy]: https://github.com/susam/emfy\r\n[sentence-spacing]:https://github.com/susam/emfy#single-space-for-sentence-spacing\r\n[QuickQWERTY]: https://susam.net/quickqwerty.html\r\n[vim-usr-01]: https://github.com/vim/vim/blob/v9.1.1752/runtime/doc/usr_01.txt\r\n[emacs-intro]: https://cgit.git.savannah.gnu.org/cgit/emacs.git/tree/doc/emacs/emacs.texi?h=emacs-30.2#n1556\r\n[gcc-src]: https://gcc.gnu.org/git/?p=gcc.git;f=gcc/cfg.cc;hb=releases/gcc-15.2.0\r\n\r\n\r\n**How do you approach learning a new domain?**\r\n\r\nWhen I take on a new domain, there is of course a lot of reading\r\ninvolved from articles, books, and documentation.  But as I read, I\r\nconstantly try to test what I learn.  Whenever I see a claim, I ask\r\nmyself, \"If this were wrong, how could I demonstrate it?\"  Then I\r\ndesign a little experiment, perhaps write a snippet of code, or run a\r\ncommand, or work through a concrete example, with the goal of checking\r\nthe claim in practice.\r\n\r\nNow I am not genuinely hoping to prove a claim wrong.  It is just a\r\nway to engage with the material.  To illustrate, let me share an\r\nextremely simple and generic example without going into any particular\r\ndomain.  Suppose I learn that Boolean operations in Python\r\nshort-circuit.  I might write out several experimental snippets like\r\nthe following:\r\n\r\n```python\r\ndef t(): print('t'); return True\r\ndef f(): print('f'); return False\r\nf() or t() or f()\r\n```\r\n\r\nAnd then confirm that the results do indeed confirm short-circuit\r\nevaluation (`f` followed by `t` in this case).\r\n\r\nAt this point, one could say, \"Well, you just confirmed what the\r\ndocumentation already told you.\"  And that's true.  But for me, the\r\nvalue lies in trying to test it for myself.  Even if the claim holds,\r\nthe act of checking forces me to see the idea in action.  That not\r\nonly reinforces the concept but also helps me build a much deeper\r\nintuition for it.\r\n\r\nSometimes these experiments also expose gaps in my own understanding.\r\nSuppose I didn't properly know what \"short-circuit\" means.  Then the\r\nresults might contradict my expectations.  That contradiction would\r\npush me to correct my misconception, and that's where the real\r\nlearning happens.\r\n\r\nOccasionally, this process even uncovers subtleties I didn't expect.\r\nFor example, while learning socket programming, I discovered that a\r\nclient can successfully receive data using `recv()` even after calling\r\n`shutdown()`, contrary to what I had first inferred from the\r\nspecifications.  See my Stack Overflow post \"[Why can recv() in the\r\nclient program receive messages sent to the client after the client\r\nhas invoked shutdown(sockfd, SHUT_RD)?][so-recv]\" for more details if\r\nyou are curious.\r\n\r\nNow this method cannot always be applied, especially if it is very\r\nexpensive or unwieldy to do so.  For example, if I am learning\r\nsomething in the finance domain, it is not always possible to perform\r\nan actual transaction.  One can sometimes use simulation software,\r\nmock environments, or sandbox systems to explore ideas safely.  Still,\r\nit is worth noting that this method has its limitations.\r\n\r\nIn mathematics, though, I find this method highly effective.  When I\r\nstudy a new branch of mathematics, I try to come up with examples and\r\ncounterexamples to test what I am learning.  Often, failing to find a\r\ncounterexample helps me appreciate more deeply why a claim holds and\r\nwhy no counterexamples exist.\r\n\r\n[so-recv]: https://stackoverflow.com/q/39698037/303363\r\n\r\n\r\n\r\n\r\n**Do you have trouble not getting distracted with so much on your plate? I'm curious how you balance the time commitments of everything!**\r\n\r\nIndeed, it is very easy to get distracted.  One thing that has helped\r\nover the years is the increase in responsibilities in other areas of\r\nmy life.  These days I also spend some of my free time studying\r\nmathematics textbooks.  With growing responsibilities and the time I\r\ndevote to mathematics, I now get at most a few hours each week for\r\nhobby computing.  This automatically narrows down my options.  I can\r\nexplore perhaps one or at most two ideas in a month, and that\r\nconstraint makes me very deliberate about choosing my pursuits.\r\n\r\nMany of the explorations do not evolve into something solid that I can\r\nshare.  They remain as little experimental code snippets or notes\r\narchived in a private repository.  But once in a while, an exploration\r\ngrows into something concrete and feels worth sharing on the Web.\r\nThat becomes a short-term hobby project.  I might work on it over a\r\nweekend if it is small, or for a few weeks if it is more complex.\r\nWhen that happens, the goal of sharing the project helps me focus.\r\n\r\nI try not to worry too much about making time.  After all, this is\r\njust a hobby.  Other areas of my life have higher priority.  I also\r\nwant to devote a good portion of my free time to learning more\r\nmathematics, which is another hobby I am passionate about.  Whatever\r\nlittle spare time remains after attending to the higher-priority\r\naspects of my life goes into my computing projects, usually a couple\r\nof hours a week, most of it on weekends.\r\n\r\n**How does blogging mix in?  What's the development like of a single piece of curiosity through wrestling with the domain, learning and sharing it etc.?**\r\n\r\nMaintaining my personal website is another aspect of computing that I\r\nfind very enjoyable.  My website began as a loose collection of pages\r\non a LAN site during my university days.  Since then I have been\r\nadding pages to it to write about various topics that I find\r\ninteresting.  It acquired its blog shape and form much later when\r\nblogging became fashionable.\r\n\r\nI usually write a new blog post when I feel like there is some piece\r\nof knowledge or some exploration that I want to archive in a\r\npersistent format.  Now what the development of a post looks like\r\ndepends very much on the post.  So let me share two opposite examples\r\nto describe what the development of a single piece looks like.\r\n\r\nOne of my most frequently visited posts is [Lisp in Vim][lisp-in-vim].\r\nIt started when I was hosting a Common Lisp programming club for\r\nbeginners.  Although I have always used Emacs and SLIME for Common\r\nLisp programming myself, many in the club used Vim, so I decided to\r\nwrite a short guide on setting up something SLIME-like there.  As a\r\nformer long-time Vim user myself, I wanted to make the Lisp journey\r\neasier for Vim users too.  I thought it would be a 30-minute exercise\r\nwhere I write up a README that explains how to install [Slimv][] and\r\nhow to set it up in Vim.  But then I discovered a newer plugin called\r\n[Vlime][] that also offered SLIME-like features in Vim!  That detail\r\nsent me down a very deep rabbit hole.  Now I needed to know how the\r\ntwo packages were different, what their strengths and weaknesses were,\r\nhow routine operations were performed in both, and so on.  What was\r\nmeant to be a short note turned into a nearly 10,000-word article.  As\r\nI was comparing the two SLIME-like packages for Vim, I also found a\r\nfew bugs in Slimv and contributed fixes for them ([#87][], [#88][],\r\n[#89][], [#90][]).  Writing this blog post turned into a month-long\r\nproject!\r\n\r\nAt the opposite extreme is a post like [Elliptical Python\r\nProgramming][elliptical].  I stumbled upon Python [Ellipsis][] while\r\nreviewing someone's code.  It immediately caught my attention.  I\r\nwondered if, combined with some standard obfuscation techniques, one\r\ncould write arbitrary Python programs that looked almost like Morse\r\ncode.  A few minutes of experimentation showed that a genuinely Morse\r\ncode-like appearance was not possible, but something close could be\r\nachieved.  So I wrote what I hope is a humorous post demonstrating\r\nthat arbitrary Python programs can be written using a very restricted\r\nset of symbols, one of which is the ellipsis.  It took me less than an\r\nhour to write this post.  The final result doesn't look quite like\r\nMorse code as I had imagined, but it is quite amusing nevertheless!\r\n\r\n[lisp-in-vim]: https://susam.net/lisp-in-vim.html\r\n[Slimv]: https://github.com/kovisoft/slimv\r\n[Vlime]: https://github.com/vlime/vlime\r\n[elliptical]: https://susam.net/elliptical-python-programming.html\r\n[Ellipsis]: https://docs.python.org/3/library/constants.html#Ellipsis\r\n[#87]: https://github.com/kovisoft/slimv/pull/87\r\n[#88]: https://github.com/kovisoft/slimv/pull/88\r\n[#89]: https://github.com/kovisoft/slimv/pull/89\r\n[#90]: https://github.com/kovisoft/slimv/pull/90\r\n\r\n\r\n**What draws you to post and read online forums?  How do you balance\r\nor allot time for reading technical articles, blogs etc.?**\r\n\r\nThe exchange of ideas!  Just as I\r\nenjoy sharing my own computing-related thoughts, ideas, and projects,\r\nI also find joy in reading what others have to share.\r\n\r\nOther areas of my life take precedence over\r\nhobby projects.  Similarly, I treat the hobby projects as higher\r\npriority than reading technical forums.\r\n\r\nAfter I've given time to the higher-priority parts of my life and to\r\nmy own technical explorations, I use whatever spare time remains to\r\nread articles, follow technical discussions, and occasionally add\r\ncomments.\r\n\r\n\r\n\r\n**When you decided to stop with MathB due to moderation burdens, I\r\noffered to take over/help and you mentioned\r\nothers had too.  Did anyone end up forking it, to your knowledge?**\r\n\r\nI first thought of shutting down the [MathB][]-based pastebin website\r\nin November 2019.  The website had been running for seven years at\r\nthat time.  When I announced my thoughts to the IRC communities that\r\nwould be affected, I received a lot of support and encouragement.  A\r\nfew members even volunteered to help me out with moderation.  That\r\nsupport and encouragement kept me going for another six years.\r\nHowever, the volunteers eventually became busy with their own lives\r\nand moved on.  After all, moderating user content for an open pastebin\r\nthat anyone in the world can post to is a thankless and tiring\r\nactivity.  So most of the moderation activity fell back on me.\r\nFinally, in February 2025, I realised that I no longer want to spend\r\ntime on this kind of work.\r\n\r\nI developed MathB with a lot of passion for myself and my friends.  I\r\nhad no idea at the time that this little project would keep a corner\r\nof my mind occupied even during weekends and holidays.  There was\r\nalways a nagging worry.  What if someone posted content that triggered\r\ncompliance concerns and my server was taken offline while I was away?\r\nI no longer wanted that kind of burden in my life.  So I finally\r\ndecided to shut it down.  I've written more about this in [MathB.in Is\r\nShutting Down][mathbin-shutdown].\r\n\r\nTo my knowledge, no one has forked it, but others have developed\r\nalternatives.  Further, the [Archive Team][archive-team] has\r\n[archived][mathb-archive] all posts from the now-defunct MathB-based\r\nwebsite.  A member of the Archive Team reached out to me over IRC and\r\nwe worked together for about a week to get everything successfully\r\narchived.\r\n\r\n[MathB]: https://github.com/susam/mathb\r\n[mathbin-shutdown]: https://susam.net/mathbin-is-shutting-down.html\r\n[archive-team]: https://wiki.archiveteam.org/\r\n[mathb-archive]: https://web.archive.org/web/*/https://mathb.in/\r\n\r\n\r\n\r\n\r\n**What're your favorite math textbooks?**\r\n\r\nI have several favourite mathematics books, but let me share three I\r\nremember especially fondly.\r\n\r\nThe first is *Advanced Engineering Mathematics* by Erwin Kreyszig.  I\r\ndon't often see this book recommended online, but for me it played a\r\nmajor role in broadening my horizons.  I think I studied the 8th\r\nedition back in the early 2000s.  It is a hefty book with over a\r\nthousand pages, and I remember reading it cover to cover, solving\r\nevery exercise problem along the way.  It gave me a solid foundation\r\nin routine areas like differential equations, linear algebra, vector\r\ncalculus, and complex analysis.  It also introduced me to Fourier\r\ntransforms and Laplace transforms, which I found fascinating.\r\n\r\nOf course, the Fourier transform has a wide range of applications in\r\nsignal processing, communications, spectroscopy, and more.  But I want\r\nto focus on the fun and playful part.  In the early 2000s, I was also\r\nlearning to play the piano as a hobby.  I used to record my amateur\r\nmusic compositions with [Audacity][] by connecting my digital piano to\r\nmy laptop with a line-in cable.  It was great fun to plot the spectrum\r\nof my music on Audacity, apply high-pass and low-pass filters, and\r\nobserve how the Fourier transform of the audio changed and then hear\r\nthe effect on the music.  That kind of hands-on tinkering made Fourier\r\nanalysis intuitive for me, and I highly recommend it to anyone who\r\nenjoys both music and mathematics.\r\n\r\nThe second book is *Introduction to Analytic Number Theory* by Tom M.\r\nApostol.  As a child I was intrigued by the prime number theorem but\r\nlacked the mathematical maturity to understand its proof.  Years\r\nlater, as an adult, I finally taught myself the proof from Apostol's\r\nbook.  It was a fantastic journey that began with simple concepts like\r\nthe Möbius function and Dirichlet products and ended with quite clever\r\ncontour integrals that proved the theorem.  The complex analysis I had\r\nlearnt from Kreyszig turned out to be crucial for understanding those\r\nintegrals.  Along the way I gained a deeper understanding of the\r\nRiemann zeta function ζ(s).  The book discusses zero-free regions\r\nwhere ζ(s) does not vanish, which I found especially fascinating.\r\nResults like ζ(-1) = -1/12, which once seemed mysterious, became\r\nobvious after studying this book.\r\n\r\nThe third is *Galois Theory* by Ian Stewart.  It introduced me to\r\nfield extensions, field homomorphisms, and solubility by radicals.  I\r\nhad long known that not all quintic equations are soluble by radicals,\r\nbut I didn't know why.  Stewart's book taught me exactly why.  In\r\nparticular, it demonstrated that the polynomial t⁵ - 6t + 3 over the\r\nfield of rational numbers is not soluble by radicals.  This particular\r\nresult, although fascinating, is just a small part of a much larger\r\nbody of work, which is even more remarkable.  To arrive at this\r\nresult, the book takes us through a wonderful journey that includes\r\nthe theory of polynomial rings, algebraic and transcendental field\r\nextensions, impossibility proofs for ruler-and-compass constructions,\r\nthe Galois correspondence, and much more.\r\n\r\nOne of the most rewarding aspects of reading books like these is how\r\nthey open doors to new knowledge, including things I didn't even know\r\nthat I didn't know.\r\n\r\n[Audacity]: https://github.com/audacity/audacity\r\n\r\n**How does the newer math jell with or inform past or present\r\ncomputing, compared to much older stuff?**\r\n\r\nI don't always think explicitly about how mathematics informs\r\ncomputing, past or present.  Often the textbooks I pick feel very\r\nchallenging to me, so much so that all my energy goes into simply\r\nmastering the material.  It is arduous but enjoyable.  I do it purely\r\nfor the fun of learning without worrying about applications.\r\n\r\nOf course, a good portion of pure mathematics probably has no\r\nreal-world applications.  As G. H. Hardy famously wrote in *A\r\nMathematician's Apology*:\r\n\r\n\u003e *I have never done anything 'useful'.  No discovery of mine has made,\r\nor is likely to make, directly or indirectly, for good or ill, the\r\nleast difference to the amenity of the world.*\r\n\r\nBut there is no denying that some of it does find applications.  Were\r\nHardy alive today, he might be disappointed that number theory, his\r\nfavourite field of \"useless\" mathematics, is now a crucial part of\r\nmodern cryptography.  Electronic commerce wouldn't likely exist\r\nwithout it.\r\n\r\nSimilarly, it is amusing how something as abstract as abstract algebra\r\nfinds very concrete applications in coding theory.  Concepts such as\r\npolynomial rings, finite fields, and cosets of subspaces in vector\r\nspaces over finite fields play a crucial role in error-correcting\r\ncodes, without which modern data transmission and storage would not be\r\npossible.\r\n\r\nOn a more personal note, some simpler areas of mathematics have been\r\ndirectly useful in my own work.  While solving problems for\r\nbusinesses, information entropy, combinatorics, and probability theory\r\nwere crucial when I worked on gesture-based authentication about one\r\nand a half decades ago.\r\n\r\nSimilarly, when I was developing Bloom filter-based indexing and\r\nquerying for a network events database, again, probability theory was\r\ncrucial in determining the parameters of the Bloom filters (such as\r\nthe number of hash functions, bits per filter, and elements per\r\nfilter) to ensure that the false positive rate remained below a\r\ncertain threshold.  Subsequent testing with randomly sampled network\r\nevents confirmed that the observed false positive rate matched the\r\ntheoretical estimate quite well.  It was very satisfying to see\r\nprobability theory and the real world agreeing so closely.\r\n\r\nBeyond these specific examples, studying mathematics also influences\r\nthe way I think about problems.  Embarking on journeys like analytic\r\nnumber theory or Galois theory is humbling.  There are times when I\r\nstruggle to understand a small paragraph of the book, and it takes me\r\nseveral hours (or even days) to work out the arguments in detail with\r\npen and paper (lots of it) before I really grok them.  That experience\r\nof grappling with dense reasoning teaches humility and also makes me\r\nsceptical of complex, hand-wavy logic in day-to-day programming.\r\n\r\nSeveral times I have seen code that bundles too many decisions into\r\none block of logic, where it is not obvious whether it would behave\r\ncorrectly in all circumstances.  Explanations may sometimes be offered\r\nabout why it works for reasonable inputs, but the reasoning is often\r\nnot watertight.  The experience of working through mathematical\r\nproofs, writing my own, making mistakes, and then correcting them has\r\ntaught me that if the reasoning for correctness is not clear and\r\nrigorous, something could be wrong.  In my experience, once such code\r\nsees real-world usage, a bug is nearly always found.\r\n\r\nThat's why I usually insist either on simplifying the logic or on\r\ndemonstrating correctness in a clear, rigorous way.  Sometimes this\r\nmeans doing a case-by-case analysis for different types of inputs or\r\nconditions, and showing that the code behaves correctly in each case.\r\nThere is also a bit of an art to reducing what seem like numerous or\r\neven infinitely many cases to a small, manageable set of cases by\r\nspotting structure, such as symmetries, invariants, or natural\r\npartitions of the input space.  Alternatively, one can look for a\r\nsimpler argument that covers all cases.  These are techniques we\r\nemploy routinely in mathematics, and I think that kind of thinking and\r\nreasoning is quite valuable in software development too.","submitter_user":"veqq","user_is_author":true,"tags":["interview","person"],"short_id_url":"https://lobste.rs/s/kltoas","comments_url":"https://lobste.rs/s/kltoas/lobsters_interview_with_susam"},{"short_id":"pnq557","created_at":"2025-09-12T10:09:40.000-05:00","title":"Jef Raskin’s cul-de-sac and the quest for the humane computer","url":"https://arstechnica.com/gadgets/2025/09/jef-raskins-cul-de-sac-and-the-quest-for-the-humane-computer/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"snej","user_is_author":false,"tags":["historical","person"],"short_id_url":"https://lobste.rs/s/pnq557","comments_url":"https://lobste.rs/s/pnq557/jef_raskin_s_cul_de_sac_quest_for_humane"},{"short_id":"exbkdt","created_at":"2025-09-12T09:54:24.000-05:00","title":"oq: Terminal OpenAPI Spec viewer","url":"https://github.com/plutov/oq","score":16,"flags":0,"comment_count":3,"description":"\u003cp\u003eBuilt this project with Bubble Tea.\u003c/p\u003e\n","description_plain":"Built this project with Bubble Tea.","submitter_user":"pluto","user_is_author":true,"tags":["go"],"short_id_url":"https://lobste.rs/s/exbkdt","comments_url":"https://lobste.rs/s/exbkdt/oq_terminal_openapi_spec_viewer"},{"short_id":"kiqlsv","created_at":"2025-09-12T09:52:39.000-05:00","title":"Trail of Bits: Buttercup is now open-source","url":"https://blog.trailofbits.com/2025/08/08/buttercup-is-now-open-source/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","submitter_user":"df","user_is_author":false,"tags":["ai","security"],"short_id_url":"https://lobste.rs/s/kiqlsv","comments_url":"https://lobste.rs/s/kiqlsv/trail_bits_buttercup_is_now_open_source"}]